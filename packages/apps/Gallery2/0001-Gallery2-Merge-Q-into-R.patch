From 8ab4600b1f633a8eaa96052fa6027045d2a7b04b Mon Sep 17 00:00:00 2001
From: wh <wanghang@rock-chips.com>
Date: Mon, 28 Sep 2020 15:23:27 +0800
Subject: [PATCH 1/5] Gallery2: Merge Q into R

Signed-off-by: wh <wanghang@rock-chips.com>
Change-Id: Ic3e8e368fdf67272309331610ee32d4a6be825ab
---
 AndroidManifest.xml                           |  19 +
 .../android/gallery3d/exif/ExifParser.java    |  10 +-
 .../android/gallery3d/util/ThreadPool.java    |   4 +-
 res/layout/main.xml                           |   3 +-
 res/layout/movie_view.xml                     |   1 +
 res/menu/albumset.xml                         |   2 +-
 res/values-zh-rCN/strings.xml                 |   4 +
 res/values/filtershow_values.xml              |   2 +-
 res/values/strings.xml                        |   4 +
 res/xml/provider_paths.xml                    |   6 +
 src/android/util/ConfigUtil.java              |  12 +
 .../android/gallery3d/app/ActivityState.java  |  17 +
 .../gallery3d/app/AlbumDataLoader.java        |  15 +-
 src/com/android/gallery3d/app/AlbumPage.java  |  95 +++
 .../gallery3d/app/AlbumSetDataLoader.java     |   8 +
 .../android/gallery3d/app/AlbumSetPage.java   | 109 ++-
 .../app/CheckPermissionActivity.java          | 112 +++
 .../gallery3d/app/GalleryActivity.java        | 108 ++-
 .../android/gallery3d/app/MovieActivity.java  |  34 +-
 .../android/gallery3d/app/MoviePlayer.java    |  33 +-
 .../gallery3d/app/PackagesMonitor.java        |  13 +-
 .../gallery3d/app/PhotoDataAdapter.java       |  56 +-
 src/com/android/gallery3d/app/PhotoPage.java  | 189 ++++-
 .../android/gallery3d/app/PickerActivity.java |  37 +
 .../gallery3d/app/SinglePhotoDataAdapter.java |  23 +-
 .../gallery3d/app/SlideshowDataAdapter.java   |   2 +-
 .../android/gallery3d/app/SlideshowPage.java  |   2 +-
 .../android/gallery3d/app/StateManager.java   |  45 +-
 src/com/android/gallery3d/app/TrimVideo.java  |  32 +-
 src/com/android/gallery3d/app/Wallpaper.java  |  40 +
 .../android/gallery3d/data/ActionImage.java   |   7 +
 .../android/gallery3d/data/ClusterAlbum.java  |   8 +
 .../android/gallery3d/data/DataManager.java   |  31 +
 .../android/gallery3d/data/FilterTypeSet.java |   8 +
 .../gallery3d/data/ImageCacheRequest.java     |   8 +-
 .../gallery3d/data/ImageCacheService.java     |  22 +-
 .../android/gallery3d/data/LocalAlbum.java    |  24 +
 .../android/gallery3d/data/LocalImage.java    |  81 +-
 .../gallery3d/data/LocalMergeAlbum.java       |   8 +
 .../android/gallery3d/data/LocalVideo.java    |  35 +-
 .../android/gallery3d/data/MediaDetails.java  |   8 +
 src/com/android/gallery3d/data/MediaItem.java |  30 +
 src/com/android/gallery3d/data/SnailItem.java |   8 +
 src/com/android/gallery3d/data/UriImage.java  |  17 +-
 .../filtershow/EditorPlaceHolder.java         |   4 +-
 .../filtershow/FilterShowActivity.java        |  48 +-
 .../filtershow/crop/CropActivity.java         |  41 +-
 .../filtershow/editors/EditorColorBorder.java |   4 +-
 .../filters/FilterDrawRepresentation.java     |   3 +
 .../filtershow/imageshow/ImageShow.java       |   5 +-
 .../filtershow/imageshow/MasterImage.java     |   2 +-
 .../filtershow/pipeline/ImagePreset.java      |   3 +
 .../filtershow/pipeline/ImageSavingTask.java  |   7 +-
 .../pipeline/ProcessingService.java           |  44 +-
 .../gallery3d/filtershow/tools/SaveImage.java |   9 +-
 .../gadget/PhotoAppWidgetProvider.java        |  36 +-
 .../gallery3d/gadget/WidgetService.java       |  32 +
 .../gallery3d/glrenderer/UploadedTexture.java |  15 +-
 .../gallery3d/ingest/IngestService.java       |  25 +-
 .../gallery3d/ingest/data/MtpDeviceIndex.java |  50 +-
 .../ingest/data/MtpDeviceIndexRunnable.java   |   5 +-
 src/com/android/gallery3d/ui/GLRootView.java  |  34 +-
 src/com/android/gallery3d/ui/GLView.java      |  16 +
 .../android/gallery3d/ui/MenuExecutor.java    |  22 +-
 src/com/android/gallery3d/ui/PhotoView.java   | 109 +++
 .../gallery3d/ui/PositionController.java      |   9 +
 .../android/gallery3d/ui/TileImageView.java   | 364 ++++++++-
 .../android/gallery3d/util/BitmapUtils.java   | 215 +++++
 .../android/gallery3d/util/CacheManager.java  |   6 +
 src/com/android/gif/GifAction.java            |   6 +
 src/com/android/gif/GifDecoder.java           | 751 ++++++++++++++++++
 src/com/android/gif/GifFrame.java             |  16 +
 src/com/android/gif/GifTextrue.java           | 210 +++++
 src/com/android/gif/GifTextrueFactory.java    |  53 ++
 src/com/android/gif/Shared.java               | 134 ++++
 75 files changed, 3389 insertions(+), 221 deletions(-)
 create mode 100644 res/xml/provider_paths.xml
 create mode 100644 src/android/util/ConfigUtil.java
 create mode 100644 src/com/android/gallery3d/app/CheckPermissionActivity.java
 create mode 100644 src/com/android/gallery3d/util/BitmapUtils.java
 create mode 100644 src/com/android/gif/GifAction.java
 create mode 100644 src/com/android/gif/GifDecoder.java
 create mode 100644 src/com/android/gif/GifFrame.java
 create mode 100644 src/com/android/gif/GifTextrue.java
 create mode 100644 src/com/android/gif/GifTextrueFactory.java
 create mode 100644 src/com/android/gif/Shared.java

diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index a08b2bcae..a1298ab48 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -19,6 +19,7 @@
     <uses-permission android:name="android.permission.GET_ACCOUNTS" />
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.MANAGE_ACCOUNTS" />
+<!--    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"/>-->
     <uses-permission android:name="android.permission.NFC" />
     <uses-permission android:name="android.permission.READ_SYNC_SETTINGS" />
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
@@ -28,6 +29,7 @@
     <uses-permission android:name="android.permission.VIBRATE" />
     <uses-permission android:name="android.permission.WAKE_LOCK" />
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.WRITE_MEDIA_STORAGE" />
     <uses-permission android:name="android.permission.WRITE_SETTINGS" />
     <uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS" />
     <uses-permission android:name="com.android.gallery3d.permission.GALLERY_PROVIDER" />
@@ -234,6 +236,12 @@
             </intent-filter>
         </activity>
 
+        <activity
+            android:name=".app.CheckPermissionActivity"
+            android:configChanges="orientation|keyboardHidden|screenSize"
+            android:label="@string/app_name"
+            android:theme="@style/Theme.Gallery" />
+
         <provider
             android:name="com.android.gallery3d.filtershow.provider.SharedImageProvider"
             android:authorities="com.android.gallery3d.filtershow.provider.SharedImageProvider"
@@ -311,6 +319,7 @@
                 android:label="@string/appwidget_title">
             <intent-filter>
                 <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
+                <action android:name="widget_update" />
             </intent-filter>
             <meta-data android:name="android.appwidget.provider"
                     android:resource="@xml/widget_info" />
@@ -344,5 +353,15 @@
         </receiver>
 
         <service android:name="com.android.camera.MediaSaveService" />
+
+        <provider
+            android:name="androidx.core.content.FileProvider"
+            android:authorities="com.android.gallery3d.fileprovider"
+            android:grantUriPermissions="true"
+            android:exported="false">
+            <meta-data
+                android:name="android.support.FILE_PROVIDER_PATHS"
+                android:resource="@xml/provider_paths" />
+        </provider>
     </application>
 </manifest>
diff --git a/gallerycommon/src/com/android/gallery3d/exif/ExifParser.java b/gallerycommon/src/com/android/gallery3d/exif/ExifParser.java
index 5467d423d..3a3b71afc 100644
--- a/gallerycommon/src/com/android/gallery3d/exif/ExifParser.java
+++ b/gallerycommon/src/com/android/gallery3d/exif/ExifParser.java
@@ -558,9 +558,13 @@ class ExifParser {
             // Read the data here.
             if ((offset < mIfd0Position) && (dataFormat == ExifTag.TYPE_UNDEFINED)) {
                 byte[] buf = new byte[(int) numOfComp];
-                System.arraycopy(mDataAboveIfd0, (int) offset - DEFAULT_IFD0_OFFSET,
-                        buf, 0, (int) numOfComp);
-                tag.setValue(buf);
+                try {
+                    System.arraycopy(mDataAboveIfd0, (int) offset - DEFAULT_IFD0_OFFSET,
+                            buf, 0, (int) numOfComp);
+                    tag.setValue(buf);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
             } else {
                 tag.setOffset((int) offset);
             }
diff --git a/gallerycommon/src/com/android/gallery3d/util/ThreadPool.java b/gallerycommon/src/com/android/gallery3d/util/ThreadPool.java
index 115dc6625..e19e52aa8 100644
--- a/gallerycommon/src/com/android/gallery3d/util/ThreadPool.java
+++ b/gallerycommon/src/com/android/gallery3d/util/ThreadPool.java
@@ -130,7 +130,9 @@ public class ThreadPool {
             // if the job is cancelled.
             if (setMode(MODE_CPU)) {
                 try {
-                    result = mJob.run(this);
+                    if(mJob != null) {
+                        result = mJob.run(this);
+                    }
                 } catch (Throwable ex) {
                     Log.w(TAG, "Exception in running a job", ex);
                 }
diff --git a/res/layout/main.xml b/res/layout/main.xml
index 08e595959..c68dfb5ff 100644
--- a/res/layout/main.xml
+++ b/res/layout/main.xml
@@ -3,7 +3,8 @@
         android:id="@+id/gallery_root"
         android:orientation="vertical"
         android:layout_width="match_parent"
-        android:layout_height="match_parent">
+        android:layout_height="match_parent"
+        android:background="#1a1a1a">
     <include layout="@layout/gl_root_group"/>
     <FrameLayout android:id="@+id/header"
             android:visibility="gone"
diff --git a/res/layout/movie_view.xml b/res/layout/movie_view.xml
index 97aa156fd..ea26fa1fd 100644
--- a/res/layout/movie_view.xml
+++ b/res/layout/movie_view.xml
@@ -20,6 +20,7 @@
         android:layout_width="match_parent"
         android:layout_height="match_parent">
     <VideoView android:id="@+id/surface_view"
+            android:background="@android:color/black"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             android:layout_centerInParent="true" />
diff --git a/res/menu/albumset.xml b/res/menu/albumset.xml
index 8ac8cbbd2..8626b9d50 100644
--- a/res/menu/albumset.xml
+++ b/res/menu/albumset.xml
@@ -29,7 +29,7 @@
             android:showAsAction="never" />
     <item android:id="@+id/action_settings"
             android:title="@string/settings"
-            android:showAsAction="never" />
+            android:showAsAction="never" android:visible="false"/>
     <item android:id="@+id/action_general_help"
             android:title="@string/help"
             android:visible="false"
diff --git a/res/values-zh-rCN/strings.xml b/res/values-zh-rCN/strings.xml
index 91a6358c2..405ecd953 100644
--- a/res/values-zh-rCN/strings.xml
+++ b/res/values-zh-rCN/strings.xml
@@ -436,4 +436,8 @@
     <item quantity="one" msgid="6949174783125614798">"%1$d张照片"</item>
     <item quantity="other" msgid="3813306834113858135">"%1$d张照片"</item>
   </plurals>
+
+    <string name="movie_crop_alert">"无法剪辑：只有MP4格式视频才能剪辑"</string>
+
+    <string name="err_permission">"无权限"</string>
 </resources>
diff --git a/res/values/filtershow_values.xml b/res/values/filtershow_values.xml
index a788afefc..22e9880b5 100644
--- a/res/values/filtershow_values.xml
+++ b/res/values/filtershow_values.xml
@@ -16,7 +16,7 @@
 
 <resources>
     <!-- Specify the screen orientation -->
-    <bool name="only_use_portrait">true</bool>
+    <bool name="only_use_portrait">false</bool>
 
     <!-- Text size for the state panel -->
     <dimen name="state_panel_text_size">16dip</dimen>
diff --git a/res/values/strings.xml b/res/values/strings.xml
index 570014e3e..32a511d91 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -1115,4 +1115,8 @@ CHAR LIMIT = NONE] -->
         <item quantity="one">%1$d photo</item>
         <item quantity="other">%1$d photos</item>
     </plurals>
+
+    <string name="movie_crop_alert">Can not trim : only the MP4 video can trim</string>
+
+    <string name="err_permission">Permission Error</string>
 </resources>
diff --git a/res/xml/provider_paths.xml b/res/xml/provider_paths.xml
new file mode 100644
index 000000000..bfc744516
--- /dev/null
+++ b/res/xml/provider_paths.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<paths xmlns:android="http://schemas.android.com/apk/res/android">
+    <external-path
+        name="external_files"
+        path="." />
+</paths>
\ No newline at end of file
diff --git a/src/android/util/ConfigUtil.java b/src/android/util/ConfigUtil.java
new file mode 100644
index 000000000..560a25ea4
--- /dev/null
+++ b/src/android/util/ConfigUtil.java
@@ -0,0 +1,12 @@
+package android.util;
+
+public class ConfigUtil {
+    
+    public static boolean SUPPORT_VIDEO_TRIM = false;   
+    
+    public static boolean SUPPORT_VIDEO_MUTE = false;
+    
+    public static boolean SUPPORT_IMAGE_FILTER_SHARPEN = false;
+    
+    public static boolean SUPPORT_IMAGE_FILTER_CURVES = false;
+}
diff --git a/src/com/android/gallery3d/app/ActivityState.java b/src/com/android/gallery3d/app/ActivityState.java
index 2f1e0c9d9..01e942203 100644
--- a/src/com/android/gallery3d/app/ActivityState.java
+++ b/src/com/android/gallery3d/app/ActivityState.java
@@ -1,4 +1,5 @@
 /*
+ * $_FOR_ROCKCHIP_RBOX_$
  * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -39,6 +40,12 @@ import com.android.gallery3d.ui.GLView;
 import com.android.gallery3d.ui.PreparePageFadeoutTexture;
 import com.android.gallery3d.util.GalleryUtils;
 
+//$_rbox_$_modify_$_chengmingchuan_$20140224
+//$_rbox_$_modify_$_begin
+import android.view.KeyEvent;
+//$_rbox_$_modify_$_end
+
+
 abstract public class ActivityState {
     protected static final int FLAG_HIDE_ACTION_BAR = 1;
     protected static final int FLAG_HIDE_STATUS_BAR = 2;
@@ -254,6 +261,16 @@ abstract public class ActivityState {
         return true;
     }
 
+    // $_rbox_$_modify_$_chengmingchuan_$20140224
+    // $_rbox_$_modify_$_begin
+    protected boolean onKeyDown(int keyCode, KeyEvent event) {
+        return false;
+    }
+    public void makeDirty(){
+    }
+    // $_rbox_$_modify_$_end
+
+
     protected boolean onItemSelected(MenuItem item) {
         return false;
     }
diff --git a/src/com/android/gallery3d/app/AlbumDataLoader.java b/src/com/android/gallery3d/app/AlbumDataLoader.java
index 28a822830..1f7fab039 100644
--- a/src/com/android/gallery3d/app/AlbumDataLoader.java
+++ b/src/com/android/gallery3d/app/AlbumDataLoader.java
@@ -307,12 +307,15 @@ public class AlbumDataLoader {
                 int index = i % DATA_CACHE_SIZE;
                 mSetVersion[index] = info.version;
                 MediaItem updateItem = items.get(i - info.reloadStart);
-                long itemVersion = updateItem.getDataVersion();
-                if (mItemVersion[index] != itemVersion) {
-                    mItemVersion[index] = itemVersion;
-                    mData[index] = updateItem;
-                    if (mDataListener != null && i >= mActiveStart && i < mActiveEnd) {
-                        mDataListener.onContentChanged(i);
+                if(updateItem != null){
+                    long itemVersion = updateItem.getDataVersion();
+                    if (mItemVersion[index] != itemVersion) {
+                        mItemVersion[index] = itemVersion;
+                        mData[index] = updateItem;
+                        if (mDataListener != null && i >= mActiveStart && i < mActiveEnd) {
+                            mDataListener.onContentChanged(i);
+                        }
+
                     }
                 }
             }
diff --git a/src/com/android/gallery3d/app/AlbumPage.java b/src/com/android/gallery3d/app/AlbumPage.java
index 44f24043b..714647fa5 100644
--- a/src/com/android/gallery3d/app/AlbumPage.java
+++ b/src/com/android/gallery3d/app/AlbumPage.java
@@ -1,4 +1,5 @@
 /*
+ *$_FOR_ROCKCHIP_RBOX_$
  * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -59,6 +60,12 @@ import com.android.gallery3d.util.Future;
 import com.android.gallery3d.util.GalleryUtils;
 import com.android.gallery3d.util.MediaSetUtils;
 
+// $_rbox_$_modify_$_chengmingchuan_$20140224
+// $_rbox_$_modify_$_begin
+import android.view.KeyEvent;
+// $_rbox_$_modify_$_end
+
+
 
 public class AlbumPage extends ActivityState implements GalleryActionBar.ClusterRunner,
         SelectionManager.SelectionListener, MediaSet.SyncListener, GalleryActionBar.OnAlbumModeSelectedListener {
@@ -116,6 +123,18 @@ public class AlbumPage extends ActivityState implements GalleryActionBar.Cluster
     private Handler mHandler;
     private static final int MSG_PICK_PHOTO = 0;
 
+    //$_rbox_$_modify_$_chengmingchuan_$20140224
+    //$_rbox_$_modify_$_begin
+    private final int  FOCUS_UP=1;
+    private final int  FOCUS_DOWN=2;
+    private final int  FOCUS_LEFT = 3;
+    private final int  FOCUS_RIGHT = 4;
+    private int mCurrentFocus=0;
+
+    private int mOldFocusIndex = 0;
+    //$_rbox_$_modify_$_end
+
+
     private PhotoFallbackEffect mResumeEffect;
     private PhotoFallbackEffect.PositionProvider mPositionProvider =
             new PhotoFallbackEffect.PositionProvider() {
@@ -584,6 +603,82 @@ public class AlbumPage extends ActivityState implements GalleryActionBar.Cluster
         }
     }
 
+    //$_rbox_$_modify_$_chengmingchuan_$20140224
+    //$_rbox_$_modify_$_begin
+    private boolean moveFocus(int focus){
+        int oldFucus = mCurrentFocus;
+        switch(focus){
+            case FOCUS_UP:
+                mCurrentFocus--;
+                break;
+            case FOCUS_DOWN:
+                mCurrentFocus++;
+                break;
+            case FOCUS_LEFT:
+                mCurrentFocus -= 2;
+                break;
+            case FOCUS_RIGHT:
+                mCurrentFocus += 2;
+                break;
+            default:
+                return false;
+        }
+        if (!mAlbumDataAdapter.isActive(mCurrentFocus)) {
+            mCurrentFocus=oldFucus;
+        }
+        if (mAlbumDataAdapter.isActive(mCurrentFocus)) {
+            MediaItem item = mAlbumDataAdapter.get(mCurrentFocus);
+            Path path = (item == null) ? null : item.getPath();
+            mAlbumView.setHighlightItemPath(path);
+            mAlbumView.setPressedIndex(mCurrentFocus);
+            mSlotView.setCenterIndex(mCurrentFocus);
+            mSlotView.invalidate();
+        }
+        return true;
+    }
+    //$_rbox_$_modify_$_end
+
+    //$_rbox_$_modify_$_chengmingchuan_$20140224
+    //$_rbox_$_modify_$_begin
+    private boolean gotoPhotoPage(){
+        int slotIndex = mCurrentFocus;
+        if(!mAlbumDataAdapter.isActive(slotIndex)){
+            return false;
+        }
+
+        this.onSingleTapUp(slotIndex);
+        return true;
+    }
+    //$_rbox_$_modify_$_end
+
+    //$_rbox_$_modify_$_chengmingchuan_$20140224
+    //$_rbox_$_modify_$_begin
+    @Override
+    protected boolean onKeyDown(int keyCode, KeyEvent event) {
+        /*cancel slotview heightlight*/
+        mAlbumView.setHighlightItemPath(null);
+        mAlbumView.setPressedUp();
+        Log.d(TAG, "=========================================KeyCode="+ keyCode);
+        switch(keyCode){
+            case KeyEvent.KEYCODE_DPAD_LEFT:
+                return this.moveFocus(FOCUS_LEFT);
+            case KeyEvent.KEYCODE_DPAD_RIGHT:
+                return this.moveFocus(FOCUS_RIGHT);
+            case KeyEvent.KEYCODE_DPAD_UP:
+                return this.moveFocus(FOCUS_UP);
+            case KeyEvent.KEYCODE_DPAD_DOWN:
+                return this.moveFocus(FOCUS_DOWN);
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+            case KeyEvent.KEYCODE_ENTER:
+                return this.gotoPhotoPage();
+            default:
+                break;
+        }
+        return false;
+    }
+    //$_rbox_$_modify_$_end
+
+
     @Override
     protected boolean onItemSelected(MenuItem item) {
         switch (item.getItemId()) {
diff --git a/src/com/android/gallery3d/app/AlbumSetDataLoader.java b/src/com/android/gallery3d/app/AlbumSetDataLoader.java
index 909d9109c..131297e23 100644
--- a/src/com/android/gallery3d/app/AlbumSetDataLoader.java
+++ b/src/com/android/gallery3d/app/AlbumSetDataLoader.java
@@ -1,4 +1,5 @@
 /*
+ * $_FOR_ROCKCHIP_RBOX_$
  * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -102,6 +103,13 @@ public class AlbumSetDataLoader {
         };
     }
 
+    //$_rbox_$_modify_$_chengmingchuan_$20140224
+    //$_rbox_$_modify_$_begin
+    public void makeDirty(){
+        mReloadTask.notifyDirty();
+    }
+    //$_rbox_$_modify_$_end
+
     public void pause() {
         mReloadTask.terminate();
         mReloadTask = null;
diff --git a/src/com/android/gallery3d/app/AlbumSetPage.java b/src/com/android/gallery3d/app/AlbumSetPage.java
index d56b5b85d..ae7517215 100644
--- a/src/com/android/gallery3d/app/AlbumSetPage.java
+++ b/src/com/android/gallery3d/app/AlbumSetPage.java
@@ -1,4 +1,5 @@
 /*
+ *$_FOR_ROCKCHIP_RBOX_$ 
  * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -62,6 +63,12 @@ import com.android.gallery3d.util.HelpUtils;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 
+//$_rbox_$_modify_$_chengmingchuan_$20140224
+//$_rbox_$_modify_$_begin
+import android.view.KeyEvent;
+//$_rbox_$_modify_$_end
+
+
 public class AlbumSetPage extends ActivityState implements
         SelectionManager.SelectionListener, GalleryActionBar.ClusterRunner,
         EyePosition.EyePositionListener, MediaSet.SyncListener {
@@ -119,6 +126,17 @@ public class AlbumSetPage extends ActivityState implements
     private Button mCameraButton;
     private boolean mShowedEmptyToastForSelf = false;
 
+    //$_rbox_$_modify_$_chengmingchuan_$20140224
+    //$_rbox_$_modify_$_begin
+     private final int  FOCUS_UP=1;
+     private final int  FOCUS_DOWN=2;
+     private final int  FOCUS_LEFT = 3;
+     private final int  FOCUS_RIGHT = 4;
+     private int mCurrentFocus=0;
+     private int mOldFocusIndex = 0;
+     //$_rbox_$_modify_$_end
+
+
     @Override
     protected int getBackgroundColorId() {
         return R.color.albumset_background;
@@ -188,7 +206,7 @@ public class AlbumSetPage extends ActivityState implements
     }
 
     public void onSingleTapUp(int slotIndex) {
-        if (!mIsActive) return;
+        if (!mIsActive || !mAlbumSetDataAdapter.isActive(slotIndex)) return;
 
         if (mSelectionManager.inSelectionMode()) {
             MediaSet targetSet = mAlbumSetDataAdapter.getMediaSet(slotIndex);
@@ -235,7 +253,7 @@ public class AlbumSetPage extends ActivityState implements
     }
 
     private void pickAlbum(int slotIndex) {
-        if (!mIsActive) return;
+        if (!mIsActive || !mAlbumSetDataAdapter.isActive(slotIndex)) return;
 
         MediaSet targetSet = mAlbumSetDataAdapter.getMediaSet(slotIndex);
         if (targetSet == null) return; // Content is dirty, we shall reload soon
@@ -298,7 +316,9 @@ public class AlbumSetPage extends ActivityState implements
     }
 
     public void onLongTap(int slotIndex) {
-        if (mGetContent || mGetAlbum) return;
+        if (mGetContent || mGetAlbum
+                || !mIsActive || !mAlbumSetDataAdapter.isActive(slotIndex))
+            return;
         MediaSet set = mAlbumSetDataAdapter.getMediaSet(slotIndex);
         if (set == null) return;
         mSelectionManager.setAutoLeaveSelectionMode(true);
@@ -573,6 +593,88 @@ public class AlbumSetPage extends ActivityState implements
         return true;
     }
 
+      //$_rbox_$_modify_$_chengmingchuan_$20140224
+      //$_rbox_$_modify_$_begin
+      private boolean moveFocus(int focus){
+         int oldFucus = mCurrentFocus;
+         switch(focus){
+            case FOCUS_UP:
+                mCurrentFocus--;
+                break;
+            case FOCUS_DOWN:
+                mCurrentFocus++;
+                break;
+            case FOCUS_LEFT:
+                mCurrentFocus -= 2;
+                break;
+            case FOCUS_RIGHT:
+                mCurrentFocus += 2;
+                break;
+            default:
+                return false;
+         }
+         if(!mAlbumSetDataAdapter.isActive(mCurrentFocus)){
+            mCurrentFocus=oldFucus;
+         }
+
+         if(mAlbumSetDataAdapter.isActive(mCurrentFocus)){
+            MediaSet set = mAlbumSetDataAdapter.getMediaSet(mCurrentFocus);
+            Path path = (set == null) ? null : set.getPath();
+            mAlbumSetView.setHighlightItemPath(path);
+            mAlbumSetView.setPressedIndex(mCurrentFocus);
+            mSlotView.setCenterIndex(mCurrentFocus);
+            mSlotView.invalidate();
+         }
+      
+         return true;
+      }
+      //$_rbox_$_modify_$_end
+      
+      //$_rbox_$_modify_$_chengmingchuan_$20140224
+      //$_rbox_$_modify_$_begin
+      private boolean gotoAlbum(){
+            int slotIndex = mCurrentFocus;
+        onSingleTapUp(slotIndex);
+       return true;
+      }
+      //$_rbox_$_modify_$_end
+    
+     //$_rbox_$_modify_$_chengmingchuan_$20140224
+     //$_rbox_$_modify_$_begin
+      @Override
+      public void makeDirty(){
+          this.mAlbumSetDataAdapter.makeDirty();
+      }
+      //$_rbox_$_modify_$_end
+    
+      //$_rbox_$_modify_$_chengmingchuan_$20140224
+      //$_rbox_$_modify_$_begin
+      @Override
+      protected boolean onKeyDown(int keyCode, KeyEvent event) {
+          /*cancel slotview heightlight*/
+           mAlbumSetView.setHighlightItemPath(null);
+       mAlbumSetView.setPressedUp();
+       Log.d(TAG, "=========================================KeyCode="+ keyCode);
+       switch(keyCode){
+          case KeyEvent.KEYCODE_DPAD_LEFT:
+              return this.moveFocus(FOCUS_LEFT);
+          case KeyEvent.KEYCODE_DPAD_RIGHT:
+              return this.moveFocus(FOCUS_RIGHT);
+          case KeyEvent.KEYCODE_DPAD_UP:
+              return this.moveFocus(FOCUS_UP);
+          case KeyEvent.KEYCODE_DPAD_DOWN:
+              return this.moveFocus(FOCUS_DOWN);
+          case KeyEvent.KEYCODE_DPAD_CENTER:      
+          case KeyEvent.KEYCODE_ENTER:
+              return this.gotoAlbum(); 
+          default:
+              break;
+          }    
+          return false;
+    }
+    //$_rbox_$_modify_$_end
+
+
     @Override
     protected boolean onItemSelected(MenuItem item) {
         Activity activity = mActivity;
@@ -752,6 +854,7 @@ public class AlbumSetPage extends ActivityState implements
 
         @Override
         public MediaDetails getDetails() {
+            if (!mAlbumSetDataAdapter.isActive(mIndex)) return null;
             MediaObject item = mAlbumSetDataAdapter.getMediaSet(mIndex);
             if (item != null) {
                 mAlbumSetView.setHighlightItemPath(item.getPath());
diff --git a/src/com/android/gallery3d/app/CheckPermissionActivity.java b/src/com/android/gallery3d/app/CheckPermissionActivity.java
new file mode 100644
index 000000000..a3e3db401
--- /dev/null
+++ b/src/com/android/gallery3d/app/CheckPermissionActivity.java
@@ -0,0 +1,112 @@
+package com.android.gallery3d.app;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.widget.Toast;
+
+import com.android.gallery3d.R;
+
+/**
+ * Created by waha on 2017/12/5.
+ */
+
+public class CheckPermissionActivity extends Activity {
+    public static final int REQUEST_CODE_ASK_PERMISSIONS = 124;
+    private static String mJumpActivityName;
+    public static final String[] REQUEST_PERMISSIONS = new String[]{
+            Manifest.permission.WRITE_EXTERNAL_STORAGE,
+            Manifest.permission.READ_EXTERNAL_STORAGE,
+            Manifest.permission.RECORD_AUDIO,
+            Manifest.permission.CAMERA,
+            //Manifest.permission.ACCESS_FINE_LOCATION,
+            //Manifest.permission.ACCESS_COARSE_LOCATION,
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        requestPermissions(REQUEST_PERMISSIONS, REQUEST_CODE_ASK_PERMISSIONS);
+    }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        switch (requestCode) {
+            case REQUEST_CODE_ASK_PERMISSIONS:
+                if (null == grantResults || grantResults.length < 1) {//monkey maybe enter
+                    String toast_text = getResources().getString(R.string.err_permission);
+                    Toast.makeText(CheckPermissionActivity.this, toast_text,
+                            Toast.LENGTH_SHORT).show();
+                    finish();
+                    return;
+                } else {
+                    for (int result : grantResults) {
+                        if (result != PackageManager.PERMISSION_GRANTED) {
+                            // Permission Denied
+                            String toast_text = getResources().getString(R.string.err_permission);
+                            Toast.makeText(CheckPermissionActivity.this, toast_text,
+                                    Toast.LENGTH_SHORT).show();
+                            finish();
+                            return;
+                        }
+                    }
+                }
+                // Permission Granted
+                back2JumpActivity();
+                break;
+            default:
+                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        }
+
+    }
+
+    private void back2JumpActivity() {
+        Intent intent = null;
+        try {
+            intent = new Intent(this, Class.forName(mJumpActivityName));
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+            finish();
+            return;
+        }
+        if (null != getIntent()) {
+            intent.setAction(getIntent().getAction());
+            intent.setDataAndType(getIntent().getData(), getIntent().getType());
+        }
+        startActivity(intent);
+        finish();
+    }
+
+    public static boolean jump2PermissionActivity(Activity activity, Intent intent) {
+        if (hasUnauthorizedPermission(activity)) {
+            Intent newIntent = new Intent(activity, CheckPermissionActivity.class);
+            if (null != intent) {
+                //not action:newIntent.setAction(intent.getAction());
+                newIntent.setDataAndType(intent.getData(), intent.getType());
+                if (null != intent.getExtras()) {
+                    newIntent.putExtras(intent.getExtras());
+                }
+                newIntent.setFlags(intent.getFlags());
+            }
+            activity.startActivity(newIntent);
+            mJumpActivityName = activity.getComponentName().getClassName();
+            return true;
+        }
+        return false;
+    }
+
+    public static boolean hasUnauthorizedPermission(Activity activity) {
+        for (String permission : REQUEST_PERMISSIONS) {
+            if (PackageManager.PERMISSION_GRANTED != activity.checkSelfPermission(permission)) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/com/android/gallery3d/app/GalleryActivity.java b/src/com/android/gallery3d/app/GalleryActivity.java
index bb2a6b8f1..878b44d1e 100644
--- a/src/com/android/gallery3d/app/GalleryActivity.java
+++ b/src/com/android/gallery3d/app/GalleryActivity.java
@@ -16,11 +16,13 @@
 
 package com.android.gallery3d.app;
 
+import android.app.ActivityManager;
 import android.app.Dialog;
 import android.content.ContentResolver;
 import android.content.DialogInterface;
 import android.content.DialogInterface.OnCancelListener;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Bundle;
 import android.view.InputDevice;
@@ -39,6 +41,16 @@ import com.android.gallery3d.data.Path;
 import com.android.gallery3d.picasasource.PicasaSource;
 import com.android.gallery3d.util.GalleryUtils;
 
+// $_rbox_$_modify_$_chengmingchuan_$20140225
+// $_rbox_$_modify_$_begin
+import android.view.KeyEvent;
+import android.os.Environment;
+import com.android.gallery3d.ui.GLRootView;
+import com.android.gallery3d.ui.GLRoot;
+import android.content.Context;
+// $_rbox_$_modify_$_end
+
+
 public final class GalleryActivity extends AbstractGalleryActivity implements OnCancelListener {
     public static final String EXTRA_SLIDESHOW = "slideshow";
     public static final String EXTRA_DREAM = "dream";
@@ -53,6 +65,7 @@ public final class GalleryActivity extends AbstractGalleryActivity implements On
 
     private static final String TAG = "GalleryActivity";
     private Dialog mVersionCheckDialog;
+    private boolean mUnInit;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -70,7 +83,13 @@ public final class GalleryActivity extends AbstractGalleryActivity implements On
         if (savedInstanceState != null) {
             getStateManager().restoreFromState(savedInstanceState);
         } else {
-            initializeByIntent();
+            if (CheckPermissionActivity.hasUnauthorizedPermission(this)) {
+                requestPermissions(CheckPermissionActivity.REQUEST_PERMISSIONS,
+                        CheckPermissionActivity.REQUEST_CODE_ASK_PERMISSIONS);
+                mUnInit = true;
+            } else {
+                initializeByIntent();
+            }
         }
     }
 
@@ -173,7 +192,7 @@ public final class GalleryActivity extends AbstractGalleryActivity implements On
                 int typeBits = GalleryUtils.determineTypeBits(this, intent);
                 data.putInt(KEY_TYPE_BITS, typeBits);
                 data.putString(AlbumSetPage.KEY_MEDIA_PATH,
-                        getDataManager().getTopSetPath(typeBits));
+                        getDataManager().getTopSetPath(DataManager.INCLUDE_ALL));
                 getStateManager().startState(AlbumSetPage.class, data);
             } else if (contentType.startsWith(
                     ContentResolver.CURSOR_DIR_BASE_TYPE)) {
@@ -202,7 +221,12 @@ public final class GalleryActivity extends AbstractGalleryActivity implements On
                     startDefaultPage();
                 }
             } else {
-                Path itemPath = dm.findPathByUri(uri, contentType);
+//                Path itemPath = dm.findPathByUri(uri, contentType);
+                String type = contentType;
+                if(type.trim().equals("*/*")){
+                    type = "image/*";
+                }
+                Path itemPath = dm.findPathByUri(uri, type);
                 Path albumPath = dm.getDefaultSetOf(itemPath);
 
                 data.putString(PhotoPage.KEY_MEDIA_ITEM_PATH, itemPath.toString());
@@ -230,7 +254,23 @@ public final class GalleryActivity extends AbstractGalleryActivity implements On
 
     @Override
     protected void onResume() {
-        Utils.assertTrue(getStateManager().getStateCount() > 0);
+        if (mUnInit) {
+            super.onResume();
+            return;
+        }
+        try {
+            Utils.assertTrue(getStateManager().getStateCount() > 0);
+        } catch (AssertionError e) {
+            if (ActivityManager.isUserAMonkey()) {
+                super.onResume();
+                mVersionCheckDialog = null;
+                Log.v(TAG, "jump AssertionError during monkey with onResume");
+                finish();
+                return;
+            } else {
+                throw new AssertionError();
+            }
+        }
         super.onResume();
         if (mVersionCheckDialog != null) {
             mVersionCheckDialog.show();
@@ -252,6 +292,40 @@ public final class GalleryActivity extends AbstractGalleryActivity implements On
         }
     }
 
+
+    // $_rbox_$_modify_$_chengmingchuan_$_20140225_$_[Info: Handle Keycode]
+    // $_rbox_$_modify_$_begin
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+         if(KeyEvent.KEYCODE_BACK==keyCode){
+         this.onBackPressed();
+         return true;
+     }
+
+     GLRoot root = getGLRoot();
+        root.lockRenderThread();
+        try {
+         boolean flag = getStateManager().onKeyDown(keyCode, event);
+         if(flag){
+          ((GLRootView)root).setFocusable(true);
+          ((GLRootView)root).requestFocus();
+         }else{
+             ((GLRootView)root).setFocusable(false);
+         }
+            return flag||super.onKeyDown(keyCode, event);
+        } catch (AssertionError e){
+            if (ActivityManager.isUserAMonkey()) {
+                Log.v(TAG, "jump AssertionError during monkey with onKeyDown");
+            } else {
+                throw new AssertionError();
+            }
+            return super.onKeyDown(keyCode, event);
+        } finally {
+            root.unlockRenderThread();
+       }
+    }
+    // $_rbox_$_modify_$_end
+
     @Override
     public boolean onGenericMotionEvent(MotionEvent event) {
         final boolean isTouchPad = (event.getSource()
@@ -272,4 +346,30 @@ public final class GalleryActivity extends AbstractGalleryActivity implements On
         }
         return super.onGenericMotionEvent(event);
     }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        switch (requestCode) {
+            case CheckPermissionActivity.REQUEST_CODE_ASK_PERMISSIONS:
+                for (int result : grantResults) {
+                    if (result != PackageManager.PERMISSION_GRANTED) {
+                        // Permission Denied
+                        String toast_text = getResources().getString(R.string.err_permission);
+                            Toast.makeText(this, toast_text, Toast.LENGTH_SHORT).show();
+                        finish();
+                        return;
+                    }
+                }
+                // Permission Granted
+                mUnInit = false;
+                initializeByIntent();
+                Utils.assertTrue(getStateManager().getStateCount() > 0);
+                if (mVersionCheckDialog != null) {
+                    mVersionCheckDialog.show();
+                }
+                break;
+            default:
+                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        }
+    }
 }
diff --git a/src/com/android/gallery3d/app/MovieActivity.java b/src/com/android/gallery3d/app/MovieActivity.java
index a92a46ded..5934bf711 100644
--- a/src/com/android/gallery3d/app/MovieActivity.java
+++ b/src/com/android/gallery3d/app/MovieActivity.java
@@ -77,6 +77,10 @@ public class MovieActivity extends Activity {
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        if (CheckPermissionActivity.jump2PermissionActivity(this, getIntent())) {
+            finish();
+            return;
+        }
 
         requestWindowFeature(Window.FEATURE_ACTION_BAR);
         requestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);
@@ -238,37 +242,51 @@ public class MovieActivity extends Activity {
 
     @Override
     public void onPause() {
-        mPlayer.onPause();
+        if (null != mPlayer) {
+            mPlayer.onPause();
+        }
         super.onPause();
     }
 
     @Override
     public void onResume() {
-        mPlayer.onResume();
+        if (null != mPlayer) {
+            mPlayer.onResume();
+        }
         super.onResume();
     }
 
     @Override
     public void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
-        mPlayer.onSaveInstanceState(outState);
+        if (null != mPlayer) {
+            mPlayer.onSaveInstanceState(outState);
+        }
     }
 
     @Override
     public void onDestroy() {
-        mPlayer.onDestroy();
+        if (null != mPlayer) {
+            mPlayer.onDestroy();
+        }
         super.onDestroy();
     }
 
     @Override
     public boolean onKeyDown(int keyCode, KeyEvent event) {
-        return mPlayer.onKeyDown(keyCode, event)
-                || super.onKeyDown(keyCode, event);
+        boolean playKey = false;
+        if (null != mPlayer) {
+            playKey = mPlayer.onKeyDown(keyCode, event);
+        }
+        return playKey || super.onKeyDown(keyCode, event);
     }
 
     @Override
     public boolean onKeyUp(int keyCode, KeyEvent event) {
-        return mPlayer.onKeyUp(keyCode, event)
-                || super.onKeyUp(keyCode, event);
+        boolean playKey = false;
+        if (null != mPlayer) {
+            playKey = mPlayer.onKeyUp(keyCode, event);
+        }
+        return playKey || super.onKeyUp(keyCode, event);
     }
 }
diff --git a/src/com/android/gallery3d/app/MoviePlayer.java b/src/com/android/gallery3d/app/MoviePlayer.java
index f6bd36725..0e99894bc 100644
--- a/src/com/android/gallery3d/app/MoviePlayer.java
+++ b/src/com/android/gallery3d/app/MoviePlayer.java
@@ -25,6 +25,7 @@ import android.content.DialogInterface.OnCancelListener;
 import android.content.DialogInterface.OnClickListener;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.graphics.Color;
 import android.media.AudioManager;
 import android.media.MediaPlayer;
 import android.media.audiofx.AudioEffect;
@@ -171,7 +172,8 @@ public class MoviePlayer implements
         mVideoView.postDelayed(new Runnable() {
             @Override
             public void run() {
-                mVideoView.setVisibility(View.VISIBLE);
+                //mVideoView.setVisibility(View.VISIBLE);
+                mVideoView.setBackgroundColor(Color.TRANSPARENT);
             }
         }, BLACK_TIMEOUT);
 
@@ -421,6 +423,7 @@ public class MoviePlayer implements
         switch (keyCode) {
             case KeyEvent.KEYCODE_HEADSETHOOK:
             case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+            case KeyEvent.KEYCODE_DPAD_CENTER:
                 if (mVideoView.isPlaying()) {
                     pauseVideo();
                 } else {
@@ -442,6 +445,34 @@ public class MoviePlayer implements
                 // TODO: Handle next / previous accordingly, for now we're
                 // just consuming the events.
                 return true;
+            case KeyEvent.KEYCODE_DPAD_LEFT:
+                if (mVideoView.canSeekBackward()) {
+                    pauseVideo();
+                    mController.setSeekable(true);
+                    int currentTime = mVideoView.getCurrentPosition() - 5000;
+                    currentTime = currentTime > 0 ? currentTime : 0;
+                    int totalTime = mVideoView.getDuration();
+                    mVideoView.seekTo(currentTime);
+                    setProgress();
+                } else 
+                    mController.setSeekable(false);
+                return true;
+            case KeyEvent.KEYCODE_DPAD_RIGHT:
+                if (mVideoView.canSeekForward()) {
+                    pauseVideo();
+                    mController.setSeekable(true);
+                    int currentTime = mVideoView.getCurrentPosition() + 5000;
+                    int totalTime = mVideoView.getDuration();
+                    currentTime = currentTime > totalTime ? totalTime : currentTime;
+                    mVideoView.seekTo(currentTime);
+                    setProgress();
+                } else 
+                    mController.setSeekable(false);
+                return true;
+            case KeyEvent.KEYCODE_DPAD_DOWN:
+            case KeyEvent.KEYCODE_DPAD_UP:
+                mController.show();
+                return true;
         }
         return false;
     }
diff --git a/src/com/android/gallery3d/app/PackagesMonitor.java b/src/com/android/gallery3d/app/PackagesMonitor.java
index be262fd7f..9b2412f1b 100644
--- a/src/com/android/gallery3d/app/PackagesMonitor.java
+++ b/src/com/android/gallery3d/app/PackagesMonitor.java
@@ -22,7 +22,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
 import android.preference.PreferenceManager;
-import androidx.core.app.JobIntentService;
 
 import com.android.gallery3d.picasasource.PicasaSource;
 import com.android.gallery3d.util.LightCycleHelper;
@@ -38,18 +37,16 @@ public class PackagesMonitor extends BroadcastReceiver {
     @Override
     public void onReceive(final Context context, final Intent intent) {
         intent.setClass(context, AsyncService.class);
-        AsyncService.enqueueWork(context, intent);
+        context.startService(intent);
     }
 
-    public static class AsyncService extends JobIntentService {
-        public static final int JOB_ID = 1;
-
-        public static void enqueueWork(Context context, Intent work) {
-            enqueueWork(context, AsyncService.class, JOB_ID, work);
+    public static class AsyncService extends IntentService {
+        public AsyncService() {
+            super("GalleryPackagesMonitorAsync");
         }
 
         @Override
-        protected void onHandleWork(Intent intent) {
+        protected void onHandleIntent(Intent intent) {
             onReceiveAsync(this, intent);
         }
     }
diff --git a/src/com/android/gallery3d/app/PhotoDataAdapter.java b/src/com/android/gallery3d/app/PhotoDataAdapter.java
index fd3a7cf73..768484dd7 100644
--- a/src/com/android/gallery3d/app/PhotoDataAdapter.java
+++ b/src/com/android/gallery3d/app/PhotoDataAdapter.java
@@ -30,6 +30,7 @@ import com.android.gallery3d.data.MediaObject;
 import com.android.gallery3d.data.MediaSet;
 import com.android.gallery3d.data.Path;
 import com.android.gallery3d.glrenderer.TiledTexture;
+import com.android.gallery3d.ui.BitmapScreenNail;
 import com.android.gallery3d.ui.PhotoView;
 import com.android.gallery3d.ui.ScreenNail;
 import com.android.gallery3d.ui.SynchronizedHandler;
@@ -49,6 +50,7 @@ import java.util.HashSet;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.FutureTask;
+import com.android.gallery3d.data.SnailItem;
 
 public class PhotoDataAdapter implements PhotoPage.Model {
     @SuppressWarnings("unused")
@@ -66,6 +68,8 @@ public class PhotoDataAdapter implements PhotoPage.Model {
 
     private static final int BIT_SCREEN_NAIL = 1;
     private static final int BIT_FULL_IMAGE = 2;
+    
+    private AppBridge mAppBridge;
 
     // sImageFetchSeq is the fetching sequence for images.
     // We want to fetch the current screennail first (offset = 0), the next
@@ -163,6 +167,10 @@ public class PhotoDataAdapter implements PhotoPage.Model {
 
     private final SourceListener mSourceListener = new SourceListener();
     private final TiledTexture.Uploader mUploader;
+    
+    public int getSize() {
+        return mSize;
+    }
 
     // The path of the current viewing item will be stored in mItemPath.
     // If mItemPath is not null, mCurrentIndex is only a hint for where we
@@ -171,7 +179,7 @@ public class PhotoDataAdapter implements PhotoPage.Model {
     // preview. If cameraIndex < 0, there is no camera preview.
     public PhotoDataAdapter(AbstractGalleryActivity activity, PhotoView view,
             MediaSet mediaSet, Path itemPath, int indexHint, int cameraIndex,
-            boolean isPanorama, boolean isStaticCamera) {
+            boolean isPanorama, boolean isStaticCamera,AppBridge tmpAppBirdge) {
         mSource = Utils.checkNotNull(mediaSet);
         mPhotoView = Utils.checkNotNull(view);
         mItemPath = Utils.checkNotNull(itemPath);
@@ -181,6 +189,7 @@ public class PhotoDataAdapter implements PhotoPage.Model {
         mIsStaticCamera = isStaticCamera;
         mThreadPool = activity.getThreadPool();
         mNeedFullImage = true;
+        mAppBridge = tmpAppBirdge;
 
         Arrays.fill(mChanges, MediaObject.INVALID_DATA_VERSION);
 
@@ -393,6 +402,10 @@ public class PhotoDataAdapter implements PhotoPage.Model {
     }
 
     private void updateCurrentIndex(int index) {
+        int m = index % DATA_CACHE_SIZE;
+        if(m < 0 || m >= mData.length){
+            return;
+        }
         if (mCurrentIndex == index) return;
         mCurrentIndex = index;
         updateSlidingWindow();
@@ -562,6 +575,10 @@ public class PhotoDataAdapter implements PhotoPage.Model {
     public int getCurrentIndex() {
         return mCurrentIndex;
     }
+    
+    public MediaItem getCurrentMediaItem() {
+        return mData[mCurrentIndex % DATA_CACHE_SIZE];
+    }
 
     @Override
     public MediaItem getMediaItem(int offset) {
@@ -701,6 +718,10 @@ public class PhotoDataAdapter implements PhotoPage.Model {
             // a Bitmap and then wrap it in a BitmapScreenNail instead.
             ScreenNail s = mItem.getScreenNail();
             if (s != null) return s;
+            if(mItem instanceof SnailItem){
+                s  = mAppBridge.attachScreenNail();
+                return s;
+            }
 
             // If this is a temporary item, don't try to get its bitmap because
             // it won't be available. We will get its bitmap after a data reload.
@@ -714,7 +735,7 @@ public class PhotoDataAdapter implements PhotoPage.Model {
                 bitmap = BitmapUtils.rotateBitmap(bitmap,
                     mItem.getRotation() - mItem.getFullImageRotation(), true);
             }
-            return bitmap == null ? null : new TiledScreenNail(bitmap);
+            return bitmap == null ? null : new BitmapScreenNail(bitmap);
         }
     }
 
@@ -1038,8 +1059,14 @@ public class PhotoDataAdapter implements PhotoPage.Model {
                     info.size = mSource.getMediaItemCount();
                 }
                 if (!info.reloadContent) continue;
-                info.items = mSource.getMediaItem(
-                        info.contentStart, info.contentEnd);
+                try {
+                    info.items = mSource.getMediaItem(
+                            info.contentStart, info.contentEnd);
+                }
+                catch (Exception e){
+                    e.printStackTrace();
+                    return;
+                }
 
                 int index = MediaSet.INDEX_NOT_FOUND;
 
@@ -1049,16 +1076,21 @@ public class PhotoDataAdapter implements PhotoPage.Model {
                     mFocusHintPath = null;
                 }
 
-                // Otherwise try to see if the currently focused item can be found.
-                if (index == MediaSet.INDEX_NOT_FOUND) {
-                    MediaItem item = findCurrentMediaItem(info);
-                    if (item != null && item.getPath() == info.target) {
-                        index = info.indexHint;
-                    } else {
-                        index = findIndexOfTarget(info);
+                try {
+                    // Otherwise try to see if the currently focused item can be found.
+                    if (index == MediaSet.INDEX_NOT_FOUND) {
+                        MediaItem item = findCurrentMediaItem(info);
+                        if (item != null && item.getPath() == info.target) {
+                            index = info.indexHint;
+                        } else {
+                            index = findIndexOfTarget(info);
+                        }
                     }
                 }
-
+                catch (Exception e){ 
+                    e.printStackTrace();
+                    return;
+                }
                 // The image has been deleted. Focus on the next image (keep
                 // mCurrentIndex unchanged) or the previous image (decrease
                 // mCurrentIndex by 1). In page mode we want to see the next
diff --git a/src/com/android/gallery3d/app/PhotoPage.java b/src/com/android/gallery3d/app/PhotoPage.java
index 915fdab5a..a92ec47a9 100644
--- a/src/com/android/gallery3d/app/PhotoPage.java
+++ b/src/com/android/gallery3d/app/PhotoPage.java
@@ -1,4 +1,5 @@
 /*
+ * $_FOR_ROCKCHIP_RBOX_$
  * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -16,12 +17,19 @@
 
 package com.android.gallery3d.app;
 
+import java.io.File;
+import java.util.ArrayList;
+
 import android.annotation.TargetApi;
 import android.app.ActionBar.OnMenuVisibilityListener;
+import android.app.ActivityManager.RunningServiceInfo;
 import android.app.Activity;
+import android.app.ActivityManager;
 import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.graphics.Rect;
@@ -39,6 +47,7 @@ import android.view.View;
 import android.widget.RelativeLayout;
 import android.widget.ShareActionProvider;
 import android.widget.Toast;
+import androidx.core.content.FileProvider;
 
 import com.android.gallery3d.R;
 import com.android.gallery3d.common.ApiHelper;
@@ -73,6 +82,11 @@ import com.android.gallery3d.ui.SynchronizedHandler;
 import com.android.gallery3d.util.GalleryUtils;
 import com.android.gallery3d.util.UsageStatistics;
 
+//$_rbox_$_modify_$_chengmingchuan_$_20140225_$_[Info: Handle Keycode]
+//$_rbox_$_modify_$_begin
+import android.view.KeyEvent;
+//$_rbox_$_modify_$_end
+
 public abstract class PhotoPage extends ActivityState implements
         PhotoView.Listener, AppBridge.Server, ShareActionProvider.OnShareTargetSelectedListener,
         PhotoPageBottomControls.Delegate, GalleryActionBar.OnAlbumModeSelectedListener {
@@ -185,6 +199,10 @@ public abstract class PhotoPage extends ActivityState implements
             new MyMenuVisibilityListener();
 
     private int mLastSystemUiVis = 0;
+    
+    public static final String PHOTOPAGE_UPDATE="photopage_view_update";
+    private BroadcastReceiver mSwitchReceiver;
+    private int  jumpToIndex = 0;
 
     private final PanoramaSupportCallback mUpdatePanoramaMenuItemsCallback = new PanoramaSupportCallback() {
         @Override
@@ -224,6 +242,8 @@ public abstract class PhotoPage extends ActivityState implements
         public void pause();
         public boolean isEmpty();
         public void setCurrentPhoto(Path path, int indexHint);
+        //jyzheng add 
+        public MediaItem getCurrentMediaItem();
     }
 
     private class MyMenuVisibilityListener implements OnMenuVisibilityListener {
@@ -276,7 +296,8 @@ public abstract class PhotoPage extends ActivityState implements
                         if (mCurrentPhoto == message.obj && mBottomControls != null) {
                             mIsPanorama = message.arg1 == 1;
                             mIsPanorama360 = message.arg2 == 1;
-                            mBottomControls.refresh();
+                            /**not show bottom item anymore*/
+                            //mBottomControls.refresh();
                         }
                         break;
                     }
@@ -357,11 +378,14 @@ public abstract class PhotoPage extends ActivityState implements
                         if (mCurrentPhoto == message.obj) {
                             boolean isPanorama360 = message.arg1 != 0;
                             Uri contentUri = mCurrentPhoto.getContentUri();
+                            if (null != mActivity) {
+                                contentUri = adjustFileUri(mActivity.getAndroidContext(), contentUri);
+                            }
                             Intent panoramaIntent = null;
                             if (isPanorama360) {
                                 panoramaIntent = createSharePanoramaIntent(contentUri);
                             }
-                            Intent shareIntent = createShareIntent(mCurrentPhoto);
+                            Intent shareIntent = createShareIntent(mCurrentPhoto, contentUri);
 
                             mActionBar.setShareIntents(panoramaIntent, shareIntent, PhotoPage.this);
                             setNfcBeamPushUri(contentUri);
@@ -390,7 +414,8 @@ public abstract class PhotoPage extends ActivityState implements
                     null;
         mTreatBackAsUp = data.getBoolean(KEY_TREAT_BACK_AS_UP, false);
         mStartInFilmstrip = data.getBoolean(KEY_START_IN_FILMSTRIP, false);
-        boolean inCameraRoll = data.getBoolean(KEY_IN_CAMERA_ROLL, false);
+        //boolean inCameraRoll = data.getBoolean(KEY_IN_CAMERA_ROLL, false);
+        boolean inCameraRoll = false;
         mCurrentIndex = data.getInt(KEY_INDEX_HINT, 0);
         if (mSetPathString != null) {
             mShowSpinner = true;
@@ -469,7 +494,7 @@ public abstract class PhotoPage extends ActivityState implements
                     mActivity, mPhotoView, mMediaSet, itemPath, mCurrentIndex,
                     mAppBridge == null ? -1 : 0,
                     mAppBridge == null ? false : mAppBridge.isPanorama(),
-                    mAppBridge == null ? false : mAppBridge.isStaticCamera());
+                    mAppBridge == null ? false : mAppBridge.isStaticCamera(),mAppBridge);
             mModel = pda;
             mPhotoView.setModel(mModel);
 
@@ -510,6 +535,7 @@ public abstract class PhotoPage extends ActivityState implements
                     }
                     // Reset the timeout for the bars after a swipe
                     refreshHidingMessage();
+                    mPhotoView.updateCurrentIndex();
                 }
 
                 @Override
@@ -564,6 +590,23 @@ public abstract class PhotoPage extends ActivityState implements
                 });
     }
 
+    private static Uri adjustFileUri(Context context, Uri oldUri) {
+        if (null == oldUri || null == oldUri.toString()) {
+            return oldUri;
+        }
+        try{
+            if (oldUri.toString().startsWith("file:///storage")) {
+                Uri uri = FileProvider.getUriForFile(context,
+                        "com.android.gallery3d.fileprovider",
+                        new File(oldUri.getPath()));
+                return uri;
+            }
+        } catch(Exception e) {
+            e.printStackTrace();
+        }
+        return oldUri;
+    }
+
     @Override
     public void onPictureCenter(boolean isCamera) {
         isCamera = isCamera || (mHasCameraScreennailOrPlaceholder && mAppBridge == null);
@@ -637,11 +680,11 @@ public abstract class PhotoPage extends ActivityState implements
         mNfcPushUris[0] = uri;
     }
 
-    private static Intent createShareIntent(MediaObject mediaObject) {
+    private static Intent createShareIntent(MediaObject mediaObject, Uri contentUri) {
         int type = mediaObject.getMediaType();
         return new Intent(Intent.ACTION_SEND)
                 .setType(MenuExecutor.getMimeType(type))
-                .putExtra(Intent.EXTRA_STREAM, mediaObject.getContentUri())
+                .putExtra(Intent.EXTRA_STREAM, contentUri)
                 .addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
     }
 
@@ -1004,6 +1047,90 @@ public abstract class PhotoPage extends ActivityState implements
             }
         }
     }
+    
+    
+   //$_rbox_$_modify_$_chengmingchuan_$_20140225_$_[Info: Handle Keycode]
+    //$_rbox_$_modify_$_begin
+    @Override
+    protected boolean onKeyDown(int keyCode, KeyEvent event) {
+         Log.d(TAG, "=========================================KeyCode="+ keyCode);
+     switch(keyCode){
+        case KeyEvent.KEYCODE_DPAD_LEFT:
+            return mPhotoView.slideShowImage(mPhotoView.SLIDE_LEFT, mShowBars);
+        case KeyEvent.KEYCODE_DPAD_RIGHT:
+            return mPhotoView.slideShowImage(mPhotoView.SLIDE_RIGHT, mShowBars);
+        case KeyEvent.KEYCODE_DPAD_UP:
+            return mPhotoView.slideShowImage(mPhotoView.SLIDE_LEFT, mShowBars);
+        case KeyEvent.KEYCODE_DPAD_DOWN:
+            return mPhotoView.slideShowImage(mPhotoView.SLIDE_RIGHT, mShowBars);
+        case KeyEvent.KEYCODE_DPAD_CENTER: 
+        case KeyEvent.KEYCODE_ENTER:
+            return this.onOkPressed();
+        default:
+            break;
+            /*
+        case KeyEvent.KEYCODE_TV_ROTATE_LEFT:
+            MediaItem current1 = mModel.getMediaItem(0);
+                     Path path1 = current1.getPath();
+            mSelectionManager.deSelectAll();
+            mSelectionManager.toggle(path1);
+            mMenuExecutor.startAction(R.id.action_rotate_ccw, R.string.rotate_left, null);
+            return true;
+        case KeyEvent.KEYCODE_TV_ROTATE_RIGHT:
+            MediaItem current2 = mModel.getMediaItem(0);
+                     Path path2 = current2.getPath();
+            mSelectionManager.deSelectAll();
+            mSelectionManager.toggle(path2);
+            mMenuExecutor.startAction(R.id.action_rotate_cw, R.string.rotate_right, null);
+            return true;
+        case KeyEvent.KEYCODE_TV_ZOOM_IN:
+            mPhotoView.scalingImage(mPhotoView.ZOOMIN);
+            return true;
+        case KeyEvent.KEYCODE_TV_ZOOM_OUT:
+            mPhotoView.scalingImage(mPhotoView.ZOOMOUT);
+            return true;
+        */
+     }
+     return false;
+    }
+    //$_rbox_$_modify_$_end
+
+    //$_rbox_$_modify_$_chengmingchuan
+    //$_rbox_$_modify_$_begin
+    private boolean onOkPressed(){
+     MediaItem item = mModel.getMediaItem(0);
+        if ((item == null) ) {
+            // item is not ready, ignore
+            return false;
+        }
+
+        boolean playVideo = (item.getSupportedOperations() & MediaItem.SUPPORT_PLAY) != 0;
+        if (playVideo) {
+            playVideo((Activity) mActivity, item.getPlayUri(), item.getName());
+        } else {
+            if (mShowBars) {
+                hideBars();
+            } else {
+                showBars();
+            }
+        }
+     return true;
+    }
+    //$_rbox_$_modify_$_end
+    
+    private static final int MSG = 0x01;
+    private Handler mSwithHandler = new Handler(){
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case MSG:
+                if(mPhotoView != null){
+                    mPhotoView.switchToImage(jumpToIndex);
+                }
+                break;
+            }
+        }   
+    };
 
     @Override
     protected boolean onItemSelected(MenuItem item) {
@@ -1088,6 +1215,13 @@ public abstract class PhotoPage extends ActivityState implements
                 return true;
             }
             case R.id.action_delete:
+                if(mModel instanceof PhotoDataAdapter){
+                    if(mModel.getCurrentIndex() == ((PhotoDataAdapter)mModel).getSize()-1){
+                       jumpToIndex = mModel.getCurrentIndex()-1;
+                    }else{
+                       jumpToIndex = mModel.getCurrentIndex();
+                    }
+                }
                 confirmMsg = mActivity.getResources().getQuantityString(
                         R.plurals.delete_selection, 1);
             case R.id.action_setas:
@@ -1219,18 +1353,43 @@ public abstract class PhotoPage extends ActivityState implements
         mMenuExecutor.startSingleItemAction(R.id.action_delete, mDeletePath);
         mDeletePath = null;
     }
+    
+    public static boolean isSeviceWorked(Context context, String serviceName) {
+        ActivityManager myManager = (ActivityManager) context
+                .getSystemService(Context.ACTIVITY_SERVICE);
+        ArrayList<RunningServiceInfo> runningService = (ArrayList<RunningServiceInfo>) myManager
+                .getRunningServices(30);
+        for (int i = 0; i < runningService.size(); i++) {
+            if (runningService.get(i).service.getClassName().toString().equals(
+                    serviceName)) {
+                return true;
+            }
+        }
+        return false;
+    }
 
     public void playVideo(Activity activity, Uri uri, String title) {
+        boolean isWork = isSeviceWorked(activity,"com.android.rk.mediafloat.MediaFloatService");
+        if (!isWork) {
         try {
             Intent intent = new Intent(Intent.ACTION_VIEW)
                     .setDataAndType(uri, "video/*")
                     .putExtra(Intent.EXTRA_TITLE, title)
                     .putExtra(MovieActivity.KEY_TREAT_UP_AS_BACK, true);
+            intent.setClass(activity, MovieActivity.class);
             activity.startActivityForResult(intent, REQUEST_PLAY_VIDEO);
+            if (activity.isInMultiWindowMode()) {
+                activity.overridePendingTransition(0, 0);
+            }
         } catch (ActivityNotFoundException e) {
             Toast.makeText(activity, activity.getString(R.string.video_err),
                     Toast.LENGTH_SHORT).show();
         }
+        } else {
+            Intent intent = new Intent("com.rk.app.mediafloat.CUSTOM_ACTION");
+            intent.putExtra("URI", uri.toString());
+            activity.startService(intent);
+        }
     }
 
     private void setCurrentPhotoByIntent(Intent intent) {
@@ -1295,7 +1454,11 @@ public abstract class PhotoPage extends ActivityState implements
     public void onPause() {
         super.onPause();
         mIsActive = false;
-
+        try{
+            mActivity.getAndroidContext().unregisterReceiver(mSwitchReceiver);
+        }catch(Exception e){
+            e.printStackTrace();
+        }
         mActivity.getGLRoot().unfreeze();
         mHandler.removeMessages(MSG_UNFREEZE_GLROOT);
 
@@ -1419,6 +1582,18 @@ public abstract class PhotoPage extends ActivityState implements
 
         mRecenterCameraOnResume = true;
         mHandler.sendEmptyMessageDelayed(MSG_UNFREEZE_GLROOT, UNFREEZE_GLROOT_TIMEOUT);
+        IntentFilter intentFilter = new IntentFilter(PHOTOPAGE_UPDATE);
+        if (mSwitchReceiver == null) {
+            mSwitchReceiver = new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context arg0, Intent arg1) {
+                    mSwithHandler.removeMessages(MSG);
+                    mSwithHandler.sendEmptyMessageDelayed(MSG, 50);
+                }
+            };
+        }
+        mActivity.getAndroidContext().registerReceiver(mSwitchReceiver,
+                intentFilter);
     }
 
     @Override
diff --git a/src/com/android/gallery3d/app/PickerActivity.java b/src/com/android/gallery3d/app/PickerActivity.java
index d5bb218ea..b4be08549 100644
--- a/src/com/android/gallery3d/app/PickerActivity.java
+++ b/src/com/android/gallery3d/app/PickerActivity.java
@@ -27,11 +27,48 @@ import android.view.Window;
 import com.android.gallery3d.R;
 import com.android.gallery3d.ui.GLRootView;
 
+// $_rbox_$_modify_$_chengmingchuan_$20140225
+// $_rbox_$_modify_$_begin
+import android.view.KeyEvent;
+import android.os.Environment;
+import com.android.gallery3d.ui.GLRoot;
+import android.content.Context;
+// $_rbox_$_modify_$_end
+
+
 public class PickerActivity extends AbstractGalleryActivity
         implements OnClickListener {
 
     public static final String KEY_ALBUM_PATH = "album-path";
 
+    // $_rbox_$_modify_$_chengmingchuan_$_20140225_$_[Info: Handle Keycode]
+    // $_rbox_$_modify_$_begin
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+         if(KeyEvent.KEYCODE_BACK==keyCode){
+         this.onBackPressed();
+         return true;
+     }
+
+     GLRoot root = getGLRoot();
+        root.lockRenderThread();
+        try {
+         boolean flag = getStateManager().onKeyDown(keyCode, event);
+         if(flag){
+          ((GLRootView)root).setFocusable(true);
+          ((GLRootView)root).requestFocus();
+         }else{
+             ((GLRootView)root).setFocusable(false);
+         }
+            return flag||super.onKeyDown(keyCode, event);
+        } finally {    
+            root.unlockRenderThread();
+       }
+    }
+    // $_rbox_$_modify_$_end
+
+
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
diff --git a/src/com/android/gallery3d/app/SinglePhotoDataAdapter.java b/src/com/android/gallery3d/app/SinglePhotoDataAdapter.java
index 00f2fe78f..5ed2d72e2 100644
--- a/src/com/android/gallery3d/app/SinglePhotoDataAdapter.java
+++ b/src/com/android/gallery3d/app/SinglePhotoDataAdapter.java
@@ -44,7 +44,7 @@ public class SinglePhotoDataAdapter extends TileImageViewAdapter
     private static final int MSG_UPDATE_IMAGE = 1;
 
     private MediaItem mItem;
-    private boolean mHasFullImage;
+    private boolean mHasFullImage = true;
     private Future<?> mTask;
     private Handler mHandler;
 
@@ -56,19 +56,20 @@ public class SinglePhotoDataAdapter extends TileImageViewAdapter
     public SinglePhotoDataAdapter(
             AbstractGalleryActivity activity, PhotoView view, MediaItem item) {
         mItem = Utils.checkNotNull(item);
-        mHasFullImage = (item.getSupportedOperations() &
-                MediaItem.SUPPORT_FULL_IMAGE) != 0;
+//        mHasFullImage = (item.getSupportedOperations() &
+//                MediaItem.SUPPORT_FULL_IMAGE) != 0;
         mPhotoView = Utils.checkNotNull(view);
         mHandler = new SynchronizedHandler(activity.getGLRoot()) {
             @Override
             @SuppressWarnings("unchecked")
             public void handleMessage(Message message) {
                 Utils.assertTrue(message.what == MSG_UPDATE_IMAGE);
-                if (mHasFullImage) {
+                /*if (mHasFullImage) {
                     onDecodeLargeComplete((ImageBundle) message.obj);
                 } else {
                     onDecodeThumbComplete((Future<Bitmap>) message.obj);
-                }
+                }*/
+                onDecodeComplete((Future<Bitmap>) message.obj);
             }
         };
         mThreadPool = activity.getThreadPool();
@@ -131,7 +132,7 @@ public class SinglePhotoDataAdapter extends TileImageViewAdapter
         }
     }
 
-    private void onDecodeThumbComplete(Future<Bitmap> future) {
+    private void onDecodeComplete(Future<Bitmap> future) {
         try {
             Bitmap backup = future.get();
             if (backup == null) {
@@ -151,8 +152,11 @@ public class SinglePhotoDataAdapter extends TileImageViewAdapter
     public void resume() {
         if (mTask == null) {
             if (mHasFullImage) {
+                //mTask = mThreadPool.submit(
+                //        mItem.requestLargeImage(), mLargeListener);
                 mTask = mThreadPool.submit(
-                        mItem.requestLargeImage(), mLargeListener);
+                        mItem.requestImage(MediaItem.TYPE_DECODE),
+                        mThumbListener);
             } else {
                 mTask = mThreadPool.submit(
                         mItem.requestImage(MediaItem.TYPE_THUMBNAIL),
@@ -260,4 +264,9 @@ public class SinglePhotoDataAdapter extends TileImageViewAdapter
     public int getLoadingState(int offset) {
         return mLoadingState;
     }
+    
+    @Override
+    public MediaItem getCurrentMediaItem() {
+        return mItem;
+    }
 }
diff --git a/src/com/android/gallery3d/app/SlideshowDataAdapter.java b/src/com/android/gallery3d/app/SlideshowDataAdapter.java
index 7a0fba5fb..de5e3b47a 100644
--- a/src/com/android/gallery3d/app/SlideshowDataAdapter.java
+++ b/src/com/android/gallery3d/app/SlideshowDataAdapter.java
@@ -128,7 +128,7 @@ public class SlideshowDataAdapter implements SlideshowPage.Model {
                 }
 
                 Bitmap bitmap = item
-                        .requestImage(MediaItem.TYPE_THUMBNAIL)
+                        .requestImage(MediaItem.TYPE_DECODE)
                         .run(jc);
 
                 if (bitmap != null) {
diff --git a/src/com/android/gallery3d/app/SlideshowPage.java b/src/com/android/gallery3d/app/SlideshowPage.java
index 174058dc8..a54506523 100644
--- a/src/com/android/gallery3d/app/SlideshowPage.java
+++ b/src/com/android/gallery3d/app/SlideshowPage.java
@@ -161,7 +161,7 @@ public class SlideshowPage extends ActivityState {
             return;
         }
 
-        mSlideshowView.next(slide.bitmap, slide.item.getRotation());
+        mSlideshowView.next(slide.bitmap, slide.item.getRotation()>0?(slide.item.getRotation()-90):slide.item.getRotation());
 
         setStateResult(Activity.RESULT_OK, mResultIntent
                 .putExtra(KEY_ITEM_PATH, slide.item.getPath().toString())
diff --git a/src/com/android/gallery3d/app/StateManager.java b/src/com/android/gallery3d/app/StateManager.java
index aa372a824..fb1747efa 100644
--- a/src/com/android/gallery3d/app/StateManager.java
+++ b/src/com/android/gallery3d/app/StateManager.java
@@ -1,4 +1,5 @@
 /*
+ * $_FOR_ROCKCHIP_RBOX_$
  * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -30,6 +31,12 @@ import com.android.gallery3d.util.UsageStatistics;
 
 import java.util.Stack;
 
+//$_rbox_$_modify_$_chengmingchuan_$_20140224_$_[Info: Handle Keycode]
+//$_rbox_$_modify_$_begin
+import android.view.KeyEvent;
+//$_rbox_$_modify_$_end
+
+
 public class StateManager {
     @SuppressWarnings("unused")
     private static final String TAG = "StateManager";
@@ -143,6 +150,14 @@ public class StateManager {
         return mStack.size();
     }
 
+     //$_rbox_$_modify_$_chengmingchuan_$_20140224_$_[Info: Handle Keycode]
+    // $_rbox_$_modify_$_begin
+     public boolean onKeyDown(int keyCode, KeyEvent event) {
+         return getTopState().onKeyDown(keyCode, event);
+     }
+     // $_rbox_$_modify_$_end
+
+
     public boolean itemSelected(MenuItem item) {
         if (!mStack.isEmpty()) {
             if (getTopState().onItemSelected(item)) return true;
@@ -191,35 +206,33 @@ public class StateManager {
 
         Log.v(TAG, "finishState " + state);
         if (state != mStack.peek().activityState) {
-            if (state.isDestroyed()) {
+        //    if (state.isDestroyed()) {
                 Log.d(TAG, "The state is already destroyed");
                 return;
-            } else {
+          /*  } else {
                 throw new IllegalArgumentException("The stateview to be finished"
                         + " is not at the top of the stack: " + state + ", "
                         + mStack.peek().activityState);
-            }
+            }*/
         }
 
         // Remove the top state.
         mStack.pop();
         state.mIsFinishing = true;
-        ActivityState top = !mStack.isEmpty() ? mStack.peek().activityState : null;
-        if (mIsResumed && fireOnPause) {
-            if (top != null) {
-                state.transitionOnNextPause(state.getClass(), top.getClass(),
-                        StateTransitionAnimation.Transition.Outgoing);
-            }
-            state.onPause();
-        }
+        if (mIsResumed) state.onPause();
         mActivity.getGLRoot().setContentPane(null);
         state.onDestroy();
 
-        if (top != null && mIsResumed) top.resume();
-        if (top != null) {
-            UsageStatistics.onContentViewChanged(UsageStatistics.COMPONENT_GALLERY,
+        if (!mStack.isEmpty()) {
+            // Restore the immediately previous state
+            ActivityState top = mStack.peek().activityState;
+            if (mIsResumed) top.resume();
+            if (top != null) {
+                UsageStatistics.onContentViewChanged(UsageStatistics.COMPONENT_GALLERY,
                     top.getClass().getSimpleName());
+            }
         }
+        
     }
 
     public void switchState(ActivityState oldState,
@@ -257,6 +270,8 @@ public class StateManager {
 
     public void destroy() {
         Log.v(TAG, "destroy");
+        Intent intent = new Intent("widget_update");
+        mActivity.getAndroidContext().sendBroadcast(intent);
         while (!mStack.isEmpty()) {
             mStack.pop().activityState.onDestroy();
         }
@@ -297,6 +312,8 @@ public class StateManager {
     public void saveState(Bundle outState) {
         Log.v(TAG, "saveState");
 
+        Intent intent = new Intent("widget_update");
+        mActivity.getAndroidContext().sendBroadcast(intent);
         Parcelable list[] = new Parcelable[mStack.size()];
         int i = 0;
         for (StateEntry entry : mStack) {
diff --git a/src/com/android/gallery3d/app/TrimVideo.java b/src/com/android/gallery3d/app/TrimVideo.java
index b0ed8e635..8eda7285c 100644
--- a/src/com/android/gallery3d/app/TrimVideo.java
+++ b/src/com/android/gallery3d/app/TrimVideo.java
@@ -39,6 +39,7 @@ import com.android.gallery3d.util.SaveVideoFileUtils;
 
 import java.io.File;
 import java.io.IOException;
+import android.os.Message;
 
 public class TrimVideo extends Activity implements
         MediaPlayer.OnErrorListener,
@@ -225,6 +226,26 @@ public class TrimVideo extends Activity implements
             return true;
         }
     }
+    
+    private final static int MSG = 0x01;
+    private Handler handler = new Handler(){
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case MSG:
+                if (mProgress != null) {
+                    mProgress.dismiss();
+                    mProgress = null;
+                }
+                Toast.makeText(getApplicationContext(),
+                        getString(R.string.movie_crop_alert) ,
+                        Toast.LENGTH_LONG)
+                        .show();
+                finish();
+                break;
+            }
+        }   
+    };
 
     private void trimVideo() {
 
@@ -240,12 +261,15 @@ public class TrimVideo extends Activity implements
                 try {
                     VideoUtils.startTrim(mSrcFile, mDstFileInfo.mFile,
                             mTrimStartTime, mTrimEndTime);
-                    // Update the database for adding a new video file.
-                    SaveVideoFileUtils.insertContent(mDstFileInfo,
-                            getContentResolver(), mUri);
-                } catch (IOException e) {
+                } catch (Exception e) {
                     e.printStackTrace();
+                    handler.removeMessages(MSG);
+                    handler.sendEmptyMessage(MSG);
+                    return;
                 }
+                    // Update the database for adding a new video file.
+                SaveVideoFileUtils.insertContent(mDstFileInfo,
+                            getContentResolver(), mUri);
                 // After trimming is done, trigger the UI changed.
                 mHandler.post(new Runnable() {
                     @Override
diff --git a/src/com/android/gallery3d/app/Wallpaper.java b/src/com/android/gallery3d/app/Wallpaper.java
index 2022f5a4a..228ab0417 100644
--- a/src/com/android/gallery3d/app/Wallpaper.java
+++ b/src/com/android/gallery3d/app/Wallpaper.java
@@ -16,6 +16,7 @@
 
 package com.android.gallery3d.app;
 
+import android.content.pm.PackageManager;
 import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.WallpaperManager;
@@ -26,10 +27,12 @@ import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
 import android.view.Display;
+import android.widget.Toast;
 
 import com.android.gallery3d.common.ApiHelper;
 import com.android.gallery3d.filtershow.crop.CropActivity;
 import com.android.gallery3d.filtershow.crop.CropExtras;
+import com.android.gallery3d.R;
 
 import java.lang.IllegalArgumentException;
 
@@ -50,6 +53,7 @@ public class Wallpaper extends Activity {
 
     private int mState = STATE_INIT;
     private Uri mPickedItem;
+    private boolean mUnInit;
 
     @Override
     protected void onCreate(Bundle bundle) {
@@ -58,6 +62,13 @@ public class Wallpaper extends Activity {
             mState = bundle.getInt(KEY_STATE);
             mPickedItem = (Uri) bundle.getParcelable(KEY_PICKED_ITEM);
         }
+
+        if (CheckPermissionActivity.hasUnauthorizedPermission(this)) {
+            requestPermissions(CheckPermissionActivity.REQUEST_PERMISSIONS,
+                    CheckPermissionActivity.REQUEST_CODE_ASK_PERMISSIONS);
+            mUnInit = true;
+            return;
+        }
     }
 
     @Override
@@ -84,6 +95,35 @@ public class Wallpaper extends Activity {
     @Override
     protected void onResume() {
         super.onResume();
+        if (mUnInit) {
+            return;
+        }
+        initData();
+    }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        switch (requestCode) {
+            case CheckPermissionActivity.REQUEST_CODE_ASK_PERMISSIONS:
+                for (int result : grantResults) {
+                    if (result != PackageManager.PERMISSION_GRANTED) {
+                        // Permission Denied
+                        String toast_text = getResources().getString(R.string.err_permission);
+                        Toast.makeText(this, toast_text, Toast.LENGTH_SHORT).show();
+                        finish();
+                        return;
+                    }
+                }
+                // Permission Granted
+                mUnInit = false;
+                //initData();
+                break;
+            default:
+                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        }
+    }
+
+    private void initData() {
         Intent intent = getIntent();
         switch (mState) {
             case STATE_INIT: {
diff --git a/src/com/android/gallery3d/data/ActionImage.java b/src/com/android/gallery3d/data/ActionImage.java
index 58e30b146..181f1cbb9 100644
--- a/src/com/android/gallery3d/data/ActionImage.java
+++ b/src/com/android/gallery3d/data/ActionImage.java
@@ -24,6 +24,7 @@ import android.net.Uri;
 import com.android.gallery3d.app.GalleryApp;
 import com.android.gallery3d.common.BitmapUtils;
 import com.android.gallery3d.common.Utils;
+import com.android.gallery3d.data.MediaItem.BitmapInfo;
 import com.android.gallery3d.util.ThreadPool.Job;
 import com.android.gallery3d.util.ThreadPool.JobContext;
 
@@ -100,4 +101,10 @@ public class ActionImage extends MediaItem {
     public int getHeight() {
         return 0;
     }
+    
+    @Override
+    public Job<BitmapInfo> requestDecodeImage(int type, Uri mUri) {
+        // TODO Auto-generated method stub
+        return null;
+    }
 }
diff --git a/src/com/android/gallery3d/data/ClusterAlbum.java b/src/com/android/gallery3d/data/ClusterAlbum.java
index 8681952bf..5c18847ba 100644
--- a/src/com/android/gallery3d/data/ClusterAlbum.java
+++ b/src/com/android/gallery3d/data/ClusterAlbum.java
@@ -130,6 +130,14 @@ public class ClusterAlbum extends MediaSet implements ContentListener {
             public void consume(int index, MediaItem item) {
                 if ((item.getSupportedOperations() & SUPPORT_DELETE) != 0) {
                     item.delete();
+                    java.io.File file = new java.io.File(item.mPath.toString());
+                    try{
+                       if(file.exists()){
+                           file.delete();
+                       }
+                    }catch(Exception e){
+                       e.printStackTrace();
+                    }
                 }
             }
         };
diff --git a/src/com/android/gallery3d/data/DataManager.java b/src/com/android/gallery3d/data/DataManager.java
index 38865e9f1..3cf278712 100644
--- a/src/com/android/gallery3d/data/DataManager.java
+++ b/src/com/android/gallery3d/data/DataManager.java
@@ -19,6 +19,7 @@ package com.android.gallery3d.data;
 import android.content.Context;
 import android.database.ContentObserver;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Handler;
 
 import com.android.gallery3d.app.GalleryApp;
@@ -29,6 +30,7 @@ import com.android.gallery3d.data.MediaSet.ItemConsumer;
 import com.android.gallery3d.data.MediaSource.PathId;
 import com.android.gallery3d.picasasource.PicasaSource;
 
+import java.io.File;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.HashMap;
@@ -86,6 +88,9 @@ public class DataManager implements StitchingChangeListener {
 
     private static final String TOP_LOCAL_VIDEO_SET_PATH = "/local/video";
 
+    private static final String MNT_PATH = "/mnt/media_rw";
+    private static final String STORAGE_REGEX = "^/storage";
+
     public static final Comparator<MediaItem> sDateTakenComparator =
             new DateTakenComparator();
 
@@ -250,6 +255,19 @@ public class DataManager implements StitchingChangeListener {
     }
 
     public void delete(Path path) {
+        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.O_MR1) {
+            MediaDetails mediaDetails = getMediaObject(path).getDetails();
+            if (null != mediaDetails) {
+                Object deleteDetail = mediaDetails.getDetail(MediaDetails.INDEX_PATH);
+                if (null != deleteDetail && isExtendStorage(deleteDetail.toString())) {
+                    String deletePath = convertStorageToMnt(deleteDetail.toString());
+                    File file = new File(deletePath);
+                    if (file.exists()) {
+                        file.delete();
+                    }
+                }
+            }
+        }
         getMediaObject(path).delete();
     }
 
@@ -368,4 +386,17 @@ public class DataManager implements StitchingChangeListener {
     public void onStitchingProgress(Uri uri, int progress) {
         // Do nothing.
     }
+
+    public static String convertStorageToMnt(String path) {
+        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.O_MR1
+            && isExtendStorage(path)) {
+            return path.replaceFirst(STORAGE_REGEX, MNT_PATH);
+        }
+        return path;
+    }
+
+    private static boolean isExtendStorage(String path) {
+        return null != path && path.startsWith("/storage/")
+                && !path.startsWith("/storage/emulated/");
+    }
 }
diff --git a/src/com/android/gallery3d/data/FilterTypeSet.java b/src/com/android/gallery3d/data/FilterTypeSet.java
index 477ef73ad..ff9ace04f 100644
--- a/src/com/android/gallery3d/data/FilterTypeSet.java
+++ b/src/com/android/gallery3d/data/FilterTypeSet.java
@@ -129,6 +129,14 @@ public class FilterTypeSet extends MediaSet implements ContentListener {
             public void consume(int index, MediaItem item) {
                 if ((item.getSupportedOperations() & SUPPORT_DELETE) != 0) {
                     item.delete();
+                    java.io.File file = new java.io.File(item.mPath.toString());
+                    try{
+                       if(file.exists()){
+                           file.delete();
+                       }
+                    }catch(Exception e){
+                        e.printStackTrace();
+                    }
                 }
             }
         };
diff --git a/src/com/android/gallery3d/data/ImageCacheRequest.java b/src/com/android/gallery3d/data/ImageCacheRequest.java
index 6cbc5c5ea..2831d4d83 100644
--- a/src/com/android/gallery3d/data/ImageCacheRequest.java
+++ b/src/com/android/gallery3d/data/ImageCacheRequest.java
@@ -33,14 +33,16 @@ abstract class ImageCacheRequest implements Job<Bitmap> {
     private int mType;
     private int mTargetSize;
     private long mTimeModified;
+    private String mLocalFilePath;
 
     public ImageCacheRequest(GalleryApp application,
-            Path path, long timeModified, int type, int targetSize) {
+            Path path, long timeModified, int type, int targetSize,String localFilePath) {
         mApplication = application;
         mPath = path;
         mType = type;
         mTargetSize = targetSize;
         mTimeModified = timeModified;
+        mLocalFilePath = localFilePath;
     }
 
     private String debugTag() {
@@ -55,7 +57,7 @@ abstract class ImageCacheRequest implements Job<Bitmap> {
 
         BytesBuffer buffer = MediaItem.getBytesBufferPool().get();
         try {
-            boolean found = cacheService.getImageData(mPath, mTimeModified, mType, buffer);
+            boolean found = cacheService.getImageData(mPath,mLocalFilePath, mTimeModified, mType, buffer);
             if (jc.isCancelled()) return null;
             if (found) {
                 BitmapFactory.Options options = new BitmapFactory.Options();
@@ -94,7 +96,7 @@ abstract class ImageCacheRequest implements Job<Bitmap> {
         byte[] array = BitmapUtils.compressToBytes(bitmap);
         if (jc.isCancelled()) return null;
 
-        cacheService.putImageData(mPath, mTimeModified, mType, array);
+        cacheService.putImageData(mPath,mLocalFilePath, mTimeModified, mType, array);
         return bitmap;
     }
 
diff --git a/src/com/android/gallery3d/data/ImageCacheService.java b/src/com/android/gallery3d/data/ImageCacheService.java
index 1c7cb8c5e..52858fe44 100644
--- a/src/com/android/gallery3d/data/ImageCacheService.java
+++ b/src/com/android/gallery3d/data/ImageCacheService.java
@@ -55,9 +55,12 @@ public class ImageCacheService {
      *
      * @return true if the image data is found; false if not found.
      */
-    public boolean getImageData(Path path, long timeModified, int type, BytesBuffer buffer) {
-        byte[] key = makeKey(path, timeModified, type);
+    public boolean getImageData(Path path,String filePath, long timeModified, int type, BytesBuffer buffer) {
+        byte[] key = makeKey(path,filePath, timeModified, type);
         long cacheKey = Utils.crc64Long(key);
+        if(mCache == null){
+            return false;
+        }
         try {
             LookupRequest request = new LookupRequest();
             request.key = cacheKey;
@@ -77,12 +80,15 @@ public class ImageCacheService {
         return false;
     }
 
-    public void putImageData(Path path, long timeModified, int type, byte[] value) {
-        byte[] key = makeKey(path, timeModified, type);
+    public void putImageData(Path path,String filePath, long timeModified, int type, byte[] value) {
+        byte[] key = makeKey(path, filePath, timeModified, type);
         long cacheKey = Utils.crc64Long(key);
         ByteBuffer buffer = ByteBuffer.allocate(key.length + value.length);
         buffer.put(key);
         buffer.put(value);
+        if(mCache == null){
+            return;
+        }
         synchronized (mCache) {
             try {
                 mCache.insert(cacheKey, buffer.array());
@@ -92,8 +98,8 @@ public class ImageCacheService {
         }
     }
 
-    public void clearImageData(Path path, long timeModified, int type) {
-        byte[] key = makeKey(path, timeModified, type);
+    public void clearImageData(Path path,String filePath, long timeModified, int type) {
+        byte[] key = makeKey(path,filePath, timeModified, type);
         long cacheKey = Utils.crc64Long(key);
         synchronized (mCache) {
             try {
@@ -104,8 +110,8 @@ public class ImageCacheService {
         }
     }
 
-    private static byte[] makeKey(Path path, long timeModified, int type) {
-        return GalleryUtils.getBytes(path.toString() + "+" + timeModified + "+" + type);
+    private static byte[] makeKey(Path path,String filePath, long timeModified, int type) {
+        return GalleryUtils.getBytes(path.toString() +"+"+filePath+ "+" + timeModified + "+" + type);
     }
 
     private static boolean isSameKey(byte[] key, byte[] buffer) {
diff --git a/src/com/android/gallery3d/data/LocalAlbum.java b/src/com/android/gallery3d/data/LocalAlbum.java
index 322eb91b1..735381b52 100644
--- a/src/com/android/gallery3d/data/LocalAlbum.java
+++ b/src/com/android/gallery3d/data/LocalAlbum.java
@@ -267,6 +267,30 @@ public class LocalAlbum extends MediaSet {
 
     @Override
     public void delete() {
+        Cursor cursor = mResolver.query(
+                mBaseUri, mProjection, mWhereClause,
+                new String[]{String.valueOf(mBucketId)},
+                mOrderClause);
+        if (cursor == null) {
+            return;
+        }
+
+        try {
+            while (cursor.moveToNext()) {
+                String filepath = cursor.getString(8);
+                filepath = DataManager.convertStorageToMnt(filepath);
+                java.io.File file = new java.io.File(filepath);
+                try{
+                    if(file.exists()){
+                        file.delete();
+                    }
+                }catch(Exception e){
+                    e.printStackTrace();
+                }
+            }
+        } finally {
+            cursor.close();
+        }
         GalleryUtils.assertNotInRenderThread();
         mResolver.delete(mBaseUri, mWhereClause,
                 new String[]{String.valueOf(mBucketId)});
diff --git a/src/com/android/gallery3d/data/LocalImage.java b/src/com/android/gallery3d/data/LocalImage.java
index 2b01c1e22..15ad6a152 100644
--- a/src/com/android/gallery3d/data/LocalImage.java
+++ b/src/com/android/gallery3d/data/LocalImage.java
@@ -19,10 +19,13 @@ package com.android.gallery3d.data;
 import android.annotation.TargetApi;
 import android.content.ContentResolver;
 import android.content.ContentValues;
+import android.content.Context;
 import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.BitmapRegionDecoder;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory.Options;
 import android.net.Uri;
 import android.os.Build;
 import android.provider.MediaStore.Images;
@@ -34,6 +37,7 @@ import com.android.gallery3d.app.GalleryApp;
 import com.android.gallery3d.app.PanoramaMetadataSupport;
 import com.android.gallery3d.common.ApiHelper;
 import com.android.gallery3d.common.BitmapUtils;
+import com.android.gallery3d.data.MediaItem.BitmapInfo;
 import com.android.gallery3d.exif.ExifInterface;
 import com.android.gallery3d.exif.ExifTag;
 import com.android.gallery3d.filtershow.tools.SaveImage;
@@ -41,10 +45,12 @@ import com.android.gallery3d.util.GalleryUtils;
 import com.android.gallery3d.util.ThreadPool.Job;
 import com.android.gallery3d.util.ThreadPool.JobContext;
 import com.android.gallery3d.util.UpdateHelper;
+import com.android.gif.GifTextrue;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.io.InputStream;
 
 // LocalImage represents an image in the local storage.
 public class LocalImage extends LocalMediaItem {
@@ -176,18 +182,22 @@ public class LocalImage extends LocalMediaItem {
                 type, filePath);
     }
 
-    public static class LocalImageRequest extends ImageCacheRequest {
+    public class LocalImageRequest extends ImageCacheRequest {
         private String mLocalFilePath;
 
         LocalImageRequest(GalleryApp application, Path path, long timeModified,
                 int type, String localFilePath) {
             super(application, path, timeModified, type,
-                    MediaItem.getTargetSize(type));
+                    MediaItem.getTargetSize(type),localFilePath);
             mLocalFilePath = localFilePath;
         }
 
         @Override
         public Bitmap onDecodeOriginal(JobContext jc, final int type) {
+            if(type == MediaItem.TYPE_DECODE){
+                  return new com.android.gallery3d.util.BitmapUtils(mApplication.getAndroidContext())
+                    .getBitmap(getContentUri(), 1024, 768);
+            }
             BitmapFactory.Options options = new BitmapFactory.Options();
             options.inPreferredConfig = Bitmap.Config.ARGB_8888;
             int targetSize = MediaItem.getTargetSize(type);
@@ -237,14 +247,18 @@ public class LocalImage extends LocalMediaItem {
     @Override
     public int getSupportedOperations() {
         int operation = SUPPORT_DELETE | SUPPORT_SHARE | SUPPORT_CROP
-                | SUPPORT_SETAS | SUPPORT_PRINT | SUPPORT_INFO;
+                | SUPPORT_PRINT | SUPPORT_INFO;
         if (BitmapUtils.isSupportedByRegionDecoder(mimeType)) {
-            operation |= SUPPORT_FULL_IMAGE | SUPPORT_EDIT;
+            operation |= SUPPORT_SETAS;
         }
-
-        if (BitmapUtils.isRotationSupported(mimeType)) {
-            operation |= SUPPORT_ROTATE;
+        if (mimeType != null && mimeType.toLowerCase().indexOf("gif") == -1
+                && !mimeType.endsWith("wbmp")/*image/vnd.wap.wbmp*/) {
+            operation |= SUPPORT_EDIT;
         }
+         operation |= SUPPORT_FULL_IMAGE;
+//        if (BitmapUtils.isRotationSupported(mimeType)) {
+            operation |= SUPPORT_ROTATE;
+//        }
 
         if (GalleryUtils.isValidLocation(latitude, longitude)) {
             operation |= SUPPORT_SHOW_ON_MAP;
@@ -270,6 +284,14 @@ public class LocalImage extends LocalMediaItem {
         SaveImage.deleteAuxFiles(contentResolver, getContentUri());
         contentResolver.delete(baseUri, "_id=?",
                 new String[]{String.valueOf(id)});
+        File file = new File(DataManager.convertStorageToMnt(filePath));
+        try{
+           if(file.exists()){
+              file.delete();
+           }
+        }catch(Exception e){
+         e.printStackTrace();
+        }
     }
 
     @Override
@@ -320,11 +342,32 @@ public class LocalImage extends LocalMediaItem {
     public MediaDetails getDetails() {
         MediaDetails details = super.getDetails();
         details.addDetail(MediaDetails.INDEX_ORIENTATION, Integer.valueOf(rotation));
-        if (MIME_TYPE_JPEG.equals(mimeType)) {
+//        if (MIME_TYPE_JPEG.equals(mimeType)) {
             // ExifInterface returns incorrect values for photos in other format.
             // For example, the width and height of an webp images is always '0'.
             MediaDetails.extractExifInfo(details, filePath);
-        }
+            if (width == 0 || height == 0) {
+                try {
+                    BitmapFactory.Options options = new BitmapFactory.Options();
+                    options.inJustDecodeBounds = true;
+                    BitmapFactory.decodeFile(filePath, options);
+                    width = options.outWidth;
+                    height = options.outHeight;
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+            if(width > 0){
+                MediaDetails.setWidth(details, width);
+            }
+            if(height > 0){
+                MediaDetails.setHeight(details, height);
+            }
+            int w = rotation % 180 == 0 ? getWidth() : getHeight();
+            int h = rotation % 180 == 0 ? getHeight() : getWidth();
+            MediaDetails.setWidth(details, w);
+            MediaDetails.setHeight(details, h);
+//        }
         return details;
     }
 
@@ -347,4 +390,24 @@ public class LocalImage extends LocalMediaItem {
     public String getFilePath() {
         return filePath;
     }
+    
+    @Override
+    public Job<BitmapInfo> requestDecodeImage(int type, Uri mUri) {
+        return new BitmapJob(type,mUri);
+    }
+    private class BitmapJob implements Job<BitmapInfo> {
+        private int mType;
+        private Uri mUri;
+
+        protected BitmapJob(int type,Uri uri) {
+            mType = type;
+            mUri = uri;
+        }
+
+        @Override
+        public BitmapInfo run(JobContext jc) {
+            return new BitmapInfo(mUri,
+                    new com.android.gallery3d.util.BitmapUtils(mApplication.getAndroidContext()).getNotRotateBitmap(mUri, 1024, 768));
+        }
+    }
 }
diff --git a/src/com/android/gallery3d/data/LocalMergeAlbum.java b/src/com/android/gallery3d/data/LocalMergeAlbum.java
index f0b5e5726..4fdb7a624 100644
--- a/src/com/android/gallery3d/data/LocalMergeAlbum.java
+++ b/src/com/android/gallery3d/data/LocalMergeAlbum.java
@@ -200,6 +200,14 @@ public class LocalMergeAlbum extends MediaSet implements ContentListener {
     public void delete() {
         for (MediaSet set : mSources) {
             set.delete();
+            java.io.File file = new java.io.File(set.mPath.toString());
+            try{
+               if(file.exists()){
+                   file.delete();
+               }
+            }catch(Exception e){
+               e.printStackTrace();
+            }
         }
     }
 
diff --git a/src/com/android/gallery3d/data/LocalVideo.java b/src/com/android/gallery3d/data/LocalVideo.java
index 4b8774ca4..1b4337e9b 100644
--- a/src/com/android/gallery3d/data/LocalVideo.java
+++ b/src/com/android/gallery3d/data/LocalVideo.java
@@ -20,17 +20,21 @@ import android.content.ContentResolver;
 import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.BitmapRegionDecoder;
+import android.media.MediaMetadataRetriever;
 import android.net.Uri;
 import android.provider.MediaStore.Video;
 import android.provider.MediaStore.Video.VideoColumns;
 
 import com.android.gallery3d.app.GalleryApp;
 import com.android.gallery3d.common.BitmapUtils;
+import com.android.gallery3d.data.MediaItem.BitmapInfo;
 import com.android.gallery3d.util.GalleryUtils;
 import com.android.gallery3d.util.ThreadPool.Job;
 import com.android.gallery3d.util.ThreadPool.JobContext;
 import com.android.gallery3d.util.UpdateHelper;
 
+import java.io.File;
+
 // LocalVideo represents a video in the local storage.
 public class LocalVideo extends LocalMediaItem {
     private static final String TAG = "LocalVideo";
@@ -162,7 +166,7 @@ public class LocalVideo extends LocalMediaItem {
         LocalVideoRequest(GalleryApp application, Path path, long timeModified,
                 int type, String localFilePath) {
             super(application, path, timeModified, type,
-                    MediaItem.getTargetSize(type));
+                    MediaItem.getTargetSize(type),localFilePath);
             mLocalFilePath = localFilePath;
         }
 
@@ -191,6 +195,14 @@ public class LocalVideo extends LocalMediaItem {
         Uri baseUri = Video.Media.EXTERNAL_CONTENT_URI;
         mApplication.getContentResolver().delete(baseUri, "_id=?",
                 new String[]{String.valueOf(id)});
+        File file = new File(DataManager.convertStorageToMnt(filePath));
+        try{
+           if(file.exists()){
+               file.delete();
+           }
+        }catch(Exception e){
+           e.printStackTrace();
+        }
     }
 
     @Override
@@ -222,6 +234,21 @@ public class LocalVideo extends LocalMediaItem {
             details.addDetail(MediaDetails.INDEX_DURATION, GalleryUtils.formatDuration(
                     mApplication.getAndroidContext(), durationInSec));
         }
+        if (filePath != null) {
+            MediaMetadataRetriever retrieverSrc = new MediaMetadataRetriever();
+            retrieverSrc.setDataSource(filePath);
+            String degreesString = retrieverSrc.extractMetadata(
+                    MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION);
+            if (degreesString != null) {
+                int degrees = Integer.parseInt(degreesString);
+                if (degrees >= 0) {
+                    int w = degrees % 180 == 0 ? getWidth() : getHeight();
+                    int h = degrees % 180 == 0 ? getHeight() : getWidth();
+                    details.addDetail(MediaDetails.INDEX_WIDTH, w);
+                    details.addDetail(MediaDetails.INDEX_HEIGHT, h);
+                }
+            }
+        }
         return details;
     }
 
@@ -239,4 +266,10 @@ public class LocalVideo extends LocalMediaItem {
     public String getFilePath() {
         return filePath;
     }
+    
+    @Override
+    public Job<BitmapInfo> requestDecodeImage(int type, Uri mUri) {
+        // TODO Auto-generated method stub
+        return null;
+    }
 }
diff --git a/src/com/android/gallery3d/data/MediaDetails.java b/src/com/android/gallery3d/data/MediaDetails.java
index cac524b88..f74b45bea 100644
--- a/src/com/android/gallery3d/data/MediaDetails.java
+++ b/src/com/android/gallery3d/data/MediaDetails.java
@@ -167,4 +167,12 @@ public class MediaDetails implements Iterable<Entry<Integer, Object>> {
             details.setUnit(MediaDetails.INDEX_FOCAL_LENGTH, R.string.unit_mm);
         }
     }
+    
+    public static void setWidth(MediaDetails details, int width){
+        details.addDetail(MediaDetails.INDEX_WIDTH, width);
+    }
+    
+    public static void setHeight(MediaDetails details, int height){
+        details.addDetail(MediaDetails.INDEX_HEIGHT, height);
+    }
 }
diff --git a/src/com/android/gallery3d/data/MediaItem.java b/src/com/android/gallery3d/data/MediaItem.java
index 59ea86551..3cbf20822 100644
--- a/src/com/android/gallery3d/data/MediaItem.java
+++ b/src/com/android/gallery3d/data/MediaItem.java
@@ -18,6 +18,7 @@ package com.android.gallery3d.data;
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapRegionDecoder;
+import android.net.Uri;
 
 import com.android.gallery3d.common.ApiHelper;
 import com.android.gallery3d.ui.ScreenNail;
@@ -29,7 +30,10 @@ public abstract class MediaItem extends MediaObject {
     // not be changed without resetting the cache.
     public static final int TYPE_THUMBNAIL = 1;
     public static final int TYPE_MICROTHUMBNAIL = 2;
+    public static final int TYPE_DECODE = 3;
 
+    public static final int THUMBNAIL_TARGET_SIZE = 640;
+    public static final int MICROTHUMBNAIL_TARGET_SIZE = 200;
     public static final int CACHED_IMAGE_QUALITY = 95;
 
     public static final int IMAGE_READY = 0;
@@ -52,6 +56,30 @@ public abstract class MediaItem extends MediaObject {
 
     public abstract Job<Bitmap> requestImage(int type);
     public abstract Job<BitmapRegionDecoder> requestLargeImage();
+    public abstract Job<BitmapInfo> requestDecodeImage(int type,Uri mUri);
+
+    public class BitmapInfo{
+        private Uri mUri ;
+        private Bitmap mBitmap;
+        
+        public BitmapInfo(Uri mUri, Bitmap mBitmap) {
+            this.mUri = mUri;
+            this.mBitmap = mBitmap;
+        }
+        public Uri getmUri() {
+            return mUri;
+        }
+        public void setmUri(Uri mUri) {
+            this.mUri = mUri;
+        }
+        public Bitmap getmBitmap() {
+            return mBitmap;
+        }
+        public void setmBitmap(Bitmap mBitmap) {
+            this.mBitmap = mBitmap;
+        }
+        
+    }
 
     public MediaItem(Path path, long version) {
         super(path, version);
@@ -115,6 +143,8 @@ public abstract class MediaItem extends MediaObject {
                 return sThumbnailTargetSize;
             case TYPE_MICROTHUMBNAIL:
                 return sMicrothumbnailTargetSize;
+            case TYPE_DECODE:
+                return THUMBNAIL_TARGET_SIZE;
             default:
                 throw new RuntimeException(
                     "should only request thumb/microthumb from cache");
diff --git a/src/com/android/gallery3d/data/SnailItem.java b/src/com/android/gallery3d/data/SnailItem.java
index 3586d2cab..789b6af6d 100644
--- a/src/com/android/gallery3d/data/SnailItem.java
+++ b/src/com/android/gallery3d/data/SnailItem.java
@@ -18,7 +18,9 @@ package com.android.gallery3d.data;
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapRegionDecoder;
+import android.net.Uri;
 
+import com.android.gallery3d.data.MediaItem.BitmapInfo;
 import com.android.gallery3d.ui.ScreenNail;
 import com.android.gallery3d.util.ThreadPool.Job;
 import com.android.gallery3d.util.ThreadPool.JobContext;
@@ -92,4 +94,10 @@ public class SnailItem extends MediaItem {
     public void updateVersion() {
         mDataVersion = nextVersionNumber();
     }
+    
+    @Override
+    public Job<BitmapInfo> requestDecodeImage(int type, Uri mUri) {
+        // TODO Auto-generated method stub
+        return null;
+    }
 }
diff --git a/src/com/android/gallery3d/data/UriImage.java b/src/com/android/gallery3d/data/UriImage.java
index b3fe1de03..6b51279cf 100644
--- a/src/com/android/gallery3d/data/UriImage.java
+++ b/src/com/android/gallery3d/data/UriImage.java
@@ -28,9 +28,11 @@ import com.android.gallery3d.app.GalleryApp;
 import com.android.gallery3d.app.PanoramaMetadataSupport;
 import com.android.gallery3d.common.BitmapUtils;
 import com.android.gallery3d.common.Utils;
+import com.android.gallery3d.data.MediaItem.BitmapInfo;
 import com.android.gallery3d.util.ThreadPool.CancelListener;
 import com.android.gallery3d.util.ThreadPool.Job;
 import com.android.gallery3d.util.ThreadPool.JobContext;
+import com.android.gif.GifTextrue;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -190,6 +192,10 @@ public class UriImage extends MediaItem {
         @Override
         public Bitmap run(JobContext jc) {
             if (!prepareInputFile(jc)) return null;
+            if(mType == MediaItem.TYPE_DECODE){
+                return new com.android.gallery3d.util.BitmapUtils(mApplication.getAndroidContext())
+                              .getBitmap(mUri, 1024, 768);
+            }
             int targetSize = MediaItem.getTargetSize(mType);
             Options options = new Options();
             options.inPreferredConfig = Config.ARGB_8888;
@@ -211,11 +217,12 @@ public class UriImage extends MediaItem {
 
     @Override
     public int getSupportedOperations() {
-        int supported = SUPPORT_PRINT | SUPPORT_SETAS;
+        int supported = SUPPORT_PRINT  | SUPPORT_INFO;
         if (isSharable()) supported |= SUPPORT_SHARE;
         if (BitmapUtils.isSupportedByRegionDecoder(mContentType)) {
-            supported |= SUPPORT_EDIT | SUPPORT_FULL_IMAGE;
+            supported |= SUPPORT_FULL_IMAGE | SUPPORT_SETAS;
         }
+        supported |= SUPPORT_EDIT;
         return supported;
     }
 
@@ -295,4 +302,10 @@ public class UriImage extends MediaItem {
     public int getRotation() {
         return mRotation;
     }
+    
+    @Override
+    public Job<BitmapInfo> requestDecodeImage(int type, Uri mUri) {
+        // TODO Auto-generated method stub
+        return null;
+    }
 }
diff --git a/src/com/android/gallery3d/filtershow/EditorPlaceHolder.java b/src/com/android/gallery3d/filtershow/EditorPlaceHolder.java
index 95fc56d4f..faa37c6b8 100644
--- a/src/com/android/gallery3d/filtershow/EditorPlaceHolder.java
+++ b/src/com/android/gallery3d/filtershow/EditorPlaceHolder.java
@@ -66,7 +66,9 @@ public class EditorPlaceHolder {
     }
 
     public void hide() {
-        mContainer.setVisibility(View.GONE);
+        if (null != mContainer) {
+            mContainer.setVisibility(View.GONE);
+        }
     }
 
     public void hideOldViews() {
diff --git a/src/com/android/gallery3d/filtershow/FilterShowActivity.java b/src/com/android/gallery3d/filtershow/FilterShowActivity.java
index 937c5290b..3521939f9 100644
--- a/src/com/android/gallery3d/filtershow/FilterShowActivity.java
+++ b/src/com/android/gallery3d/filtershow/FilterShowActivity.java
@@ -26,6 +26,7 @@ import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.ServiceConnection;
 import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -67,6 +68,7 @@ import android.widget.Spinner;
 import android.widget.Toast;
 
 import com.android.gallery3d.R;
+import com.android.gallery3d.app.CheckPermissionActivity;
 import com.android.gallery3d.app.PhotoPage;
 import com.android.gallery3d.data.LocalAlbum;
 import com.android.gallery3d.filtershow.cache.ImageLoader;
@@ -193,6 +195,7 @@ public class FilterShowActivity extends FragmentActivity implements OnItemClickL
     private DialogInterface mCurrentDialog = null;
     private PopupMenu mCurrentMenu = null;
     private boolean mLoadingVisible = true;
+    private boolean mUnInit;
 
     public ProcessingService getProcessingService() {
         return mBoundService;
@@ -278,7 +281,13 @@ public class FilterShowActivity extends FragmentActivity implements OnItemClickL
         }
 
         clearGalleryBitmapPool();
-        doBindService();
+        if (CheckPermissionActivity.hasUnauthorizedPermission(this)) {
+            requestPermissions(CheckPermissionActivity.REQUEST_PERMISSIONS,
+                    CheckPermissionActivity.REQUEST_CODE_ASK_PERMISSIONS);
+            mUnInit = true;
+        } else {
+            doBindService();
+        }
         getWindow().setBackgroundDrawable(new ColorDrawable(Color.GRAY));
         setContentView(R.layout.filtershow_splashscreen);
     }
@@ -896,8 +905,12 @@ public class FilterShowActivity extends FragmentActivity implements OnItemClickL
         if (mLoadBitmapTask != null) {
             mLoadBitmapTask.cancel(false);
         }
-        mUserPresetsManager.close();
-        doUnbindService();
+        if (null != mUserPresetsManager) {
+            mUserPresetsManager.close();
+        }
+        if (!mUnInit) {
+            doUnbindService();
+        }
         super.onDestroy();
     }
 
@@ -1286,6 +1299,9 @@ public class FilterShowActivity extends FragmentActivity implements OnItemClickL
     }
 
     void resetHistory() {
+        if(mMasterImage == null){
+            return;
+        }
         HistoryManager adapter = mMasterImage.getHistory();
         adapter.reset();
         HistoryItem historyItem = adapter.getItem(0);
@@ -1394,7 +1410,9 @@ public class FilterShowActivity extends FragmentActivity implements OnItemClickL
             int bucketId = GalleryUtils.getBucketId(saveDir.getPath());
             String albumName = LocalAlbum.getLocalizedName(getResources(), bucketId, null);
             showSavingProgress(albumName);
-            mImageShow.saveImage(this, null);
+            mSelectedImageUri = SaveImage.makeAndInsertUri(this,mSelectedImageUri);
+            File newFile = SaveImage.getNewFile(this, mSelectedImageUri);
+            mImageShow.saveImage(this, newFile, true);
         } else {
             done();
         }
@@ -1510,4 +1528,26 @@ public class FilterShowActivity extends FragmentActivity implements OnItemClickL
             }
         });
     }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        switch (requestCode) {
+            case CheckPermissionActivity.REQUEST_CODE_ASK_PERMISSIONS:
+                for (int result : grantResults) {
+                    if (result != PackageManager.PERMISSION_GRANTED) {
+                        // Permission Denied
+                        String toast_text = getResources().getString(R.string.err_permission);
+                        Toast.makeText(this, toast_text, Toast.LENGTH_SHORT).show();
+                        finish();
+                        return;
+                    }
+                }
+                // Permission Granted
+                mUnInit = false;
+                doBindService();
+                break;
+            default:
+                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        }
+    }
 }
diff --git a/src/com/android/gallery3d/filtershow/crop/CropActivity.java b/src/com/android/gallery3d/filtershow/crop/CropActivity.java
index 3a7829681..71fb76bbe 100644
--- a/src/com/android/gallery3d/filtershow/crop/CropActivity.java
+++ b/src/com/android/gallery3d/filtershow/crop/CropActivity.java
@@ -21,6 +21,7 @@ import android.app.Activity;
 import android.app.WallpaperManager;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.graphics.Bitmap;
 import android.graphics.Bitmap.CompressFormat;
@@ -43,6 +44,7 @@ import android.view.WindowManager;
 import android.widget.Toast;
 
 import com.android.gallery3d.R;
+import com.android.gallery3d.app.CheckPermissionActivity;
 import com.android.gallery3d.common.Utils;
 import com.android.gallery3d.filtershow.cache.ImageLoader;
 import com.android.gallery3d.filtershow.tools.SaveImage;
@@ -91,6 +93,7 @@ public class CropActivity extends Activity {
     private static final int DO_EXTRA_OUTPUT = 1 << 2;
 
     private static final int FLAG_CHECK = DO_SET_WALLPAPER | DO_RETURN_DATA | DO_EXTRA_OUTPUT;
+    private boolean mUnInit;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -118,6 +121,18 @@ public class CropActivity extends Activity {
                 }
             });
         }
+
+        if (CheckPermissionActivity.hasUnauthorizedPermission(this)) {
+            requestPermissions(CheckPermissionActivity.REQUEST_PERMISSIONS,
+                    CheckPermissionActivity.REQUEST_CODE_ASK_PERMISSIONS);
+            mUnInit = true;
+            return;
+        }
+        initData();
+    }
+
+    private void initData(){
+        Intent intent = getIntent();
         if (intent.getData() != null) {
             mSourceUri = intent.getData();
             startLoadBitmap(mSourceUri);
@@ -143,7 +158,9 @@ public class CropActivity extends Activity {
     @Override
     public void onConfigurationChanged (Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
-        mCropView.configChanged();
+        if (null != mCropView) {
+            mCropView.configChanged();
+        }
     }
 
     /**
@@ -695,4 +712,26 @@ public class CropActivity extends Activity {
         RectF scaledCrop = CropMath.getScaledCropBounds(crop, photo, imageBounds);
         return scaledCrop;
     }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        switch (requestCode) {
+            case CheckPermissionActivity.REQUEST_CODE_ASK_PERMISSIONS:
+                for (int result : grantResults) {
+                    if (result != PackageManager.PERMISSION_GRANTED) {
+                        // Permission Denied
+                        String toast_text = getResources().getString(R.string.err_permission);
+                        Toast.makeText(this, toast_text, Toast.LENGTH_SHORT).show();
+                        finish();
+                        return;
+                    }
+                }
+                // Permission Granted
+                mUnInit = false;
+                initData();
+                break;
+            default:
+                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        }
+    }
 }
diff --git a/src/com/android/gallery3d/filtershow/editors/EditorColorBorder.java b/src/com/android/gallery3d/filtershow/editors/EditorColorBorder.java
index 98659df38..455a76986 100644
--- a/src/com/android/gallery3d/filtershow/editors/EditorColorBorder.java
+++ b/src/com/android/gallery3d/filtershow/editors/EditorColorBorder.java
@@ -176,7 +176,9 @@ public class EditorColorBorder extends ParametricEditor  {
             c.setColorSet(mBasColors);
         }
         updateText();
-        mControl.updateUI();
+        if(null != mControl) {
+            mControl.updateUI();
+        }
         mView.invalidate();
     }
 
diff --git a/src/com/android/gallery3d/filtershow/filters/FilterDrawRepresentation.java b/src/com/android/gallery3d/filtershow/filters/FilterDrawRepresentation.java
index 48d3d9077..3f5c73c1d 100644
--- a/src/com/android/gallery3d/filtershow/filters/FilterDrawRepresentation.java
+++ b/src/com/android/gallery3d/filtershow/filters/FilterDrawRepresentation.java
@@ -271,6 +271,9 @@ public class FilterDrawRepresentation extends FilterRepresentation {
     public void fillStrokeParameters(StrokeData sd){
         byte type = (byte) mParamStyle.getSelected();
         int color = computeCurrentColor();
+        if (color == 0) {
+            color = DEFAULT_MENU_COLOR1;
+        }
         float size = mParamSize.getValue();
         sd.mColor = color;
         sd.mRadius = size;
diff --git a/src/com/android/gallery3d/filtershow/imageshow/ImageShow.java b/src/com/android/gallery3d/filtershow/imageshow/ImageShow.java
index e2f21f326..88acef227 100644
--- a/src/com/android/gallery3d/filtershow/imageshow/ImageShow.java
+++ b/src/com/android/gallery3d/filtershow/imageshow/ImageShow.java
@@ -600,9 +600,12 @@ public class ImageShow extends View implements OnGestureListener,
     }
 
     public void saveImage(FilterShowActivity filterShowActivity, File file) {
-        SaveImage.saveImage(getImagePreset(), filterShowActivity, file);
+        saveImage(filterShowActivity, file, false);
     }
 
+    public void saveImage(FilterShowActivity filterShowActivity, File file, boolean notMoveSource){
+        SaveImage.saveImage(getImagePreset(), filterShowActivity, file, notMoveSource);
+    }
 
     public boolean scaleInProgress() {
         return mScaleGestureDetector.isInProgress();
diff --git a/src/com/android/gallery3d/filtershow/imageshow/MasterImage.java b/src/com/android/gallery3d/filtershow/imageshow/MasterImage.java
index f6b97f11f..96ff0ea59 100644
--- a/src/com/android/gallery3d/filtershow/imageshow/MasterImage.java
+++ b/src/com/android/gallery3d/filtershow/imageshow/MasterImage.java
@@ -831,6 +831,6 @@ public class MasterImage implements RenderingRequestCaller {
     }
 
     public boolean hasTinyPlanet() {
-        return mPreset.contains(FilterRepresentation.TYPE_TINYPLANET);
+        return mPreset != null && mPreset.contains(FilterRepresentation.TYPE_TINYPLANET);
     }
 }
diff --git a/src/com/android/gallery3d/filtershow/pipeline/ImagePreset.java b/src/com/android/gallery3d/filtershow/pipeline/ImagePreset.java
index 9166ee3be..ffcc69b63 100644
--- a/src/com/android/gallery3d/filtershow/pipeline/ImagePreset.java
+++ b/src/com/android/gallery3d/filtershow/pipeline/ImagePreset.java
@@ -67,6 +67,9 @@ public class ImagePreset {
     }
 
     public ImagePreset(ImagePreset source) {
+        if(source == null || source.mFilters == null){
+            return;
+        }
         for (int i = 0; i < source.mFilters.size(); i++) {
             FilterRepresentation sourceRepresentation = source.mFilters.elementAt(i);
             mFilters.add(sourceRepresentation.copy());
diff --git a/src/com/android/gallery3d/filtershow/pipeline/ImageSavingTask.java b/src/com/android/gallery3d/filtershow/pipeline/ImageSavingTask.java
index 801aee46b..f3e0db47e 100644
--- a/src/com/android/gallery3d/filtershow/pipeline/ImageSavingTask.java
+++ b/src/com/android/gallery3d/filtershow/pipeline/ImageSavingTask.java
@@ -39,6 +39,7 @@ public class ImageSavingTask extends ProcessingTask {
         float sizeFactor;
         Bitmap previewImage;
         boolean exit;
+        boolean notMoveSource;
     }
 
     static class UpdateBitmap implements Update {
@@ -67,7 +68,8 @@ public class ImageSavingTask extends ProcessingTask {
     public void saveImage(Uri sourceUri, Uri selectedUri,
                           File destinationFile, ImagePreset preset,
                           Bitmap previewImage, boolean flatten,
-                          int quality, float sizeFactor, boolean exit) {
+                          int quality, float sizeFactor,
+                          boolean exit, boolean notMoveSource) {
         SaveRequest request = new SaveRequest();
         request.sourceUri = sourceUri;
         request.selectedUri = selectedUri;
@@ -78,6 +80,7 @@ public class ImageSavingTask extends ProcessingTask {
         request.sizeFactor = sizeFactor;
         request.previewImage = previewImage;
         request.exit = exit;
+        request.notMoveSource = notMoveSource;
         postRequest(request);
     }
 
@@ -115,7 +118,7 @@ public class ImageSavingTask extends ProcessingTask {
                     }
                 });
         Uri uri = saveImage.processAndSaveImage(preset, flatten,
-                request.quality, request.sizeFactor, request.exit);
+                request.quality, request.sizeFactor, request.exit, request.notMoveSource);
         URIResult result = new URIResult();
         result.uri = uri;
         result.exit = request.exit;
diff --git a/src/com/android/gallery3d/filtershow/pipeline/ProcessingService.java b/src/com/android/gallery3d/filtershow/pipeline/ProcessingService.java
index 6c6c2d9a2..16e36a8f0 100644
--- a/src/com/android/gallery3d/filtershow/pipeline/ProcessingService.java
+++ b/src/com/android/gallery3d/filtershow/pipeline/ProcessingService.java
@@ -17,6 +17,7 @@
 package com.android.gallery3d.filtershow.pipeline;
 
 import android.app.Notification;
+import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.Service;
 import android.content.Context;
@@ -53,6 +54,7 @@ public class ProcessingService extends Service {
     private static final String FLATTEN = "flatten";
     private static final String SIZE_FACTOR = "sizeFactor";
     private static final String EXIT = "exit";
+    private static final String SOURCE_NOT_MOVE = "notMoveSource";
 
     private ProcessingTaskController mProcessingTaskController;
     private ImageSavingTask mImageSavingTask;
@@ -67,6 +69,8 @@ public class ProcessingService extends Service {
     private boolean mSaving = false;
     private boolean mNeedsAlive = false;
 
+    private static final String CHANNEL_ID_GALLERY_PROCESS = "gallery2_process";
+
     public void setFiltershowActivity(FilterShowActivity filtershowActivity) {
         mFiltershowActivity = filtershowActivity;
     }
@@ -140,9 +144,16 @@ public class ProcessingService extends Service {
         }
     }
 
+    public static Intent getSaveIntent(Context context, ImagePreset preset, File destination,
+                                       Uri selectedImageUri, Uri sourceImageUri, boolean doFlatten, int quality,
+                                       float sizeFactor, boolean needsExit) {
+        return getSaveIntent(context, preset, destination, selectedImageUri,
+                sourceImageUri, doFlatten, quality, sizeFactor, needsExit, false);
+    }
+
     public static Intent getSaveIntent(Context context, ImagePreset preset, File destination,
             Uri selectedImageUri, Uri sourceImageUri, boolean doFlatten, int quality,
-            float sizeFactor, boolean needsExit) {
+            float sizeFactor, boolean needsExit, boolean notMoveSource) {
         Intent processIntent = new Intent(context, ProcessingService.class);
         processIntent.putExtra(ProcessingService.SOURCE_URI,
                 sourceImageUri.toString());
@@ -157,6 +168,7 @@ public class ProcessingService extends Service {
                 preset.getJsonString(ImagePreset.JASON_SAVED));
         processIntent.putExtra(ProcessingService.SAVING, true);
         processIntent.putExtra(ProcessingService.EXIT, needsExit);
+        processIntent.putExtra(ProcessingService.SOURCE_NOT_MOVE, notMoveSource);
         if (doFlatten) {
             processIntent.putExtra(ProcessingService.FLATTEN, true);
         }
@@ -196,6 +208,7 @@ public class ProcessingService extends Service {
             String source = intent.getStringExtra(SOURCE_URI);
             String selected = intent.getStringExtra(SELECTED_URI);
             String destination = intent.getStringExtra(DESTINATION_FILE);
+            boolean notMoveSource = intent.getBooleanExtra(SOURCE_NOT_MOVE, false);
             int quality = intent.getIntExtra(QUALITY, 100);
             float sizeFactor = intent.getFloatExtra(SIZE_FACTOR, 1);
             boolean flatten = intent.getBooleanExtra(FLATTEN, false);
@@ -215,7 +228,7 @@ public class ProcessingService extends Service {
             mSaving = true;
             handleSaveRequest(sourceUri, selectedUri, destinationFile, preset,
                     MasterImage.getImage().getHighresImage(),
-                    flatten, quality, sizeFactor, exit);
+                    flatten, quality, sizeFactor, exit, notMoveSource);
         }
         return START_REDELIVER_INTENT;
     }
@@ -234,12 +247,12 @@ public class ProcessingService extends Service {
 
     public void handleSaveRequest(Uri sourceUri, Uri selectedUri,
             File destinationFile, ImagePreset preset, Bitmap previewImage,
-            boolean flatten, int quality, float sizeFactor, boolean exit) {
+            boolean flatten, int quality, float sizeFactor, boolean exit, boolean notMoveSource) {
         mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
         mNotifyMgr.cancelAll();
 
         mBuilder =
-                new Notification.Builder(this)
+                new Notification.Builder(this, getNotifyChannelGalleryProcessId(this))
                         .setSmallIcon(R.drawable.filtershow_button_fx)
                         .setContentTitle(getString(R.string.filtershow_notification_label))
                         .setContentText(getString(R.string.filtershow_notification_message));
@@ -251,7 +264,7 @@ public class ProcessingService extends Service {
         // Process the image
 
         mImageSavingTask.saveImage(sourceUri, selectedUri, destinationFile,
-                preset, previewImage, flatten, quality, sizeFactor, exit);
+                preset, previewImage, flatten, quality, sizeFactor, exit, notMoveSource);
     }
 
     public void updateNotificationWithBitmap(Bitmap bitmap) {
@@ -321,4 +334,25 @@ public class ProcessingService extends Service {
     static {
         System.loadLibrary("jni_filtershow_filters");
     }
+
+
+    private String getNotifyChannelGalleryProcessId(Context context){
+        // create android channel
+        NotificationChannel androidChannel = new NotificationChannel(CHANNEL_ID_GALLERY_PROCESS,
+                CHANNEL_ID_GALLERY_PROCESS, NotificationManager.IMPORTANCE_LOW);
+        // Sets whether notifications posted to this channel should display notification lights
+        androidChannel.enableLights(false);
+        androidChannel.enableVibration(false);
+        // Sets whether notification posted to this channel should vibrate.
+        //androidChannel.enableVibration(true);
+        // Sets the notification light color for notifications posted to this channel
+        //androidChannel.setLightColor(Color.GREEN);
+        // Sets whether notifications posted to this channel appear on the lockscreen or not
+        androidChannel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE);
+
+        final NotificationManager nm =
+                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+        nm.createNotificationChannel(androidChannel);
+        return CHANNEL_ID_GALLERY_PROCESS;
+    }
 }
diff --git a/src/com/android/gallery3d/filtershow/tools/SaveImage.java b/src/com/android/gallery3d/filtershow/tools/SaveImage.java
index 17d698f15..8c2b49a86 100644
--- a/src/com/android/gallery3d/filtershow/tools/SaveImage.java
+++ b/src/com/android/gallery3d/filtershow/tools/SaveImage.java
@@ -326,7 +326,8 @@ public class SaveImage {
     }
 
     public Uri processAndSaveImage(ImagePreset preset, boolean flatten,
-                                   int quality, float sizeFactor, boolean exit) {
+                                   int quality, float sizeFactor,
+                                   boolean exit, boolean notMoveSource) {
 
         Uri uri = null;
         if (exit) {
@@ -346,7 +347,7 @@ public class SaveImage {
         // newSourceUri is then pointing to the new location.
         // If no file is moved, newSourceUri will be the same as mSourceUri.
         Uri newSourceUri = mSourceUri;
-        if (!flatten) {
+        if (!flatten && !notMoveSource) {
             newSourceUri = moveSrcToAuxIfNeeded(mSourceUri, mDestinationFile);
         }
 
@@ -533,7 +534,7 @@ public class SaveImage {
     }
 
     public static void saveImage(ImagePreset preset, final FilterShowActivity filterShowActivity,
-            File destination) {
+            File destination, boolean notMoveSource) {
         Uri selectedImageUri = filterShowActivity.getSelectedImageUri();
         Uri sourceImageUri = MasterImage.getImage().getUri();
         boolean flatten = false;
@@ -541,7 +542,7 @@ public class SaveImage {
             flatten = true;
         }
         Intent processIntent = ProcessingService.getSaveIntent(filterShowActivity, preset,
-                destination, selectedImageUri, sourceImageUri, flatten, 90, 1f, true);
+                destination, selectedImageUri, sourceImageUri, flatten, 90, 1f, true, notMoveSource);
 
         filterShowActivity.startService(processIntent);
 
diff --git a/src/com/android/gallery3d/gadget/PhotoAppWidgetProvider.java b/src/com/android/gallery3d/gadget/PhotoAppWidgetProvider.java
index 58466bf01..c361d5105 100644
--- a/src/com/android/gallery3d/gadget/PhotoAppWidgetProvider.java
+++ b/src/com/android/gallery3d/gadget/PhotoAppWidgetProvider.java
@@ -16,28 +16,34 @@
 
 package com.android.gallery3d.gadget;
 
+import java.util.ArrayList;
+
 import android.annotation.TargetApi;
 import android.app.PendingIntent;
 import android.appwidget.AppWidgetManager;
 import android.appwidget.AppWidgetProvider;
+import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.database.ContentObserver;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.net.Uri;
+import android.os.Handler;
 import android.util.Log;
 import android.widget.RemoteViews;
-
+import android.content.IntentFilter;
 import com.android.gallery3d.R;
 import com.android.gallery3d.common.ApiHelper;
 import com.android.gallery3d.gadget.WidgetDatabaseHelper.Entry;
 import com.android.gallery3d.onetimeinitializer.GalleryWidgetMigrator;
+import com.android.gallery3d.util.LinkedNode.List;
 
 public class PhotoAppWidgetProvider extends AppWidgetProvider {
 
     private static final String TAG = "WidgetProvider";
 
-    static RemoteViews buildWidget(Context context, int id, Entry entry) {
+    public static RemoteViews buildWidget(Context context, int id, Entry entry) {
 
         switch (entry.type) {
             case WidgetDatabaseHelper.TYPE_ALBUM:
@@ -48,7 +54,9 @@ public class PhotoAppWidgetProvider extends AppWidgetProvider {
         }
         throw new RuntimeException("invalid type - " + entry.type);
     }
-
+    
+    private static ArrayList<Integer> appWidgetIdList = new ArrayList<Integer>();
+    
     @Override
     public void onUpdate(Context context,
             AppWidgetManager appWidgetManager, int[] appWidgetIds) {
@@ -61,6 +69,7 @@ public class PhotoAppWidgetProvider extends AppWidgetProvider {
         WidgetDatabaseHelper helper = new WidgetDatabaseHelper(context);
         try {
             for (int id : appWidgetIds) {
+                appWidgetIdList.add(id);
                 Entry entry = helper.getEntry(id);
                 if (entry != null) {
                     RemoteViews views = buildWidget(context, id, entry);
@@ -136,4 +145,25 @@ public class PhotoAppWidgetProvider extends AppWidgetProvider {
         }
         helper.close();
     }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {     
+        if(intent.getAction().equals("widget_update")){
+            // migrate gallery widgets from pre-JB releases to JB due to bucket ID change
+            GalleryWidgetMigrator.migrateGalleryWidgets(context);
+
+            WidgetDatabaseHelper helper = new WidgetDatabaseHelper(context);
+                for (int i = 0;i < appWidgetIdList.size();i++) {
+                    int id = appWidgetIdList.get(i);
+                    Entry entry = helper.getEntry(id);
+                    if (entry != null) {
+                        RemoteViews views = buildWidget(context, id, entry);
+                        AppWidgetManager.getInstance(context).updateAppWidget(id, views);
+                    } else {
+                        Log.e(TAG, "cannot load widget: " + id);
+                    }
+                }
+        }
+        super.onReceive(context, intent);
+    }
 }
diff --git a/src/com/android/gallery3d/gadget/WidgetService.java b/src/com/android/gallery3d/gadget/WidgetService.java
index fc54fb6e8..999be12b1 100644
--- a/src/com/android/gallery3d/gadget/WidgetService.java
+++ b/src/com/android/gallery3d/gadget/WidgetService.java
@@ -19,8 +19,13 @@ package com.android.gallery3d.gadget;
 import android.annotation.TargetApi;
 import android.appwidget.AppWidgetManager;
 import android.content.Intent;
+import android.database.ContentObserver;
 import android.graphics.Bitmap;
 import android.net.Uri;
+import android.os.Handler;
+import android.os.Message;
+import android.provider.MediaStore;
+import android.util.Log;
 import android.widget.RemoteViews;
 import android.widget.RemoteViewsService;
 
@@ -77,12 +82,39 @@ public class WidgetService extends RemoteViewsService {
             AppWidgetManager.getInstance(mApp.getAndroidContext())
                     .notifyAppWidgetViewDataChanged(
                     mAppWidgetId, R.id.appwidget_stack_view);
+            mApp.getContentResolver().registerContentObserver(  
+                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI, true, mObserver);  
         }
+        
+        private ContentObserver mObserver = new ContentObserver(new Handler()) {          
+            @Override  
+            public void onChange(boolean selfChange) {  
+                mHandler.removeMessages(MSG);
+                mHandler.sendEmptyMessageDelayed(MSG, 3000);
+            }  
+        }; 
+        
+        private final int MSG = 0x01;
+        private Handler mHandler = new Handler(){
+            @Override
+            public void handleMessage(Message msg) {
+                switch (msg.what) {
+                case MSG:
+                    mSource.reload();
+                    AppWidgetManager.getInstance(mApp.getAndroidContext())
+                    .notifyAppWidgetViewDataChanged(
+                    mAppWidgetId, R.id.appwidget_stack_view);
+                    break;
+                }
+            }
+            
+        };
 
         @Override
         public void onDestroy() {
             mSource.close();
             mSource = null;
+            mApp.getContentResolver().unregisterContentObserver(mObserver);
         }
 
         @Override
diff --git a/src/com/android/gallery3d/glrenderer/UploadedTexture.java b/src/com/android/gallery3d/glrenderer/UploadedTexture.java
index 417102a38..bc301e66c 100644
--- a/src/com/android/gallery3d/glrenderer/UploadedTexture.java
+++ b/src/com/android/gallery3d/glrenderer/UploadedTexture.java
@@ -59,7 +59,7 @@ public abstract class UploadedTexture extends BasicTexture {
     private static int sUploadedCount;
     private static final int UPLOAD_LIMIT = 100;
 
-    protected Bitmap mBitmap;
+    public Bitmap mBitmap;
     private int mBorder;
 
     protected UploadedTexture() {
@@ -134,6 +134,9 @@ public abstract class UploadedTexture extends BasicTexture {
     private Bitmap getBitmap() {
         if (mBitmap == null) {
             mBitmap = onGetBitmap();
+            if(mBitmap == null){
+                return null;
+            }
             int w = mBitmap.getWidth() + mBorder * 2;
             int h = mBitmap.getHeight() + mBorder * 2;
             if (mWidth == UNSPECIFIED) {
@@ -144,7 +147,10 @@ public abstract class UploadedTexture extends BasicTexture {
     }
 
     private void freeBitmap() {
-        Utils.assertTrue(mBitmap != null);
+//        Utils.assertTrue(mBitmap != null);
+        if(mBitmap == null){
+            return;
+        }
         onFreeBitmap(mBitmap);
         mBitmap = null;
     }
@@ -191,6 +197,9 @@ public abstract class UploadedTexture extends BasicTexture {
             uploadToCanvas(canvas);
         } else if (!mContentValid) {
             Bitmap bitmap = getBitmap();
+            if(bitmap == null){
+                return;
+            }
             int format = GLUtils.getInternalFormat(bitmap);
             int type = GLUtils.getType(bitmap);
             canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
@@ -266,7 +275,7 @@ public abstract class UploadedTexture extends BasicTexture {
             mContentValid = true;
         } else {
             mState = STATE_ERROR;
-            throw new RuntimeException("Texture load fail, no bitmap");
+            //throw new RuntimeException("Texture load fail, no bitmap");
         }
     }
 
diff --git a/src/com/android/gallery3d/ingest/IngestService.java b/src/com/android/gallery3d/ingest/IngestService.java
index 262e41086..08c5fd918 100644
--- a/src/com/android/gallery3d/ingest/IngestService.java
+++ b/src/com/android/gallery3d/ingest/IngestService.java
@@ -23,6 +23,8 @@ import com.android.gallery3d.ingest.data.MtpClient;
 import com.android.gallery3d.ingest.data.MtpDeviceIndex;
 
 import android.annotation.TargetApi;
+import android.app.Notification;
+import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Service;
@@ -79,13 +81,14 @@ public class IngestService extends Service implements ImportTask.Listener,
   private NotificationCompat.Builder mNotificationBuilder;
   private long mLastProgressIndexTime = 0;
   private boolean mNeedRelaunchNotification = false;
+  private static final String CHANNEL_ID_GALLERY_INGEST = "gallery2_ingest";
 
   @Override
   public void onCreate() {
     super.onCreate();
     mScannerClient = new ScannerClient(this);
     mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
-    mNotificationBuilder = new NotificationCompat.Builder(this);
+    mNotificationBuilder = new NotificationCompat.Builder(this, getNotifyChannelGalleryProcessId(this));
     // TODO(georgescu): Use a better drawable for the notificaton?
     mNotificationBuilder.setSmallIcon(android.R.drawable.stat_notify_sync)
         .setContentIntent(PendingIntent.getActivity(this, 0,
@@ -331,4 +334,24 @@ public class IngestService extends Service implements ImportTask.Listener,
     public void onScanCompleted(String path, Uri uri) {
     }
   }
+
+  private String getNotifyChannelGalleryProcessId(Context context){
+    // create android channel
+    NotificationChannel androidChannel = new NotificationChannel(CHANNEL_ID_GALLERY_INGEST,
+            CHANNEL_ID_GALLERY_INGEST, NotificationManager.IMPORTANCE_LOW);
+    // Sets whether notifications posted to this channel should display notification lights
+    androidChannel.enableLights(false);
+    androidChannel.enableVibration(false);
+    // Sets whether notification posted to this channel should vibrate.
+    //androidChannel.enableVibration(true);
+    // Sets the notification light color for notifications posted to this channel
+    //androidChannel.setLightColor(Color.GREEN);
+    // Sets whether notifications posted to this channel appear on the lockscreen or not
+    androidChannel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE);
+
+    final NotificationManager nm =
+            (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+    nm.createNotificationChannel(androidChannel);
+    return CHANNEL_ID_GALLERY_INGEST;
+  }
 }
diff --git a/src/com/android/gallery3d/ingest/data/MtpDeviceIndex.java b/src/com/android/gallery3d/ingest/data/MtpDeviceIndex.java
index ebfbc9227..b21ad8355 100644
--- a/src/com/android/gallery3d/ingest/data/MtpDeviceIndex.java
+++ b/src/com/android/gallery3d/ingest/data/MtpDeviceIndex.java
@@ -3,15 +3,10 @@ package com.android.gallery3d.ingest.data;
 import android.annotation.TargetApi;
 import android.mtp.MtpConstants;
 import android.mtp.MtpDevice;
-import android.mtp.MtpObjectInfo;
 import android.os.Build;
-import android.webkit.MimeTypeMap;
 
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Locale;
-import java.util.Map;
 import java.util.Set;
 
 /**
@@ -89,18 +84,12 @@ public class MtpDeviceIndex {
     supportedImageFormats.add(MtpConstants.FORMAT_PNG);
     supportedImageFormats.add(MtpConstants.FORMAT_GIF);
     supportedImageFormats.add(MtpConstants.FORMAT_BMP);
-    supportedImageFormats.add(MtpConstants.FORMAT_TIFF);
-    supportedImageFormats.add(MtpConstants.FORMAT_TIFF_EP);
-    if (Build.VERSION.SDK_INT >= 24) {
-      supportedImageFormats.add(MtpConstants.FORMAT_DNG);
-    }
     SUPPORTED_IMAGE_FORMATS = Collections.unmodifiableSet(supportedImageFormats);
 
     Set<Integer> supportedVideoFormats = new HashSet<Integer>();
     supportedVideoFormats.add(MtpConstants.FORMAT_3GP_CONTAINER);
     supportedVideoFormats.add(MtpConstants.FORMAT_AVI);
     supportedVideoFormats.add(MtpConstants.FORMAT_MP4_CONTAINER);
-    supportedVideoFormats.add(MtpConstants.FORMAT_MP2);
     supportedVideoFormats.add(MtpConstants.FORMAT_MPEG);
     // TODO(georgescu): add FORMAT_MOV once Android Media Scanner supports .mov files
     SUPPORTED_VIDEO_FORMATS = Collections.unmodifiableSet(supportedVideoFormats);
@@ -115,8 +104,6 @@ public class MtpDeviceIndex {
   private static final MtpDeviceIndex sInstance = new MtpDeviceIndex(
       MtpDeviceIndexRunnable.getFactory());
 
-  private static final Map<String, Boolean> sCachedSupportedExtenstions = new HashMap<>();
-
   public static MtpDeviceIndex getInstance() {
     return sInstance;
   }
@@ -134,41 +121,12 @@ public class MtpDeviceIndex {
   }
 
   /**
-   * @param mtpObjectInfo MTP object info
+   * @param format Media format from {@link MtpConstants}
    * @return Whether the format is supported by this index.
    */
-  public boolean isFormatSupported(MtpObjectInfo mtpObjectInfo) {
-    // Checks whether the format is supported or not.
-    final int format = mtpObjectInfo.getFormat();
-    if (SUPPORTED_IMAGE_FORMATS.contains(format)
-        || SUPPORTED_VIDEO_FORMATS.contains(format)) {
-      return true;
-    }
-
-    // Checks whether the extension is supported or not.
-    final String name = mtpObjectInfo.getName();
-    if (name == null) {
-      return false;
-    }
-    final int lastDot = name.lastIndexOf('.');
-    if (lastDot >= 0) {
-      final String extension = name.substring(lastDot + 1);
-
-      Boolean result = sCachedSupportedExtenstions.get(extension);
-      if (result != null) {
-        return result;
-      }
-      final String mime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(
-          extension.toLowerCase(Locale.US));
-      if (mime != null) {
-        // This will also accept the newly added mimetypes for images and videos.
-        result = mime.startsWith("image/") || mime.startsWith("video/");
-        sCachedSupportedExtenstions.put(extension, result);
-        return result;
-      }
-    }
-
-    return false;
+  public boolean isFormatSupported(int format) {
+    return SUPPORTED_IMAGE_FORMATS.contains(format)
+        || SUPPORTED_VIDEO_FORMATS.contains(format);
   }
 
   /**
diff --git a/src/com/android/gallery3d/ingest/data/MtpDeviceIndexRunnable.java b/src/com/android/gallery3d/ingest/data/MtpDeviceIndexRunnable.java
index fe558157a..32275898e 100644
--- a/src/com/android/gallery3d/ingest/data/MtpDeviceIndexRunnable.java
+++ b/src/com/android/gallery3d/ingest/data/MtpDeviceIndexRunnable.java
@@ -171,9 +171,10 @@ public class MtpDeviceIndexRunnable implements Runnable {
           if (mtpObjectInfo == null) {
             throw new IndexingException();
           }
-          if (mtpObjectInfo.getFormat() == MtpConstants.FORMAT_ASSOCIATION) {
+          int format = mtpObjectInfo.getFormat();
+          if (format == MtpConstants.FORMAT_ASSOCIATION) {
             pendingDirectories.add(objectHandle);
-          } else if (mIndex.isFormatSupported(mtpObjectInfo)) {
+          } else if (mIndex.isFormatSupported(format)) {
             numObjects++;
             addObject(new IngestObjectInfo(mtpObjectInfo), bucketsTemp, numObjects);
           }
diff --git a/src/com/android/gallery3d/ui/GLRootView.java b/src/com/android/gallery3d/ui/GLRootView.java
index dc898d83d..22834389f 100644
--- a/src/com/android/gallery3d/ui/GLRootView.java
+++ b/src/com/android/gallery3d/ui/GLRootView.java
@@ -60,7 +60,7 @@ import javax.microedition.khronos.opengles.GL11;
 // (2) The public methods of CameraHeadUpDisplay
 // (3) The overridden methods in GLRootView.
 public class GLRootView extends GLSurfaceView
-        implements GLSurfaceView.Renderer, GLRoot {
+        implements GLSurfaceView.Renderer, GLRoot, View.OnGenericMotionListener {
     private static final String TAG = "GLRootView";
 
     private static final boolean DEBUG_FPS = false;
@@ -120,20 +120,24 @@ public class GLRootView extends GLSurfaceView
         mFlags |= FLAG_INITIALIZED;
         setBackgroundDrawable(null);
         setEGLContextClientVersion(ApiHelper.HAS_GLES20_REQUIRED ? 2 : 1);
-        if (ApiHelper.USE_888_PIXEL_FORMAT) {
+        /*if (ApiHelper.USE_888_PIXEL_FORMAT) {
             setEGLConfigChooser(8, 8, 8, 0, 0, 0);
         } else {
             setEGLConfigChooser(5, 6, 5, 0, 0, 0);
-        }
+        }*/
+        setEGLConfigChooser(8, 8, 8, 8, 16, 0);
         setRenderer(this);
-        if (ApiHelper.USE_888_PIXEL_FORMAT) {
+        /*if (ApiHelper.USE_888_PIXEL_FORMAT) {
             getHolder().setFormat(PixelFormat.RGB_888);
         } else {
             getHolder().setFormat(PixelFormat.RGB_565);
-        }
+        }*/
+        getHolder().setFormat(PixelFormat.RGBA_8888);
 
         // Uncomment this to enable gl error check.
         // setDebugFlags(DEBUG_CHECK_GL_ERROR);
+
+        setOnGenericMotionListener(this);
     }
 
     @Override
@@ -353,7 +357,11 @@ public class GLRootView extends GLSurfaceView
 
         try {
             onDrawFrameLocked(gl);
-        } finally {
+        }
+        catch (NullPointerException e){
+            //e.printStackTrace(); 
+        }
+        finally {
             mRenderLock.unlock();
         }
 
@@ -399,11 +407,12 @@ public class GLRootView extends GLSurfaceView
 
         mRenderRequested = false;
 
-        if ((mOrientationSource != null
+        /*if ((mOrientationSource != null
                 && mDisplayRotation != mOrientationSource.getDisplayRotation())
                 || (mFlags & FLAG_NEED_LAYOUT) != 0) {
             layoutContentPane();
-        }
+        }*/
+        if ((mFlags & FLAG_NEED_LAYOUT) != 0) layoutContentPane();
 
         mCanvas.save(GLCanvas.SAVE_FLAG_ALL);
         rotateCanvas(-mCompensation);
@@ -457,9 +466,16 @@ public class GLRootView extends GLSurfaceView
     }
 
     @Override
-    public boolean dispatchTouchEvent(MotionEvent event) {
+    public boolean onGenericMotion(View v, MotionEvent event) {
         if (!isEnabled()) return false;
+        if(mContentView!=null)
+        mContentView.dispatchGenericMotion(v,event);
+        return false;
+    }
 
+    @Override
+    public boolean dispatchTouchEvent(MotionEvent event) {
+        if (!isEnabled()) return false;
         int action = event.getAction();
         if (action == MotionEvent.ACTION_CANCEL
                 || action == MotionEvent.ACTION_UP) {
diff --git a/src/com/android/gallery3d/ui/GLView.java b/src/com/android/gallery3d/ui/GLView.java
index 83de19fe4..95c9cc844 100644
--- a/src/com/android/gallery3d/ui/GLView.java
+++ b/src/com/android/gallery3d/ui/GLView.java
@@ -19,6 +19,7 @@ package com.android.gallery3d.ui;
 import android.graphics.Rect;
 import android.os.SystemClock;
 import android.view.MotionEvent;
+import android.view.View;
 
 import com.android.gallery3d.anim.CanvasAnimation;
 import com.android.gallery3d.anim.StateTransitionAnimation;
@@ -292,6 +293,21 @@ public class GLView {
         return false;
     }
 
+    protected boolean onGenericMotion(View v, MotionEvent event){
+        return false;
+    }
+
+    protected boolean dispatchGenericMotion(View v, MotionEvent event) {
+        for (int i = getComponentCount() - 1; i >= 0; --i) {
+            GLView component = getComponent(i);
+            if (component.getVisibility() != GLView.VISIBLE) continue;
+            if (component.onGenericMotion(v, event)) {
+                return true;
+            }
+        }
+        return onGenericMotion(v,event);
+    }
+
     protected boolean dispatchTouchEvent(MotionEvent event,
             int x, int y, GLView component, boolean checkBounds) {
         Rect rect = component.mBounds;
diff --git a/src/com/android/gallery3d/ui/MenuExecutor.java b/src/com/android/gallery3d/ui/MenuExecutor.java
index 22b3b575a..1f3d8eda2 100644
--- a/src/com/android/gallery3d/ui/MenuExecutor.java
+++ b/src/com/android/gallery3d/ui/MenuExecutor.java
@@ -27,6 +27,7 @@ import android.content.Intent;
 import android.os.Handler;
 import android.os.Message;
 import androidx.print.PrintHelper;
+import android.util.ConfigUtil;
 import android.view.Menu;
 import android.view.MenuItem;
 
@@ -42,6 +43,7 @@ import com.android.gallery3d.util.Future;
 import com.android.gallery3d.util.GalleryUtils;
 import com.android.gallery3d.util.ThreadPool.Job;
 import com.android.gallery3d.util.ThreadPool.JobContext;
+import com.android.gallery3d.app.PhotoPage;
 
 import java.util.ArrayList;
 
@@ -110,6 +112,16 @@ public class MenuExecutor {
                             listener.onProgressComplete(message.arg1);
                         }
                         mSelectionManager.leaveSelectionMode();
+                        if (message.arg2 == R.id.action_delete
+                                && !(mActivity.getStateManager().getTopState() instanceof PhotoPage)) {
+                                mActivity.getStateManager().pause();
+                                mActivity.getStateManager().resume();
+                        }
+                        if(message.arg2 == R.id.action_delete && mActivity.getStateManager().getTopState() 
+                                instanceof PhotoPage){
+                            Intent intent = new Intent(PhotoPage.PHOTOPAGE_UPDATE);
+                            mActivity.getAndroidContext().sendBroadcast(intent);
+                        }
                         break;
                     }
                     case MSG_TASK_UPDATE: {
@@ -161,8 +173,8 @@ public class MenuExecutor {
         mHandler.sendMessage(mHandler.obtainMessage(MSG_TASK_START, listener));
     }
 
-    private void onProgressComplete(int result, ProgressListener listener) {
-        mHandler.sendMessage(mHandler.obtainMessage(MSG_TASK_COMPLETE, result, 0, listener));
+    private void onProgressComplete(int result, ProgressListener listener,int mOperation) {
+        mHandler.sendMessage(mHandler.obtainMessage(MSG_TASK_COMPLETE, result, mOperation, listener));
     }
 
     public static void updateMenuOperation(Menu menu, int supported) {
@@ -184,8 +196,8 @@ public class MenuExecutor {
         setMenuItemVisible(menu, R.id.action_rotate_ccw, supportRotate);
         setMenuItemVisible(menu, R.id.action_rotate_cw, supportRotate);
         setMenuItemVisible(menu, R.id.action_crop, supportCrop);
-        setMenuItemVisible(menu, R.id.action_trim, supportTrim);
-        setMenuItemVisible(menu, R.id.action_mute, supportMute);
+        setMenuItemVisible(menu, R.id.action_trim, supportTrim && ConfigUtil.SUPPORT_VIDEO_TRIM);
+        setMenuItemVisible(menu, R.id.action_mute, supportMute && ConfigUtil.SUPPORT_VIDEO_MUTE);
         // Hide panorama until call to updateMenuForPanorama corrects it
         setMenuItemVisible(menu, R.id.action_share_panorama, false);
         setMenuItemVisible(menu, R.id.action_share, supportShare);
@@ -443,7 +455,7 @@ public class MenuExecutor {
                 Log.e(TAG, "failed to execute operation " + mOperation
                         + " : " + th);
             } finally {
-               onProgressComplete(result, mListener);
+               onProgressComplete(result, mListener,mOperation);
             }
             return null;
         }
diff --git a/src/com/android/gallery3d/ui/PhotoView.java b/src/com/android/gallery3d/ui/PhotoView.java
index e8c706f05..9e4b8ffee 100644
--- a/src/com/android/gallery3d/ui/PhotoView.java
+++ b/src/com/android/gallery3d/ui/PhotoView.java
@@ -1,4 +1,5 @@
 /*
+ * $_FOR_ROCKCHIP_RBOX_$
  * Copyright (C) 2010 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -23,7 +24,10 @@ import android.graphics.Matrix;
 import android.graphics.Rect;
 import android.os.Build;
 import android.os.Message;
+import android.util.FloatMath;
+import android.util.Log;
 import android.view.MotionEvent;
+import android.view.View;
 import android.view.View.MeasureSpec;
 import android.view.animation.AccelerateInterpolator;
 
@@ -43,6 +47,8 @@ import com.android.gallery3d.util.GalleryUtils;
 import com.android.gallery3d.util.RangeArray;
 import com.android.gallery3d.util.UsageStatistics;
 
+import java.lang.Throwable;
+
 public class PhotoView extends GLView {
     @SuppressWarnings("unused")
     private static final String TAG = "PhotoView";
@@ -162,6 +168,15 @@ public class PhotoView extends GLView {
     private static float TRANSITION_SCALE_FACTOR = 0.74f;
     private static final int ICON_RATIO = 6;
 
+    //$_rbox_$_modify_$_chengmingchuan_$_20140225_$_[Info: Handle Keycode]
+    // $_rbox_$_modify_$_begin
+    private static final int TRANS_NONE = 0;
+    private static final int TRANS_SWITCH_NEXT = 3;
+    private static final int TRANS_SWITCH_PREVIOUS = 4;
+    private int mTransitionMode = TRANS_NONE;
+    // $_rbox_$_modify_$_end
+
+
     // whether we want to apply card deck effect in page mode.
     private static final boolean CARD_EFFECT = true;
 
@@ -228,6 +243,18 @@ public class PhotoView extends GLView {
     private static final int HOLD_CAPTURE_ANIMATION = 2;
     private static final int HOLD_DELETE = 4;
 
+    //$_rbox_$_modify_$_chengmingchuan_$_20140225_$_[Info: Handle Keycode]
+    // $_rbox_$_modify_$_begin 
+    public final int ZOOMIN    = 0;
+    public final int ZOOMOUT = 1;
+    public int mZoomCount = 0;
+    public final int  SLIDE_LEFT=1;
+    public final int  SLIDE_RIGHT=2;
+
+    private final int ZOOMMAX=3;
+    private float mScale = 1.0f;
+     // $_rbox_$_modify_$_end
+
     // mTouchBoxIndex is the index of the box that is touched by the down
     // gesture in film mode. The value Integer.MAX_VALUE means no box was
     // touched.
@@ -244,6 +271,7 @@ public class PhotoView extends GLView {
 
     public PhotoView(AbstractGalleryActivity activity) {
         mTileView = new TileImageView(activity);
+        mTileView.setPhoteView(this);
         addComponent(mTileView);
         mContext = activity.getAndroidContext();
         mPlaceholderColor = mContext.getResources().getColor(
@@ -504,6 +532,8 @@ public class PhotoView extends GLView {
         }
 
         updateCameraRect();
+        mTileView.isGifStream(mFilmMode);
+        mTileView.decodePhoto();
         mPositionController.setConstrainedFrame(mCameraRect);
         if (changeSize) {
             mPositionController.setViewSize(getWidth(), getHeight());
@@ -574,6 +604,49 @@ public class PhotoView extends GLView {
         return mCompensation;
     }
 
+    //$_rbox_$_modify_$_chengmingchuan_$_20140225_$_[Info: Handle Keycode]
+    // $_rbox_$_modify_$_begin
+    public boolean scalingImage(int zoom){
+         if (mTransitionMode != TRANS_NONE) return false;
+            PositionController controller = mPositionController;
+         if(controller.isAtMinimalScale()){mZoomCount=0;}
+         if(mZoomCount==0){mScale= controller.getCurrentScale();}
+         if(zoom == ZOOMOUT && (mZoomCount<ZOOMMAX)){
+             mZoomCount++;
+                controller.zoomIn(getWidth()/2, getHeight()/2, Math.max((1.0f+mZoomCount*0.3f), mScale * (1.0f+mZoomCount*0.3f)));
+             return true;
+         }
+         if((zoom == ZOOMIN) && (mZoomCount>0)){
+          mZoomCount--;
+          if(0==mZoomCount){controller.resetToFullView();return true;}
+          controller.zoomIn(getWidth()/2, getHeight()/2, Math.max((1.0f+mZoomCount*0.3f), mScale * (1.0f+mZoomCount*0.3f)));
+          return true;
+            }
+         return false;
+    }
+    // $_rbox_$_modify_$_end
+
+    //$_rbox_$_modify_$_chengmingchuan_$_20140225_$_[Info: Handle Keycode]
+    // $_rbox_$_modify_$_begin
+    public boolean slideShowImage(int dir, boolean showbar){
+        if (mTransitionMode != TRANS_NONE) return false;
+     if (true == showbar) return false;
+
+     if(dir==SLIDE_RIGHT){
+        slideToNextPicture();
+        Log.d(TAG, "SlideShowImage(SLIDE_RIGHT) OK!");
+        return true;
+     }
+     if(dir==SLIDE_LEFT){
+        slideToPrevPicture();
+        Log.d(TAG, "SlideShowImage(SLIDE_LEFT) OK!");
+        return true;
+     }
+     return false;
+    }
+    // $_rbox_$_modify_$_end
+
+
     ////////////////////////////////////////////////////////////////////////////
     //  Pictures
     ////////////////////////////////////////////////////////////////////////////
@@ -942,6 +1015,24 @@ public class PhotoView extends GLView {
         return true;
     }
 
+    @Override
+    protected boolean onGenericMotion(View v, MotionEvent event) {
+        if (mPictures.get(0).isCamera()) return false;
+        if (event.getAction() != MotionEvent.ACTION_SCROLL) return false;
+        float scrollvalue = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
+
+        PositionController controller = mPositionController;
+        float scale = controller.getImageScale();
+
+        if (scrollvalue > 0 && scale < 4.0f){
+            controller.zoomIn(event.getX(), event.getY(), Math.min(4.0f, scale * 1.5f));
+        } else if(scrollvalue < 0 && scale > 1.0f ){
+            controller.zoomIn(event.getX(), event.getY(), Math.max(1.0f, scale * 0.5f));
+        }
+
+        return true;
+    }
+
     private class MyGestureListener implements GestureRecognizer.Listener {
         private boolean mIgnoreUpEvent = false;
         // If we can change mode for this scale gesture.
@@ -1113,6 +1204,10 @@ public class PhotoView extends GLView {
                     && ((vy > 0) == (centerY > getHeight() / 2))
                     && dY >= escapeDistance;
             if (fastEnough) {
+                if(mModel.getMediaItem(mTouchBoxIndex).getContentUri().equals(mTileView.mUri)){
+                    switchToNextImage();
+                    mTileView.setGifPic(false);
+                }
                 vy = Math.min(vy, maxVelocity);
                 int duration = mPositionController.flingFilmY(mTouchBoxIndex, vy);
                 if (duration >= 0) {
@@ -1325,6 +1420,7 @@ public class PhotoView extends GLView {
     public void setFilmMode(boolean enabled) {
         if (mFilmMode == enabled) return;
         mFilmMode = enabled;
+        mTileView.isGifStream(mFilmMode);
         mPositionController.setFilmMode(mFilmMode);
         mModel.setNeedFullImage(!enabled);
         mModel.setFocusHintDirection(
@@ -1351,9 +1447,14 @@ public class PhotoView extends GLView {
     }
 
     public void resume() {
+        mTileView.isGifStream(mFilmMode);
         mTileView.prepareTextures();
         mPositionController.skipToFinalPosition();
     }
+    
+    public void updateCurrentIndex(){
+        mTileView.isGifStream(mFilmMode);
+    }
 
     // move to the camera preview and show controls after resume
     public void resetToFirstPicture() {
@@ -1622,18 +1723,26 @@ public class PhotoView extends GLView {
 
     public void switchToImage(int index) {
         mModel.moveTo(index);
+        mTileView.isGifStream(mFilmMode);
+        mTileView.decodePhoto();
     }
 
     private void switchToNextImage() {
         mModel.moveTo(mModel.getCurrentIndex() + 1);
+        mTileView.isGifStream(mFilmMode);
+        mTileView.decodePhoto();
     }
 
     private void switchToPrevImage() {
         mModel.moveTo(mModel.getCurrentIndex() - 1);
+        mTileView.isGifStream(mFilmMode);
+        mTileView.decodePhoto();
     }
 
     private void switchToFirstImage() {
         mModel.moveTo(0);
+        mTileView.isGifStream(mFilmMode);
+        mTileView.decodePhoto();
     }
 
     ////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/android/gallery3d/ui/PositionController.java b/src/com/android/gallery3d/ui/PositionController.java
index 6a4bcea87..73e6abc1b 100644
--- a/src/com/android/gallery3d/ui/PositionController.java
+++ b/src/com/android/gallery3d/ui/PositionController.java
@@ -1,4 +1,5 @@
 /*
+ * $_FOR_ROCKCHIP_RBOX_$
  * Copyright (C) 2011 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -1184,6 +1185,14 @@ class PositionController {
     //  Public utilities
     ////////////////////////////////////////////////////////////////////////////
 
+    //$_rbox_$_modify_$_chengmingchuan_$_20121212_$_[Info: Handle Keycode]
+    // $_rbox_$_modify_$_begin
+     public float getCurrentScale() {
+        Box b = mBoxes.get(0);
+        return b.mCurrentScale;
+    }
+    // $_rbox_$_modify_$_end
+
     public boolean isAtMinimalScale() {
         Box b = mBoxes.get(0);
         return isAlmostEqual(b.mCurrentScale, b.mScaleMin);
diff --git a/src/com/android/gallery3d/ui/TileImageView.java b/src/com/android/gallery3d/ui/TileImageView.java
index 36500a0ca..3ce02a401 100644
--- a/src/com/android/gallery3d/ui/TileImageView.java
+++ b/src/com/android/gallery3d/ui/TileImageView.java
@@ -16,26 +16,43 @@
 
 package com.android.gallery3d.ui;
 
+import android.content.ContentUris;
 import android.content.Context;
+import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.Point;
 import android.graphics.Rect;
 import android.graphics.RectF;
 import androidx.collection.LongSparseArray;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Message;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Images.ImageColumns;
 import android.util.DisplayMetrics;
 import android.view.WindowManager;
 
 import com.android.gallery3d.app.GalleryContext;
+import com.android.gallery3d.app.Log;
+import com.android.gallery3d.app.PhotoPage;
 import com.android.gallery3d.common.Utils;
 import com.android.gallery3d.data.DecodeUtils;
+import com.android.gallery3d.data.MediaItem;
 import com.android.photos.data.GalleryBitmapPool;
+import com.android.gallery3d.glrenderer.BitmapTexture;
 import com.android.gallery3d.glrenderer.GLCanvas;
 import com.android.gallery3d.glrenderer.UploadedTexture;
 import com.android.gallery3d.util.Future;
+import com.android.gallery3d.util.FutureListener;
 import com.android.gallery3d.util.ThreadPool;
 import com.android.gallery3d.util.ThreadPool.CancelListener;
 import com.android.gallery3d.util.ThreadPool.JobContext;
+import com.android.gallery3d.data.MediaItem.BitmapInfo;
+import com.android.gif.GifTextrue;
+import com.android.gif.GifTextrueFactory;
 
+import java.io.FileNotFoundException;
+import java.io.InputStream;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 public class TileImageView extends GLView {
@@ -72,6 +89,7 @@ public class TileImageView extends GLView {
     private static final int STATE_DECODE_FAIL = 0x10;
     private static final int STATE_RECYCLING = 0x20;
     private static final int STATE_RECYCLED = 0x40;
+    private enum DisplaySize{ SMALL, MEDIUM, LARGE, EXTRA_LARGE };
 
     private TileSource mModel;
     private ScreenNail mScreenNail;
@@ -150,16 +168,246 @@ public class TileImageView extends GLView {
         return metrics.heightPixels > 2048 ||  metrics.widthPixels > 2048;
     }
 
+    public static DisplaySize getDisplayResolutionType(Context context) {
+        DisplayMetrics metrics = new DisplayMetrics();
+        WindowManager wm = (WindowManager)
+                context.getSystemService(Context.WINDOW_SERVICE);
+        wm.getDefaultDisplay().getMetrics(metrics);
+        int density=metrics.heightPixels* metrics.widthPixels;
+        DisplaySize currentDpSize=DisplaySize.MEDIUM;
+        if(density>=8294400)//3840x2160, 4K
+        {
+            currentDpSize=DisplaySize.EXTRA_LARGE;
+        }
+        else if(density>=3686400)//2560 x 1440 ,2K
+        {
+            currentDpSize=DisplaySize.LARGE;
+        }
+        else if(density>=2073600)//1920x1080 ,1080p
+        {
+            currentDpSize=DisplaySize.MEDIUM;
+        }
+        else //below 1080p
+        {
+            currentDpSize=DisplaySize.SMALL;
+        }
+        return currentDpSize;
+    }
+    
+ // jyzheng add 2012-02-27
+    public Context mContext = null;
+    private boolean isGifPic = false;
+    private boolean isReload = false;
+    private String filePath = null;
+    public Uri mUri = null;
+    private Object obj = new Object();
+    private Future<?> mTask;
+    private boolean isBMPPic = false;
+    private BitmapScreenNail mBitmapScreenNail = null;
+
+    public void setGifPic(boolean isGifPic) {
+        synchronized (obj) {
+            this.isGifPic = isGifPic;
+            mUri = null;
+            filePath = null;
+        }   
+    }
+    
+    public static Uri getTrueUri(Context context,Uri mUri){
+        if(mUri == null || mUri.getPath() == null){
+            return mUri;
+        }
+        if(mUri.toString().startsWith("file://")){
+            Uri uri = MediaStore.Images.Media.getContentUri("external");
+            Cursor cur = context.getContentResolver().query(uri, null, null, null, null);
+            String path = mUri.getPath();
+            if(cur.moveToFirst()){
+                while(!cur.isAfterLast()){
+                    if(cur.getString(cur.getColumnIndexOrThrow(MediaStore.Images.Media.DATA)).equals(path)){
+                        Uri result = ContentUris.withAppendedId(uri,cur.getInt(cur.getColumnIndexOrThrow(MediaStore.Images.Media._ID)));
+                        cur.close();
+                        cur = null;
+                        return result;
+                    }else{ 
+                        cur.moveToNext();
+                    }
+                }
+            }
+            if(cur != null){
+                cur.close();
+                cur = null;
+            }
+        }       
+        return mUri;    
+    }
+
+    public void isGifStream(boolean mFilmMode) {
+        synchronized (obj) {
+            if(!(mModel instanceof PhotoPage.Model)){
+                return;
+            }
+            MediaItem item = ((PhotoPage.Model) mModel).getCurrentMediaItem();
+            if(item == null){
+                isReload = true;
+                return;
+            }
+            Uri uri = null;
+            String mimeType = item.getMimeType();
+            try{
+                uri = getTrueUri(mContext, item.getContentUri());
+            }catch (Exception e) {
+                return;
+            }
+            mUri = uri;
+            String str = uri != null ? uri.toString():null;
+            boolean isGif = mimeType.toLowerCase().endsWith("gif");
+//              if(!isGif && isChangeFilmMode){
+//                  return;
+//              }else{
+                mDecodeUri = null;
+                isGifPic = false;
+                isBMPPic = false;
+                isReload = false;
+//              }
+            if (isGif) {
+                InputStream is = null;
+                boolean flag = false;
+                if(!mFilmMode){
+                    is = getInputStream(mContext, str);
+                    flag = GifTextrue.isGifStream(is);
+                }
+                if(flag){
+                    isGifPic = true;
+                    Cursor c = mContext.getContentResolver().query(uri,
+                            new String[] { ImageColumns.DATA }, null, null, null);
+                    if (c != null) {
+                        c.moveToFirst();
+                        filePath = c.getString(0);
+                        if(filePath == null){
+                            isGifPic = false;
+                            return;
+                        }
+                        GifTextrueFactory.startOnly(new GifTextrue(this, null,
+                                filePath));
+                        c.close();
+                        c = null;
+                    }else{
+                        if(filePath == null){
+                            String temp = uri.toString();
+                            if(temp != null && temp.startsWith("file://")){
+                                filePath = temp.substring(7);
+                            }else{
+                                isGifPic = false;
+                                return;
+                            }
+                        }
+                    }
+                }else{
+                    GifTextrueFactory.freezeAllGif();
+                    isGifPic = false;
+                }
+            } else {
+                if(!mFilmMode && mimeType != null && mimeType.startsWith("image/")
+                        && mimeType.endsWith("bmp")){
+                    if(mTask != null){
+                        mTask.cancel();
+                    }
+                    isBMPPic = true;
+                    mTask = mThreadPool.submit(
+                        item.requestDecodeImage(MediaItem.TYPE_DECODE,mUri),
+                          mListener);
+                }else{
+                    isBMPPic = false;
+                }
+            }
+        }
+    }
+    
+    private static final int MSG_UPDATE_IMAGE = 1;
+    private FutureListener<BitmapInfo> mListener = new FutureListener<BitmapInfo>() {
+        public void onFutureDone(Future<BitmapInfo> future) {
+            mHandler.sendMessage(mHandler.obtainMessage(MSG_UPDATE_IMAGE,
+                    future));
+        }
+    };
+    
+    private Handler mHandler = new Handler() {
+          public void handleMessage(Message message) {
+              onDecodeComplete((Future<BitmapInfo>) message.obj);
+          }
+      };
+      
+      private Uri mDecodeUri = null;
+      private void onDecodeComplete(Future<BitmapInfo> future) {
+          try {
+            if(future == null || future.get() == null){
+                return;
+            }           
+            if(future.get().getmUri() != mUri){
+                return;
+            }
+            mDecodeUri = future.get().getmUri();
+              Bitmap backup = future.get().getmBitmap();
+              if(mBitmapScreenNail != null){
+                mBitmapScreenNail.recycle();
+                mBitmapScreenNail = null;
+              }
+              if(backup == null){
+                return;
+              }
+              
+              mBitmapScreenNail = new BitmapScreenNail(backup);
+              notifyModelInvalidated();
+          } catch (Throwable t) {
+              Log.w(TAG, "fail to decode thumb", t);
+          }
+      }
+
+    public void decodePhoto() {
+
+    }
+
+    private static InputStream getInputStream(Context c, String uri) {
+        if (uri == null) {
+            return null;
+        }
+        try {
+            return c.getContentResolver().openInputStream(Uri.parse(uri));
+        } catch (FileNotFoundException e) {
+
+            e.printStackTrace();
+            return null;
+        }
+
+    }
+
     public TileImageView(GalleryContext context) {
+        mContext = context.getAndroidContext();
         mThreadPool = context.getThreadPool();
         mTileDecoder = mThreadPool.submit(new TileDecoder());
         if (sTileSize == 0) {
-            if (isHighResolution(context.getAndroidContext())) {
-                sTileSize = 512 ;
-            } else {
-                sTileSize = 256;
-            }
+            DisplaySize ds=getDisplayResolutionType(context.getAndroidContext());
+            switch(ds){
+              case EXTRA_LARGE:
+                    sTileSize=4096;
+                    break;
+              case LARGE:
+                    sTileSize=2048;
+                    break;
+              case MEDIUM:
+                    sTileSize=1024;
+                    break;
+              case SMALL:
+                    sTileSize=512;
+                    break;
+                    }
         }
+            Log.d(TAG,"TileImageView sTileSize="+sTileSize);
+    }
+    
+    PhotoView mPhotoView = null;
+    public void setPhoteView(PhotoView photoView){
+        mPhotoView = photoView;
     }
 
     public void setModel(TileSource model) {
@@ -252,6 +500,9 @@ public class TileImageView extends GLView {
             int n = mActiveTiles.size();
             for (int i = 0; i < n; i++) {
                 Tile tile = mActiveTiles.valueAt(i);
+                if(tile == null){
+                    continue;
+                }
                 int level = tile.mTileLevel;
                 if (level < fromLevel || level >= endLevel
                         || !range[level - fromLevel].contains(tile.mX, tile.mY)) {
@@ -375,7 +626,9 @@ public class TileImageView extends GLView {
         int n = mActiveTiles.size();
         for (int i = 0; i < n; i++) {
             Tile texture = mActiveTiles.valueAt(i);
-            texture.recycle();
+            if(texture != null){
+                texture.recycle();
+            }
         }
         mActiveTiles.clear();
         mTileRange.set(0, 0, 0, 0);
@@ -390,6 +643,7 @@ public class TileImageView extends GLView {
             }
         }
         setScreenNail(null);
+        GifTextrueFactory.freezeAllGif();
     }
 
     public void prepareTextures() {
@@ -405,6 +659,14 @@ public class TileImageView extends GLView {
 
     @Override
     protected void render(GLCanvas canvas) {
+        if(isReload && ((PhotoPage.Model) mModel).getCurrentMediaItem() != null){
+            if(mPhotoView != null){
+                isGifStream(mPhotoView.getFilmMode());
+            }else{
+                isGifStream(true);
+            }
+            isReload = false;
+        }
         mUploadQuota = UPLOAD_LIMIT;
         mRenderComplete = true;
 
@@ -422,23 +684,42 @@ public class TileImageView extends GLView {
                 canvas.translate(-centerX, -centerY);
             }
         }
-        try {
-            if (level != mLevelCount && !isScreenNailAnimating()) {
-                if (mScreenNail != null) {
-                    mScreenNail.noDraw();
-                }
-
-                int size = (sTileSize << level);
-                float length = size * mScale;
-                Rect r = mTileRange;
-
-                for (int ty = r.top, i = 0; ty < r.bottom; ty += size, i++) {
-                    float y = mOffsetY + i * length;
-                    for (int tx = r.left, j = 0; tx < r.right; tx += size, j++) {
-                        float x = mOffsetX + j * length;
-                        drawTile(canvas, tx, ty, level, x, y, length);
+        if (isGifPic) {
+            if (GifTextrueFactory.getGifTextrue() != null) {
+                BitmapTexture bitmapTexture = GifTextrueFactory.getGifTextrue()
+                        .getBitmapTexture();
+                if (bitmapTexture != null) {
+                    bitmapTexture.draw(canvas, mOffsetX, mOffsetY, Math
+                            .round(mImageWidth * mScale), Math
+                            .round(mImageHeight * mScale));
+                    if(bitmapTexture.mBitmap != null){
+                       bitmapTexture.mBitmap.recycle();
+                       bitmapTexture.mBitmap= null;
+                    }
+                    bitmapTexture = null;
+                } else if (mScreenNail != null) {
+                    mScreenNail.draw(canvas, mOffsetX, mOffsetY,
+                            Math.round(mImageWidth * mScale),
+                            Math.round(mImageHeight * mScale));
+                    if (isScreenNailAnimating()) {
+                        invalidate();
                     }
                 }
+            }else{
+                if(filePath == null){
+                    isGifPic = false;
+                    return;
+                }
+                GifTextrueFactory.startOnly(new GifTextrue(this, null,
+                        filePath));
+            }
+            if (rotation != 0)
+                canvas.restore();
+        } else if(isBMPPic){
+            if(mBitmapScreenNail != null && mDecodeUri != null && mDecodeUri == mUri){
+                mBitmapScreenNail.draw(canvas, mOffsetX, mOffsetY,
+                        Math.round(mImageWidth * mScale),
+                        Math.round(mImageHeight * mScale));
             } else if (mScreenNail != null) {
                 mScreenNail.draw(canvas, mOffsetX, mOffsetY,
                         Math.round(mImageWidth * mScale),
@@ -447,8 +728,36 @@ public class TileImageView extends GLView {
                     invalidate();
                 }
             }
-        } finally {
-            if (flags != 0) canvas.restore();
+        }else{
+            try {
+                if (level != mLevelCount && !isScreenNailAnimating()) {
+                    if (mScreenNail != null) {
+                        mScreenNail.noDraw();
+                    }
+
+                    int size = (sTileSize << level);
+                    float length = size * mScale;
+                    Rect r = mTileRange;
+
+                    for (int ty = r.top, i = 0; ty < r.bottom; ty += size, i++) {
+                        float y = mOffsetY + i * length;
+                        for (int tx = r.left, j = 0; tx < r.right; tx += size, j++) {
+                            float x = mOffsetX + j * length;
+                            drawTile(canvas, tx, ty, level, x, y, length);
+                        }
+                    }
+                } else if (mScreenNail != null) {
+                    mScreenNail.draw(canvas, mOffsetX, mOffsetY,
+                            Math.round(mImageWidth * mScale),
+                            Math.round(mImageHeight * mScale));
+                    if (isScreenNailAnimating()) {
+                        invalidate();
+                    }
+                }
+            } finally {
+                if (flags != 0)
+                    canvas.restore();
+            }
         }
 
         if (mRenderComplete) {
@@ -468,7 +777,7 @@ public class TileImageView extends GLView {
         int n = mActiveTiles.size();
         for (int i = 0; i < n; i++) {
             Tile tile = mActiveTiles.valueAt(i);
-            if (!tile.isContentValid()) queueForDecode(tile);
+            if (tile != null && !tile.isContentValid()) queueForDecode(tile);
         }
     }
 
@@ -520,6 +829,9 @@ public class TileImageView extends GLView {
     }
 
     synchronized void recycleTile(Tile tile) {
+        if(tile == null){
+            return;
+        }
         if (tile.mTileState == STATE_DECODING) {
             tile.mTileState = STATE_RECYCLING;
             return;
@@ -573,7 +885,7 @@ public class TileImageView extends GLView {
                 if (tile == null) break;
                 if (!tile.isContentValid()) {
                     boolean hasBeenLoaded = tile.isLoaded();
-                    Utils.assertTrue(tile.mTileState == STATE_DECODED);
+//                    Utils.assertTrue(tile.mTileState == STATE_DECODED);
                     tile.updateContent(canvas);
                     if (!hasBeenLoaded) tile.draw(canvas, 0, 0);
                     --quota;
@@ -682,7 +994,7 @@ public class TileImageView extends GLView {
 
         @Override
         protected Bitmap onGetBitmap() {
-            Utils.assertTrue(mTileState == STATE_DECODED);
+            //Utils.assertTrue(mTileState == STATE_DECODED);
 
             // We need to override the width and height, so that we won't
             // draw beyond the boundaries.
diff --git a/src/com/android/gallery3d/util/BitmapUtils.java b/src/com/android/gallery3d/util/BitmapUtils.java
new file mode 100644
index 000000000..8c017f85e
--- /dev/null
+++ b/src/com/android/gallery3d/util/BitmapUtils.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.gallery3d.util;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.BitmapFactory;
+import android.graphics.Matrix;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.provider.MediaStore.Images.ImageColumns;
+import android.util.Log;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Utils for bitmap operations.
+ */
+public class BitmapUtils {
+
+    private static final String TAG = "BitmapUtils";
+    private static final int DEFAULT_COMPRESS_QUALITY = 90;
+    private static final int INDEX_ORIENTATION = 0;
+
+    private static final String[] IMAGE_PROJECTION = new String[] {
+        ImageColumns.ORIENTATION
+    };
+
+    private final Context context;
+
+    public BitmapUtils(Context context) {
+        this.context = context;
+    }
+
+    private static Bitmap createBitmap(Bitmap source, Matrix m) {
+        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), m, true);
+    }
+
+    private void closeStream(Closeable stream) {
+        if (stream != null) {
+            try {
+                stream.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private Rect getBitmapBounds(Uri uri) {
+        Rect bounds = new Rect();
+        InputStream is = null;
+
+        try {
+            is = context.getContentResolver().openInputStream(uri);
+            BitmapFactory.Options options = new BitmapFactory.Options();
+            options.inJustDecodeBounds = true;
+            BitmapFactory.decodeStream(is, null, options);
+
+            bounds.right = options.outWidth;
+            bounds.bottom = options.outHeight;
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } finally {
+            closeStream(is);
+        }
+
+        return bounds;
+    }
+
+    private int getOrientation(Uri uri) {
+        int orientation = 0;
+        Cursor cursor = null;
+        try {
+            cursor = context.getContentResolver().query(uri, IMAGE_PROJECTION, null, null, null);
+            if ((cursor != null) && cursor.moveToNext()) {
+                orientation = cursor.getInt(INDEX_ORIENTATION);
+            }
+        } catch (Exception e) {
+            // Ignore error for no orientation column; just use the default orientation value 0.
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+        return orientation;
+    }
+
+    /**
+     * Decodes bitmap that keeps aspect-ratio and spans most within the bounds.
+     */
+    private Bitmap decodeBitmap(Uri uri, int width, int height) {
+        InputStream is = null;
+        Bitmap bitmap = null;
+
+        try {
+            // TODO: Take max pixels allowed into account for calculation to avoid possible OOM.
+            Rect bounds = getBitmapBounds(uri);
+            int sampleSize = Math.max(bounds.width() / width, bounds.height() / height);
+            sampleSize = Math.min(sampleSize,
+                    Math.max(bounds.width() / height, bounds.height() / width));
+
+            BitmapFactory.Options options = new BitmapFactory.Options();
+            options.inSampleSize = Math.max(sampleSize, 1);
+            options.inPreferredConfig = Bitmap.Config.ARGB_8888;
+
+            is = context.getContentResolver().openInputStream(uri);
+            bitmap = BitmapFactory.decodeStream(is, null, options);
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "FileNotFoundException: " + uri);
+        } finally {
+            closeStream(is);
+        }
+
+        // Ensure bitmap in 8888 format, good for editing as well as GL compatible.
+        if ((bitmap != null) && (bitmap.getConfig() != Bitmap.Config.ARGB_8888)) {
+            Bitmap copy = bitmap.copy(Bitmap.Config.ARGB_8888, true);
+            bitmap.recycle();
+            bitmap = copy;
+        }
+
+        if (bitmap != null) {
+            // Scale down the sampled bitmap if it's still larger than the desired dimension.
+            float scale = Math.min((float) width / bitmap.getWidth(),
+                    (float) height / bitmap.getHeight());
+            scale = Math.max(scale, Math.min((float) height / bitmap.getWidth(),
+                    (float) width / bitmap.getHeight()));
+            if (scale < 1) {
+                Matrix m = new Matrix();
+                m.setScale(scale, scale);
+                Bitmap transformed = createBitmap(bitmap, m);
+                bitmap.recycle();
+                return transformed;
+            }
+        }
+        return bitmap;
+    }
+
+    /**
+     * Gets decoded bitmap (maybe immutable) that keeps orientation as well.
+     */
+    public Bitmap getBitmap(Uri uri, int width, int height) {
+        Bitmap bitmap = decodeBitmap(uri, width, height);
+
+        // Rotate the decoded bitmap according to its orientation if it's necessary.
+        if (bitmap != null) {
+            int orientation = getOrientation(uri);
+            if (orientation != 0) {
+                Matrix m = new Matrix();
+                m.setRotate(orientation);
+                Bitmap transformed = createBitmap(bitmap, m);
+                bitmap.recycle();
+                return transformed;
+            }
+        }
+        return bitmap;
+    }
+
+    public Bitmap getNotRotateBitmap(Uri uri, int width, int height) {
+        Bitmap bitmap = decodeBitmap(uri, width, height);
+        return bitmap;
+    }
+
+    /**
+     * Saves the bitmap by given directory, filename, and format; if the directory is given null,
+     * then saves it under the cache directory.
+     */
+    public File saveBitmap(Bitmap bitmap, File directory, String filename, CompressFormat format) {
+
+        if (directory == null) {
+            directory = context.getCacheDir();
+        } else {
+            // Check if the given directory exists or try to create it.
+            if (!directory.isDirectory() && !directory.mkdirs()) {
+                return null;
+            }
+        }
+
+        File file = null;
+        OutputStream os = null;
+
+        try {
+            filename = (format == CompressFormat.PNG) ? filename + ".png" : filename + ".jpg";
+            file = new File(directory, filename);
+            os = new FileOutputStream(file);
+            bitmap.compress(format, DEFAULT_COMPRESS_QUALITY, os);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } finally {
+            closeStream(os);
+        }
+        return file;
+    }
+}
diff --git a/src/com/android/gallery3d/util/CacheManager.java b/src/com/android/gallery3d/util/CacheManager.java
index ba466f79b..4803a8792 100644
--- a/src/com/android/gallery3d/util/CacheManager.java
+++ b/src/com/android/gallery3d/util/CacheManager.java
@@ -46,6 +46,9 @@ public class CacheManager {
             BlobCache cache = sCacheMap.get(filename);
             if (cache == null) {
                 File cacheDir = context.getExternalCacheDir();
+                if(cacheDir == null || !cacheDir.exists()){
+                    return null;
+                }
                 String path = cacheDir.getAbsolutePath() + "/" + filename;
                 try {
                     cache = new BlobCache(path, maxEntries, maxBytes, false,
@@ -73,6 +76,9 @@ public class CacheManager {
         pref.edit().putInt(KEY_CACHE_UP_TO_DATE, 1).commit();
 
         File cacheDir = context.getExternalCacheDir();
+        if(cacheDir == null || !cacheDir.exists()){
+            return ;
+        }
         String prefix = cacheDir.getAbsolutePath() + "/";
 
         BlobCache.deleteFiles(prefix + "imgcache");
diff --git a/src/com/android/gif/GifAction.java b/src/com/android/gif/GifAction.java
new file mode 100644
index 000000000..bb479cded
--- /dev/null
+++ b/src/com/android/gif/GifAction.java
@@ -0,0 +1,6 @@
+package com.android.gif;
+
+public interface GifAction {
+
+    public void parseOk(boolean parseStatus, int frameIndex);
+}
diff --git a/src/com/android/gif/GifDecoder.java b/src/com/android/gif/GifDecoder.java
new file mode 100644
index 000000000..502d393c1
--- /dev/null
+++ b/src/com/android/gif/GifDecoder.java
@@ -0,0 +1,751 @@
+package com.android.gif;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.os.HandlerThread;
+import android.util.Log;
+
+public class GifDecoder extends Thread {
+    private static final int MaxStackSize = 4096;
+    // max decoder pixel stack size
+
+    public static final int STATUS_FINISH = -1;
+    public static final int STATUS_FORMAT_ERROR = 1;
+    public static final int STATUS_OPEN_ERROR = 2;
+
+    public static final int STATUS_PARSING = 0;
+    private int[] act; // active color table
+    private GifAction action = null;
+    private int bgColor; // background color
+    private int bgIndex; // background color index
+    private byte[] block = new byte[256]; // current data block
+    private int blockSize = 0; // block size
+
+    private GifFrame currentFrame = null;
+    private int delay = 0; // delay in milliseconds
+    // last graphic control extension info
+    private int dispose = 0;
+
+    private int frameCount;
+    private int[] gct; // global color table
+    private boolean gctFlag; // global color table used
+    private int gctSize; // size of global color table
+
+    private byte[] gifData = null;
+    private GifFrame gifFrame; // frames read from current file
+    public int height; // full image height
+
+    private Bitmap image; // current frame
+
+    private InputStream in;
+    private boolean interlace; // interlace flag
+    private boolean isShow = false;
+    private int ix, iy, iw, ih; // current image rectangle
+
+    private int lastBgColor; // previous bg color
+
+    // 0=no action; 1=leave in place; 2=restore to bg; 3=restore to prev
+    private int lastDispose = 0;
+    private Bitmap lastImage; // previous frame
+
+    private int[] lct; // local color table
+    private boolean lctFlag; // local color table flag
+    private int lctSize; // local color table size
+    private int loopCount = 1; // iterations; 0 = repeat forever
+    private int lrx, lry, lrw, lrh;
+
+    private int pixelAspect; // pixel aspect ratio
+
+    private byte[] pixels;
+    private byte[] pixelStack;
+    // LZW decoder working arrays
+    private short[] prefix;
+    private int status;
+
+    private byte[] suffix;
+    private int transIndex; // transparent color index
+
+    private boolean transparency = false; // use transparent color
+
+    public int width; // full image width
+
+    public GifDecoder(byte[] data, GifAction act) {
+        gifData = data;
+        action = act;
+    }
+
+    public GifDecoder(InputStream is, GifAction act) {
+        in = is;
+        action = act;
+    }
+
+    public GifDecoder(String path, GifAction act) throws FileNotFoundException {
+        this(new FileInputStream(new File(path)), act);
+    }
+
+    private void decodeImageData() {
+        int NullCode = -1;
+        int npix = iw * ih;
+        int available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, count, i, datum, data_size, first, top, bi, pi;
+
+        if ((pixels == null) || (pixels.length < npix)) {
+            pixels = new byte[npix]; // allocate new pixel arrays
+        }
+        if (prefix == null) {
+            prefix = new short[MaxStackSize];
+        }
+        if (suffix == null) {
+            suffix = new byte[MaxStackSize];
+        }
+        if (pixelStack == null) {
+            pixelStack = new byte[MaxStackSize + 1];
+        }
+        // Initialize GIF data stream decoder.
+        data_size = read();
+        clear = 1 << data_size;
+        end_of_information = clear + 1;
+        available = clear + 2;
+        old_code = NullCode;
+        code_size = data_size + 1;
+        code_mask = (1 << code_size) - 1;
+        for (code = 0; code < clear; code++) {
+            prefix[code] = 0;
+            suffix[code] = (byte) code;
+        }
+
+        // Decode GIF pixel stream.
+        datum = bits = count = first = top = pi = bi = 0;
+        for (i = 0; i < npix;) {
+            if (top == 0) {
+                if (bits < code_size) {
+                    // Load bytes until there are enough bits for a code.
+                    if (count == 0) {
+                        // Read a new data block.
+                        count = readBlock();
+                        if (count <= 0) {
+                            break;
+                        }
+                        bi = 0;
+                    }
+                    datum += (((int) block[bi]) & 0xff) << bits;
+                    bits += 8;
+                    bi++;
+                    count--;
+                    continue;
+                }
+                // Get the next code.
+                code = datum & code_mask;
+                datum >>= code_size;
+                bits -= code_size;
+
+                // Interpret the code
+                if ((code > available) || (code == end_of_information)) {
+                    break;
+                }
+                if (code == clear) {
+                    // Reset decoder.
+                    code_size = data_size + 1;
+                    code_mask = (1 << code_size) - 1;
+                    available = clear + 2;
+                    old_code = NullCode;
+                    continue;
+                }
+                if (old_code == NullCode) {
+                    pixelStack[top++] = suffix[code];
+                    old_code = code;
+                    first = code;
+                    continue;
+                }
+                in_code = code;
+                if (code == available) {
+                    pixelStack[top++] = (byte) first;
+                    code = old_code;
+                }
+                while (code > clear) {
+                    pixelStack[top++] = suffix[code];
+                    code = prefix[code];
+                }
+                first = ((int) suffix[code]) & 0xff;
+                // Add a new string to the string table,
+                if (available >= MaxStackSize) {
+                    break;
+                }
+                pixelStack[top++] = (byte) first;
+                prefix[available] = (short) old_code;
+                suffix[available] = (byte) first;
+                available++;
+                if (((available & code_mask) == 0) && (available < MaxStackSize)) {
+                    code_size++;
+                    code_mask += available;
+                }
+                old_code = in_code;
+            }
+            // Pop a pixel off the pixel stack.
+            top--;
+            pixels[pi++] = pixelStack[top];
+            i++;
+        }
+        for (i = pi; i < npix; i++) {
+            pixels[i] = 0; // clear missing pixels
+        }
+    }
+
+    private boolean err() {
+        return status != STATUS_PARSING;
+    }
+
+    public void free() {
+        GifFrame fg = gifFrame;
+        while (fg != null) {
+            if (fg.image != null) {
+                fg.image.recycle();
+            }
+            fg.image = null;
+            fg = null;
+            gifFrame = gifFrame.nextFrame;
+            fg = gifFrame;
+        }
+        fg = currentFrame;
+        while (fg != null) {
+            if (fg.image != null) {
+                fg.image.recycle();
+            }
+            fg.image = null;
+            fg = null;
+            currentFrame = currentFrame.nextFrame;
+            fg = currentFrame;
+        }
+        if(image != null) {
+            image.recycle();
+            image = null;
+        }
+        if(lastImage != null) {
+            lastImage.recycle();
+            lastImage = null;
+        }
+        if (in != null) {
+            try {
+                in.close();
+            } catch (Exception ex) {
+            }
+            in = null;
+        }
+
+        gifData = null;
+        act = null;
+        block = null;
+        gct = null;
+        lct = null;
+        pixels = null;
+        pixelStack = null;
+        prefix = null;
+        suffix = null;
+    }
+
+    public GifFrame getCurrentFrame() {
+        return currentFrame;
+    }
+
+    public int getDelay(int n) {
+        delay = -1;
+        if ((n >= 0) && (n < frameCount)) {
+            // delay = ((GifFrame) frames.elementAt(n)).delay;
+            GifFrame f = getFrame(n);
+            if (f != null)
+                delay = f.delay;
+        }
+        return delay;
+    }
+
+    public int[] getDelays() {
+        GifFrame f = gifFrame;
+        int[] d = new int[frameCount];
+        int i = 0;
+        while (f != null && i < frameCount) {
+            d[i] = f.delay;
+            f = f.nextFrame;
+            i++;
+        }
+        return d;
+    }
+
+    public GifFrame getFrame(int n) {
+        GifFrame frame = gifFrame;
+        int i = 0;
+        while (frame != null) {
+            if (i == n) {
+                return frame;
+            } else {
+                frame = frame.nextFrame;
+            }
+            i++;
+        }
+        return null;
+    }
+
+    public int getFrameCount() {
+        return frameCount;
+    }
+
+    public Bitmap getFrameImage(int n) {
+        GifFrame frame = getFrame(n);
+        if (frame == null)
+            return null;
+        else
+            return frame.image;
+    }
+
+    public Bitmap getImage() {
+        return getFrameImage(0);
+    }
+
+    public int getLoopCount() {
+        return loopCount;
+    }
+
+    public int getStatus() {
+        return status;
+    }
+
+    private void init() {
+        status = STATUS_PARSING;
+        frameCount = 0;
+        gifFrame = null;
+        gct = null;
+        lct = null;
+    }
+
+    public GifFrame next() {
+        if (isShow == false) {
+            isShow = true;
+            return gifFrame;
+        } else {
+            if (status == STATUS_PARSING) {
+                if (currentFrame != null && currentFrame.nextFrame != null)
+                    currentFrame = currentFrame.nextFrame;
+                // currentFrame = gifFrame;
+                } else {
+                    /*
+                     * rockchips caijq Add begin for [fix null pointer exception]
+                     * 2010-9-15
+                     */
+                    if (currentFrame == null) {
+                        return null;
+                    }
+                    /* rockchips caijq Add end */
+                    currentFrame = currentFrame.nextFrame;
+                    if (currentFrame == null) {
+                        currentFrame = gifFrame;
+                    }
+                }
+            return currentFrame;
+        }
+    }
+
+    public boolean parseOk() {
+        return status == STATUS_FINISH;
+    }
+
+    private int read() {
+        int curByte = 0;
+        try {
+            curByte = in.read();
+        } catch (Exception e) {
+            status = STATUS_FORMAT_ERROR;
+        }
+        return curByte;
+    }
+
+    // public int read(byte[] data){
+    // InputStream is = new ByteArrayInputStream(data);
+    // return read(is);
+    // }
+
+    private int readBlock() {
+        blockSize = read();
+        int n = 0;
+        if (blockSize > 0) {
+            try {
+                int count = 0;
+                while (n < blockSize) {
+                    count = in.read(block, n, blockSize - n);
+                    if (count == -1) {
+                        break;
+                    }
+                    n += count;
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            if (n < blockSize) {
+                status = STATUS_FORMAT_ERROR;
+            }
+        }
+        return n;
+    }
+
+    private int readByte() {
+        in = new ByteArrayInputStream(gifData);
+        gifData = null;
+        return readStream();
+    }
+
+    private int[] readColorTable(int ncolors) {
+        int nbytes = 3 * ncolors;
+        int[] tab = null;
+        byte[] c = new byte[nbytes];
+        int n = 0;
+        try {
+            n = in.read(c);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        if (n < nbytes) {
+            status = STATUS_FORMAT_ERROR;
+        } else {
+            tab = new int[256]; // max size to avoid bounds checks
+            int i = 0;
+            int j = 0;
+            while (i < ncolors) {
+                int r = ((int) c[j++]) & 0xff;
+                int g = ((int) c[j++]) & 0xff;
+                int b = ((int) c[j++]) & 0xff;
+                tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
+            }
+        }
+        if(c != null){
+            c = null;
+        }
+        return tab;
+    }
+
+    private void readContents() {
+        // read GIF file content blocks
+        boolean done = false;
+        while (!(done || err())) {
+            int code = read();
+            switch (code) {
+                case 0x2C: // image separator
+                    readImage();
+                    break;
+                case 0x21: // extension
+                    code = read();
+                    switch (code) {
+                        case 0xf9: // graphics control extension
+                            readGraphicControlExt();
+                            break;
+                        case 0xff: // application extension
+                            readBlock();
+                            String app = "";
+                            for (int i = 0; i < 11; i++) {
+                                app += (char) block[i];
+                            }
+                            if (app.equals("NETSCAPE2.0")) {
+                                readNetscapeExt();
+                            } else {
+                                skip(); // don't care
+                            }
+                            break;
+                        default: // uninteresting extension
+                            skip();
+                    }
+                    break;
+                case 0x3b: // terminator
+                    done = true;
+                    break;
+                case 0x00: // bad byte, but keep going and see what happens
+                    break;
+                default:
+                    status = STATUS_FORMAT_ERROR;
+            }
+        }
+    }
+
+    private void readGraphicControlExt() {
+        read(); // block size
+        int packed = read(); // packed fields
+        dispose = (packed & 0x1c) >> 2; // disposal method
+        if (dispose == 0) {
+            dispose = 1; // elect to keep old image if discretionary
+        }
+        transparency = (packed & 1) != 0;
+        delay = readShort() * 10; // delay in milliseconds
+        if(delay == 0) {
+            delay = 100;
+        }
+        transIndex = read(); // transparent color index
+        read(); // block terminator
+    }
+
+    private void readHeader() {
+        String id = "";
+        for (int i = 0; i < 6; i++) {
+            id += (char) read();
+        }
+        if (!id.startsWith("GIF")) {
+            status = STATUS_FORMAT_ERROR;
+            return;
+        }
+        readLSD();
+        if (gctFlag && !err()) {
+            gct = readColorTable(gctSize);
+            bgColor = gct[bgIndex];
+        }
+    }
+
+    private void readImage() {
+        ix = readShort(); // (sub)image position & size
+        iy = readShort();
+        iw = readShort();
+        ih = readShort();
+        int packed = read();
+        lctFlag = (packed & 0x80) != 0; // 1 - local color table flag
+        interlace = (packed & 0x40) != 0; // 2 - interlace flag
+        // 3 - sort flag
+        // 4-5 - reserved
+        lctSize = 2 << (packed & 7); // 6-8 - local color table size
+        if (lctFlag) {
+            lct = readColorTable(lctSize); // read table
+            act = lct; // make local table active
+        } else {
+            act = gct; // make global table active
+            if (bgIndex == transIndex) {
+                bgColor = 0;
+            }
+        }
+        int save = 0;
+        if (transparency) {
+            save = act[transIndex];
+            act[transIndex] = 0; // set transparent color if specified
+        }
+        if (act == null) {
+            status = STATUS_FORMAT_ERROR; // no color table defined
+        }
+        if (err()) {
+            return;
+        }
+        decodeImageData(); // decode pixel data
+        skip();
+        if (err()) {
+            return;
+        }
+        frameCount++;
+        // create new image to receive frame data
+        // image = Bitmap.createBitmap(width, height, Config.ARGB_4444);
+        // createImage(width, height);
+        setPixels(); // transfer pixel data to image
+        if (gifFrame == null) {
+            gifFrame = new GifFrame(image, delay);
+            currentFrame = gifFrame;
+        } else {
+            GifFrame f = gifFrame;
+            while (f.nextFrame != null) {
+                f = f.nextFrame;
+    }
+        f.nextFrame = new GifFrame(image, delay);
+        }
+        // frames.addElement(new GifFrame(image, delay)); // add image to frame
+        // list
+        if (transparency) {
+            act[transIndex] = save;
+        }
+        resetFrame();
+        action.parseOk(true, frameCount);
+    }
+
+    private void readLSD() {
+        // logical screen size
+        width = readShort();
+        height = readShort();
+        // packed fields
+        int packed = read();
+        gctFlag = (packed & 0x80) != 0; // 1 : global color table flag
+        // 2-4 : color resolution
+        // 5 : gct sort flag
+        gctSize = 2 << (packed & 7); // 6-8 : gct size
+        bgIndex = read(); // background color index
+        pixelAspect = read(); // pixel aspect ratio
+    }
+
+    private void readNetscapeExt() {
+        do {
+            readBlock();
+            if (block[0] == 1) {
+                // loop count sub-block
+                int b1 = ((int) block[1]) & 0xff;
+                int b2 = ((int) block[2]) & 0xff;
+                loopCount = (b2 << 8) | b1;
+            }
+        } while ((blockSize > 0) && !err());
+    }
+
+    private int readShort() {
+        // read 16-bit value, LSB first
+        return read() | (read() << 8);
+    }
+
+    private int readStream() {
+        init();
+        if (in != null) {
+            readHeader();
+            if (!err()) {
+                readContents();
+                if (frameCount < 0) {
+                    status = STATUS_FORMAT_ERROR;
+                    action.parseOk(false, -1);
+                } else {
+                    status = STATUS_FINISH;
+                    action.parseOk(true, -1);
+                }
+            }
+            /* rockchips caijq Add begin for [should notify invoker] 2010-9-15 */
+            else {
+                action.parseOk(false, -1);
+            }
+            /* rockchips caijq Add end */
+            try {
+                in.close();
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        } else {
+            status = STATUS_OPEN_ERROR;
+            action.parseOk(false, -1);
+        }
+        return status;
+    }
+
+    public void reset() {
+        currentFrame = gifFrame;
+    }
+
+    private void resetFrame() {
+        lastDispose = dispose;
+        lrx = ix;
+        lry = iy;
+        lrw = iw;
+        lrh = ih;
+        lastImage = image;
+        lastBgColor = bgColor;
+        dispose = 0;
+        transparency = false;
+        delay = 0;
+        lct = null;
+    }
+
+    public void run() {
+        if (in != null) {
+            readStream();
+        } else if (gifData != null) {
+            readByte();
+        }
+    }
+
+    private void setPixels() {
+        if(width * height > 4096 * 4096){
+            return;
+        }
+        int[] dest = new int[width * height];
+        // fill in starting image contents based on last image's dispose code
+        if (lastDispose > 0) {
+            if (lastDispose == 3) {
+                // use image before last
+                int n = frameCount - 2;
+                if (n > 0) {
+                    lastImage = getFrameImage(n - 1);
+                } else {
+                    lastImage = null;
+                }
+            }
+            if (lastImage != null) {
+                lastImage.getPixels(dest, 0, width, 0, 0, width, height);
+                // copy pixels
+                if (lastDispose == 2) {
+                    // fill last image rect area with background color
+                    int c = 0;
+                    if (!transparency) {
+                        c = lastBgColor;
+                    }
+                    for (int i = 0; i < lrh; i++) {
+                        int n1 = (lry + i) * width + lrx;
+                        int n2 = n1 + lrw;
+                        for (int k = n1; k < n2; k++) {
+                            dest[k] = c;
+                        }
+                    }
+                }
+            }
+        }
+
+        // copy each source line to the appropriate place in the destination
+        int pass = 1;
+        int inc = 8;
+        int iline = 0;
+        for (int i = 0; i < ih; i++) {
+            int line = i;
+            if (interlace) {
+                if (iline >= ih) {
+                    pass++;
+                    switch (pass) {
+                        case 2:
+                            iline = 4;
+                            break;
+                        case 3:
+                            iline = 2;
+                            inc = 4;
+                            break;
+                        case 4:
+                            iline = 1;
+                            inc = 2;
+                    }
+                }
+                line = iline;
+                iline += inc;
+            }
+            line += iy;
+            if (line < height) {
+                int k = line * width;
+                int dx = k + ix; // start of line in dest
+                int dlim = dx + iw; // end of dest line
+                if ((k + width) < dlim) {
+                    dlim = k + width; // past dest edge
+                }
+                int sx = i * iw; // start of line in source
+                while (dx < dlim) {
+                    // map color and insert in destination
+                    int index = ((int) pixels[sx++]) & 0xff;
+                    int c = act[index];
+                    if (c != 0) {
+                        dest[dx] = c;
+                    }
+                    dx++;
+                }
+            }
+        }
+        //rockchips zhongming modify for [Image Distortion]  2010-12-9
+        //image = Bitmap.createBitmap(dest, width, height, Config.ARGB_4444);
+        try{
+            image = Bitmap.createBitmap(dest, width, height, Config.ARGB_4444);
+        } catch(OutOfMemoryError e) {
+            System.gc();
+        }
+        //rockchips zhongming modify end
+        if(dest != null) {
+            dest = null;
+        }
+    }
+    /**
+     * Skips variable length blocks up to and including next zero length block.
+     */
+    private void skip() {
+        do {
+            readBlock();
+        } while ((blockSize > 0) && !err());
+    }
+}
diff --git a/src/com/android/gif/GifFrame.java b/src/com/android/gif/GifFrame.java
new file mode 100644
index 000000000..b13495971
--- /dev/null
+++ b/src/com/android/gif/GifFrame.java
@@ -0,0 +1,16 @@
+package com.android.gif;
+
+import android.graphics.Bitmap;
+
+public class GifFrame {
+    public GifFrame(Bitmap im, int del) {
+        image = im;
+        delay = del;
+    }
+
+    public Bitmap image;
+
+    public int delay;
+
+    public GifFrame nextFrame = null;
+}
diff --git a/src/com/android/gif/GifTextrue.java b/src/com/android/gif/GifTextrue.java
new file mode 100644
index 000000000..a2b9a4f32
--- /dev/null
+++ b/src/com/android/gif/GifTextrue.java
@@ -0,0 +1,210 @@
+/************************************************************
+ * Copyright ${year} Rockchip MID Comm Corp., Ltd.
+ * All rights reserved.
+ * FileName      : GifTexture.java
+ * Version Number : 1.0
+ * Description    : extends BasicTexture to support gif animation
+ * Author        : jyzheng
+ * Date          : 2012-02-25
+ * 
+ ************************************************************/
+package com.android.gif;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+
+import com.android.gallery3d.glrenderer.BitmapTexture;
+import com.android.gallery3d.ui.TileImageView;
+
+// TODO single instance
+
+public class GifTextrue{
+    /*
+     * rockchips jyzheng Add begin for [support uri gif] 2012-02-25
+     */
+    private final boolean DEBUG = true;
+    private void LOG(String str){
+        if(DEBUG){
+            Log.v(TAG, str);
+        }
+    }
+
+    public static boolean isGifStream(InputStream is) {
+        String id = "";
+        for (int i = 0; i < 6; i++) {
+            try {
+                id += (char) is.read();
+            } catch (IOException e) {
+
+                e.printStackTrace();
+                return false;
+            }catch(NullPointerException e){
+            //  e.printStackTrace();
+                return false;
+            }
+        }
+        return id.startsWith("GIF");
+
+    }
+
+    public InputStream getInputStream() {
+//      Log.v("GifTextrue", "=====================mFilePath:"+mFilePath);
+        try {
+            return new FileInputStream(new File(mFilePath));
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    /* rockchips jyzheng Add end */
+    private class GifHandler extends Handler {
+        private static final long MIN_DELAY = 50;
+        public static final int START = 0;
+        public static final int STOP = 2;
+        private static final int UPDATE = 1;
+        private GifDecoder mGifDecoder = null;
+
+        public GifHandler(Looper looper) {
+            super(looper);
+        }
+
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+            case START:
+                InputStream is = getInputStream();
+                if (is == null) {
+                    Log.e(TAG, "getInputStream returns null");
+                    break;
+                }
+                final boolean[] decodingOK = new boolean[] { true };
+                mGifDecoder = new GifDecoder(is, new GifAction() {
+                    public void parseOk(boolean parseStatus, int frameIndex) {
+                        if (!parseStatus) {
+                            Log.e(TAG, "parse gif with error");
+                            decodingOK[0] = false;
+                        }
+                    }
+                });
+                try{
+                   mGifDecoder.run();
+                }catch(OutOfMemoryError e){
+                    e.printStackTrace();
+                    System.gc();
+                }
+
+                if (decodingOK[0]) {
+                    sendEmptyMessage(UPDATE);
+                }
+
+                break;
+            case UPDATE:
+                GifDecoder decoder = mGifDecoder;
+                GifFrame frame = decoder.next();
+                if (frame != null && frame.image != null) {
+                    mBitmap = frame.image;
+                    long delay = MIN_DELAY;
+                    if (frame.delay > delay) {
+                        delay = frame.delay;
+                    }
+                    mTileImageView.invalidate();
+                    sendEmptyMessageDelayed(UPDATE, delay);
+                } else {
+                    sendEmptyMessageDelayed(UPDATE, MIN_DELAY);
+                }
+                break;
+            case STOP:
+                /** suppose start is called */
+                if(mGifDecoder != null){
+                   mGifDecoder.free();
+                }
+                mGifDecoder = null;
+                /** looper.quit will be called by thread.quit */
+                // this.getLooper().quit();
+                Runnable r = (Runnable) msg.obj;
+                r.run();
+                break;
+
+            }
+        }
+    }
+
+    /** enable this to dump all frames of gif to jpg files */
+
+    private static final String TAG = "GifTextrue";
+    private GifHandler mHandler;
+    private String mFilePath;
+
+    /** the animation will start when decoder is ready */
+
+    private HandlerThread mThread;
+    private TileImageView mTileImageView;
+    private Bitmap mBitmap;
+    private BitmapTexture mBitmapTexture = null;
+    public int mImageWidth = 0;
+    public int mImageHeight = 0;
+    
+    public BitmapTexture getBitmapTexture(){
+        if(mBitmapTexture == null || mBitmapTexture.getBitmap() != mBitmap){
+            if(mBitmap != null && !mBitmap.isRecycled()){
+               if(mBitmapTexture != null && mBitmapTexture.mBitmap != null){
+                   mBitmapTexture.mBitmap.recycle();
+                   mBitmapTexture.mBitmap= null;
+               }
+               if(mBitmapTexture != null){
+                  mBitmapTexture.recycle();
+               }
+               mBitmapTexture = null;
+               mBitmapTexture = new BitmapTexture(mBitmap);
+            }
+        }
+        return mBitmapTexture;
+    }
+
+    public GifTextrue(TileImageView t,Bitmap bitmap,String filePath) {
+        mTileImageView = t;
+        mBitmap = bitmap;
+        mFilePath = filePath;
+
+    }
+
+    public static String THREAD_NAME = "GifThead";
+
+    public void startAnimate() {
+        Log.i(TAG, "tryAnimate called for [" + this.mFilePath + "]");
+        if (mHandler == null) {
+            mThread = new HandlerThread("GifThead");
+
+            mThread.start();
+            mHandler = new GifHandler(mThread.getLooper());
+        }
+        mHandler.sendEmptyMessage(GifHandler.START);
+    }
+
+    public void stopAnimate() {
+        if (mHandler != null) {
+            Message msg = mHandler.obtainMessage(GifHandler.STOP);
+            final HandlerThread thread = mThread;
+            msg.obj = new Runnable() {
+                public void run() {
+                    thread.quit();
+                }
+            };
+            mHandler.sendMessage(msg);
+            mHandler = null;
+            mThread = null;
+        }
+    }
+
+}
diff --git a/src/com/android/gif/GifTextrueFactory.java b/src/com/android/gif/GifTextrueFactory.java
new file mode 100644
index 000000000..d61e30eb1
--- /dev/null
+++ b/src/com/android/gif/GifTextrueFactory.java
@@ -0,0 +1,53 @@
+/************************************************************
+ * Copyright ${year} Rockchip Mobile Comm Corp., Ltd.
+ * All rights reserved.
+ * FileName      : MediaItemTextureFactory.java
+ * Version Number : 1.0
+ * Description    : This factory can  return origin MediaItemTexture or
+ *                GifTexture
+ * Author        : caijq
+ * Date          : 2011-04-19
+ * History        :
+ * 
+ ************************************************************/
+package com.android.gif;
+
+import android.util.Log;
+
+public class GifTextrueFactory {
+    private static GifTextrue sActiveGif;
+    private static final String TAG = "GifTextrueFactory";
+    private static Object mLock = new Object();
+
+    public static void freezeAllGif() {
+        synchronized (mLock) {
+            if (sActiveGif != null) {
+                sActiveGif.stopAnimate();
+            }
+            sActiveGif = null;
+            Log.i(TAG, "freezeAllGif");
+        }
+
+    }
+
+    public static void startOnly(GifTextrue g) {
+        synchronized (mLock) {
+            if (g != sActiveGif) {
+                if (sActiveGif != null) {
+                    sActiveGif.stopAnimate();
+                }
+                g.startAnimate();
+                sActiveGif = g;
+
+            }
+            Log.i(TAG, "startOnly");
+        }
+
+    }
+
+    public static GifTextrue getGifTextrue() {
+        synchronized (mLock) {
+            return sActiveGif;
+        }
+    }
+}
diff --git a/src/com/android/gif/Shared.java b/src/com/android/gif/Shared.java
new file mode 100644
index 000000000..81a1922a5
--- /dev/null
+++ b/src/com/android/gif/Shared.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.gif;
+
+import android.graphics.Color;
+import android.media.ExifInterface;
+
+public final class Shared {
+    // Constants.
+    public static final int INVALID = -1;
+    public static final int INFINITY = Integer.MAX_VALUE;
+
+    public static int argb(float a, float r, float g, float b) {
+        return Color.argb((int) (a * 255f), (int) (r * 255f), (int) (g * 255f), (int) (b * 255f));
+    }
+
+    public static boolean isPowerOf2(int n) {
+        return (n & -n) == n;
+    }
+
+    /**
+     * @param i
+     *            : running variable
+     * @return 0, +1, -1, +2, -2, +3, -3 ..
+     */
+    public static int midPointIterator(int i) {
+        if (i != 0) {
+            int tick = ((i - 1) / 2) + 1;
+            int pass = ((i - 1) % 2 == 0) ? 1 : -1;
+            return tick * pass;
+        }
+        return 0;
+    }
+
+    public static int nextPowerOf2(int n) {
+        n -= 1;
+        n |= n >>> 16;
+        n |= n >>> 8;
+        n |= n >>> 4;
+        n |= n >>> 2;
+        n |= n >>> 1;
+        return n + 1;
+    }
+
+    public static int prevPowerOf2(int n) {
+        if (isPowerOf2(n)) {
+            return nextPowerOf2(n);
+        } else {
+            return nextPowerOf2(n) - 1;
+        }
+    }
+
+    public static int clamp(int value, int min, int max) {
+        if (value < min) {
+            value = min;
+        } else if (value > max) {
+            value = max;
+        }
+        return value;
+    }
+
+    public static long clamp(long value, long min, long max) {
+        if (value < min) {
+            value = min;
+        } else if (value > max) {
+            value = max;
+        }
+        return value;
+    }
+
+    public static float scaleToFit(float srcWidth, float srcHeight, float outerWidth, float outerHeight, boolean clipToFit) {
+        float scaleX = outerWidth / srcWidth;
+        float scaleY = outerHeight / srcHeight;
+        return (clipToFit ? scaleX > scaleY : scaleX < scaleY) ? scaleX : scaleY;
+    }
+
+    // Returns an angle between 0 and 360 degrees independent of the input
+    // angle.
+    public static float normalizePositive(float angleToRotate) {
+        if (angleToRotate == 0.0f) {
+            return 0.0f;
+        }
+        float nf = (angleToRotate / 360.0f);
+        int n = 0;
+        if (angleToRotate < 0) {
+            n = (int) (nf - 1.0f);
+        } else if (angleToRotate > 360) {
+            n = (int) (nf);
+        }
+        angleToRotate -= (n * 360.0f);
+        if (angleToRotate == 360.0f) {
+            angleToRotate = 0;
+        }
+        return angleToRotate;
+    }
+
+    public static int degreesToExifOrientation(float normalizedAngle) {
+        if (normalizedAngle == 0.0f) {
+            return ExifInterface.ORIENTATION_NORMAL;
+        } else if (normalizedAngle == 90.0f) {
+            return ExifInterface.ORIENTATION_ROTATE_90;
+        } else if (normalizedAngle == 180.0f) {
+            return ExifInterface.ORIENTATION_ROTATE_180;
+        } else if (normalizedAngle == 270.0f) {
+            return ExifInterface.ORIENTATION_ROTATE_270;
+        }
+        return ExifInterface.ORIENTATION_NORMAL;
+    }
+
+    public static float exifOrientationToDegrees(int exifOrientation) {
+        if (exifOrientation == ExifInterface.ORIENTATION_ROTATE_90) {
+            return 90;
+        } else if (exifOrientation == ExifInterface.ORIENTATION_ROTATE_180) {
+            return 180;
+        } else if (exifOrientation == ExifInterface.ORIENTATION_ROTATE_270) {
+            return 270;
+        }
+        return 0;
+    }
+}
-- 
2.35.1

