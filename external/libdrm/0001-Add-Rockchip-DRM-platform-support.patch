From 52f5035e0ddb834854c1f9b44f94727bd7360d34 Mon Sep 17 00:00:00 2001
From: Bian Jin chen <kenjc.bian@rock-chips.com>
Date: Thu, 30 Apr 2020 15:38:20 +0800
Subject: [PATCH 1/2] Add Rockchip DRM platform support.

Signed-off-by: Bian Jin chen <kenjc.bian@rock-chips.com>
Change-Id: Ia5cb4ad9f6fe13e2b80d13cf525490e36908bba7
---
 Makefile.am                    |    5 +
 configure.ac                   |   13 +
 include/drm/drm_fourcc.h       |    1 +
 rockchip/Android.bp            |   14 +
 rockchip/Makefile.am           |   21 +
 rockchip/libdrm_rockchip.pc.in |   11 +
 rockchip/rga_reg.h             |  474 ++++++++++++++
 rockchip/rockchip_drm.c        |  299 +++++++++
 rockchip/rockchip_drm.h        |  117 ++++
 rockchip/rockchip_drmif.h      |   79 +++
 rockchip/rockchip_rga.c        | 1084 ++++++++++++++++++++++++++++++++
 rockchip/rockchip_rga.h        |   87 +++
 tests/modetest/modetest.c      |    1 +
 xf86drmMode.c                  |   25 +
 xf86drmMode.h                  |    6 +
 15 files changed, 2237 insertions(+)
 create mode 100644 rockchip/Android.bp
 create mode 100644 rockchip/Makefile.am
 create mode 100644 rockchip/libdrm_rockchip.pc.in
 create mode 100644 rockchip/rga_reg.h
 create mode 100644 rockchip/rockchip_drm.c
 create mode 100644 rockchip/rockchip_drm.h
 create mode 100644 rockchip/rockchip_drmif.h
 create mode 100644 rockchip/rockchip_rga.c
 create mode 100644 rockchip/rockchip_rga.h

diff --git a/Makefile.am b/Makefile.am
index 730de1f2..4544fa07 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -90,6 +90,10 @@ if HAVE_ETNAVIV
 ETNAVIV_SUBDIR = etnaviv
 endif
 
+if HAVE_ROCKCHIP
+ROCKCHIP_SUBDIR = rockchip
+endif
+
 if BUILD_MANPAGES
 if HAVE_MANPAGES_STYLESHEET
 MAN_SUBDIR = man
@@ -109,6 +113,7 @@ SUBDIRS = \
 	$(TEGRA_SUBDIR) \
 	$(VC4_SUBDIR) \
 	$(ETNAVIV_SUBDIR) \
+	$(ROCKCHIP_SUBDIR) \
 	data \
 	tests \
 	$(MAN_SUBDIR)
diff --git a/configure.ac b/configure.ac
index 1cf91347..b9ffcbf1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -148,6 +148,11 @@ AC_ARG_ENABLE(tegra-experimental-api,
 	      [Enable support for Tegra's experimental API (default: disabled)]),
 	      [TEGRA=$enableval], [TEGRA=no])
 
+AC_ARG_ENABLE(rockchip-experimental-api,
+	      AS_HELP_STRING([--enable-rockchip-experimental-api],
+	      [Enable support for rockchip's experimental API (default: disabled)]),
+	      [ROCKCHIP=$enableval], [ROCKCHIP=no])
+
 AC_ARG_ENABLE(vc4,
 	      AS_HELP_STRING([--disable-vc4],
 	      [Enable support for vc4's API (default: auto, enabled on arm)]),
@@ -455,6 +460,11 @@ else
 	AC_DEFINE(HAVE_VC4, 0)
 fi
 
+AM_CONDITIONAL(HAVE_ROCKCHIP, [test "x$ROCKCHIP" = xyes])
+if test "x$ROCKCHIP" = xyes; then
+	AC_DEFINE(HAVE_ROCKCHIP, 1, [Have ROCKCHIP support])
+fi
+
 AM_CONDITIONAL(HAVE_ETNAVIV, [test "x$ETNAVIV" = xyes])
 
 AM_CONDITIONAL(HAVE_INSTALL_TESTS, [test "x$INSTALL_TESTS" = xyes])
@@ -569,6 +579,8 @@ AC_CONFIG_FILES([
 	vc4/libdrm_vc4.pc
 	etnaviv/Makefile
 	etnaviv/libdrm_etnaviv.pc
+	rockchip/Makefile
+	rockchip/libdrm_rockchip.pc
 	tests/Makefile
 	tests/modeprint/Makefile
 	tests/modetest/Makefile
@@ -602,4 +614,5 @@ echo "  Freedreno API  $FREEDRENO (kgsl: $FREEDRENO_KGSL)"
 echo "  Tegra API      $TEGRA"
 echo "  VC4 API        $VC4"
 echo "  Etnaviv API    $ETNAVIV"
+echo "  Rockchip API   $ROCKCHIP"
 echo ""
diff --git a/include/drm/drm_fourcc.h b/include/drm/drm_fourcc.h
index 5c69090d..6f9698c2 100644
--- a/include/drm/drm_fourcc.h
+++ b/include/drm/drm_fourcc.h
@@ -231,6 +231,7 @@ extern "C" {
  * index 1 = Cb:Cr plane, [15:0] Cb:Cr little endian
  */
 #define DRM_FORMAT_NV12		fourcc_code('N', 'V', '1', '2') /* 2x2 subsampled Cr:Cb plane */
+#define DRM_FORMAT_NV12_10	fourcc_code('N', 'A', '1', '2') /* 2x2 subsampled Cr:Cb plane */
 #define DRM_FORMAT_NV21		fourcc_code('N', 'V', '2', '1') /* 2x2 subsampled Cb:Cr plane */
 #define DRM_FORMAT_NV16		fourcc_code('N', 'V', '1', '6') /* 2x1 subsampled Cr:Cb plane */
 #define DRM_FORMAT_NV61		fourcc_code('N', 'V', '6', '1') /* 2x1 subsampled Cb:Cr plane */
diff --git a/rockchip/Android.bp b/rockchip/Android.bp
new file mode 100644
index 00000000..854da3a6
--- /dev/null
+++ b/rockchip/Android.bp
@@ -0,0 +1,14 @@
+cc_library_shared {
+    name: "libdrm_rockchip",
+    vendor: true,
+    shared_libs: ["libdrm"],
+
+    srcs: ["rockchip_drm.c"],
+
+    cflags: [
+        "-DHAVE_LIBDRM_ATOMIC_PRIMITIVES=1",
+        "-Wall",
+        "-Werror",
+    ],
+}
+
diff --git a/rockchip/Makefile.am b/rockchip/Makefile.am
new file mode 100644
index 00000000..c722b31a
--- /dev/null
+++ b/rockchip/Makefile.am
@@ -0,0 +1,21 @@
+AM_CFLAGS = \
+	$(WARN_CFLAGS) \
+	-I$(top_srcdir) \
+	-I$(top_srcdir)/rockchip \
+	$(PTHREADSTUBS_CFLAGS) \
+	-I$(top_srcdir)/include/drm
+
+libdrm_rockchip_la_LTLIBRARIES = libdrm_rockchip.la
+libdrm_rockchip_ladir = $(libdir)
+libdrm_rockchip_la_LDFLAGS = -version-number 1:0:0 -no-undefined
+libdrm_rockchip_la_LIBADD = ../libdrm.la @PTHREADSTUBS_LIBS@
+
+libdrm_rockchip_la_SOURCES = \
+	rockchip_drm.c \
+	rockchip_rga.c
+
+libdrm_rockchipincludedir = ${includedir}/libdrm
+libdrm_rockchipinclude_HEADERS = rockchip_drmif.h rockchip_drm.h rockchip_rga.h
+
+pkgconfigdir = @pkgconfigdir@
+pkgconfig_DATA = libdrm_rockchip.pc
diff --git a/rockchip/libdrm_rockchip.pc.in b/rockchip/libdrm_rockchip.pc.in
new file mode 100644
index 00000000..13f22ac7
--- /dev/null
+++ b/rockchip/libdrm_rockchip.pc.in
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libdrm_rockchip
+Description: Userspace interface to rockchip kernel DRM services
+Version: 0.1
+Libs: -L${libdir} -ldrm_rockchip
+Cflags: -I${includedir} -I${includedir}/libdrm
+Requires.private: libdrm
diff --git a/rockchip/rga_reg.h b/rockchip/rga_reg.h
new file mode 100644
index 00000000..34c9bfd6
--- /dev/null
+++ b/rockchip/rga_reg.h
@@ -0,0 +1,474 @@
+/*
+ * Copyright (C) 2016 Fuzhou Electronics Co.Ltd
+ * Authors:
+ *	Yakir Yang <ykk@rock-chips.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _RGA_REG_H_
+#define _RGA_REG_H_
+
+#define MODE_CTRL			0x0100
+#define SRC_INFO			0x0104
+#define SRC_Y_RGB_BASE_ADDR		0x0108
+#define SRC_CB_BASE_ADDR		0x010c
+#define SRC_CR_BASE_ADDR		0x0110
+#define SRC1_RGB_BASE_ADDR		0x0114
+#define SRC_VIR_INFO			0x0118
+#define SRC_ACT_INFO			0x011c
+#define SRC_X_FACTOR			0x0120
+#define SRC_Y_FACTOR			0x0124
+#define SRC_BG_COLOR			0x0128
+#define SRC_FG_COLOR			0x012c
+#define SRC_TR_COLOR0			0x0130
+#define SRC_TR_COLOR1			0x0134
+
+#define DST_INFO			0x0138
+#define DST_Y_RGB_BASE_ADDR		0x013c
+#define DST_CB_BASE_ADDR		0x0140
+#define DST_CR_BASE_ADDR		0x0144
+#define DST_VIR_INFO			0x0148
+#define DST_ACT_INFO			0x014c
+
+#define ALPHA_CTRL0			0x0150
+#define ALPHA_CTRL1			0x0154
+#define FADING_CTRL			0x0158
+#define PAT_CON				0x015c
+#define ROP_CON0			0x0160
+#define ROP_CON1			0x0164
+#define MASK_BASE			0x0168
+
+#define MMU_CTRL1			0x016c
+#define MMU_SRC_BASE			0x0170
+#define MMU_SRC1_BASE			0x0174
+#define MMU_DST_BASE			0x0178
+#define MMU_ELS_BASE			0x017c
+
+enum e_rga_render_mode {
+	RGA_MODE_RENDER_BITBLT = 0,
+	RGA_MODE_RENDER_COLOR_PALETTE = 1,
+	RGA_MODE_RENDER_RECTANGLE_FILL = 2,
+	RGA_MODE_RENDER_UPDATE_PALETTE_LUT_RAM = 3,
+};
+
+enum e_rga_bitblt_mode {
+	RGA_MODE_BITBLT_MODE_SRC_TO_DST = 0,
+	RGA_MODE_BITBLT_MODE_SRC_SRC1_TO_DST = 1,
+};
+
+enum e_rga_cf_rop4_pat {
+	RGA_MODE_CF_ROP4_SOLID = 0,
+	RGA_MODE_CF_ROP4_PATTERN = 1,
+};
+
+enum e_rga_src_color_format {
+	RGA_SRC_COLOR_FMT_ABGR8888 = 0,
+	RGA_SRC_COLOR_FMT_XBGR8888 = 1,
+	RGA_SRC_COLOR_FMT_RGB888 = 2,
+	RGA_SRC_COLOR_FMT_RGB565 = 4,
+	RGA_SRC_COLOR_FMT_ARGB1555 = 5,
+	RGA_SRC_COLOR_FMT_ARGB4444 = 6,
+	RGA_SRC_COLOR_FMT_YUV422SP = 8,
+	RGA_SRC_COLOR_FMT_YUV422P = 9,
+	RGA_SRC_COLOR_FMT_YUV420SP = 10,
+	RGA_SRC_COLOR_FMT_YUV420P = 11,
+	/* SRC_COLOR Palette */
+	RGA_SRC_COLOR_FMT_CP_1BPP = 12,
+	RGA_SRC_COLOR_FMT_CP_2BPP = 13,
+	RGA_SRC_COLOR_FMT_CP_4BPP = 14,
+	RGA_SRC_COLOR_FMT_CP_8BPP = 15,
+	RGA_SRC_COLOR_FMT_MASK = 15,
+};
+
+enum e_rga_src_color_swap {
+	RGA_SRC_COLOR_RB_SWAP = 1,
+	RGA_SRC_COLOR_ALPHA_SWAP = 2,
+	RGA_SRC_COLOR_UV_SWAP = 4,
+};
+
+enum e_rga_src_csc_mode {
+	RGA_SRC_CSC_MODE_BT601_R0 = 0,
+	RGA_SRC_CSC_MODE_BT601_R1 = 1,
+	RGA_SRC_CSC_MODE_BT709_R0 = 2,
+	RGA_SRC_CSC_MODE_BT709_R1 = 3,
+	/*
+	RGA_SRC_CSC_MODE_BYPASS = 0,
+	RGA_SRC_CSC_MODE_BT601_R0 = 1,
+	RGA_SRC_CSC_MODE_BT601_R1 = 2,
+	RGA_SRC_CSC_MODE_BT709_R0 = 3,
+	*/
+};
+
+enum e_rga_src_rot_mode {
+	RGA_SRC_ROT_MODE_0_DEGREE = 0,
+	RGA_SRC_ROT_MODE_90_DEGREE = 1,
+	RGA_SRC_ROT_MODE_180_DEGREE = 2,
+	RGA_SRC_ROT_MODE_270_DEGREE = 3,
+};
+
+enum e_rga_src_mirr_mode {
+	RGA_SRC_MIRR_MODE_NO = 0,
+	RGA_SRC_MIRR_MODE_X = 1,
+	RGA_SRC_MIRR_MODE_Y = 2,
+	RGA_SRC_MIRR_MODE_X_Y = 3,
+};
+
+enum e_rga_src_hscl_mode {
+	RGA_SRC_HSCL_MODE_NO = 0,
+	RGA_SRC_HSCL_MODE_DOWN = 1,
+	RGA_SRC_HSCL_MODE_UP = 2,
+};
+
+enum e_rga_src_vscl_mode {
+	RGA_SRC_VSCL_MODE_NO = 0,
+	RGA_SRC_VSCL_MODE_DOWN = 1,
+	RGA_SRC_VSCL_MODE_UP = 2,
+};
+
+enum e_rga_src_trans_enable {
+	RGA_SRC_TRANS_ENABLE_R = 1,
+	RGA_SRC_TRANS_ENABLE_G = 2,
+	RGA_SRC_TRANS_ENABLE_B = 4,
+	RGA_SRC_TRANS_ENABLE_A = 8,
+};
+
+enum e_rga_src_bic_coe_select {
+	RGA_SRC_BIC_COE_SELEC_CATROM = 0,
+	RGA_SRC_BIC_COE_SELEC_MITCHELL = 1,
+	RGA_SRC_BIC_COE_SELEC_HERMITE = 2,
+	RGA_SRC_BIC_COE_SELEC_BSPLINE = 3,
+};
+
+enum e_rga_src_yuv_ten_enable {
+	RGA_SRC_YUV_TEN_DISABLE = 0,
+	RGA_SRC_YUV_TEN_ENABLE = 1,
+};
+
+enum e_rga_src_yuv_ten_round_enable {
+	RGA_SRC_YUV_TEN_ROUND_DISABLE = 0,
+	RGA_SRC_YUV_TEN_ROUND_ENABLE = 1,
+};
+
+enum e_rga_dst_color_format {
+	RGA_DST_COLOR_FMT_ABGR888 = 0,
+	RGA_DST_COLOR_FMT_XBGR888 = 1,
+	RGA_DST_COLOR_FMT_RGB888 = 2,
+	RGA_DST_COLOR_FMT_RGB565 = 4,
+	RGA_DST_COLOR_FMT_ARGB1555 = 5,
+	RGA_DST_COLOR_FMT_ARGB4444 = 6,
+	RGA_DST_COLOR_FMT_YUV422SP = 8,
+	RGA_DST_COLOR_FMT_YUV422P = 9,
+	RGA_DST_COLOR_FMT_YUV420SP = 10,
+	RGA_DST_COLOR_FMT_YUV420P = 11,
+	RGA_DST_COLOR_FMT_MASK = 11,
+};
+
+enum e_rga_dst_color_swap {
+	RGA_DST_COLOR_RB_SWAP = 1,
+	RGA_DST_COLOR_ALPHA_SWAP = 2,
+	RGA_DST_COLOR_UV_SWAP = 4,
+};
+
+enum e_rga_src1_color_format {
+	RGA_SRC1_COLOR_FMT_ABGR888 = 0,
+	RGA_SRC1_COLOR_FMT_XBGR888 = 1,
+	RGA_SRC1_COLOR_FMT_RGB888 = 2,
+	RGA_SRC1_COLOR_FMT_RGB565 = 4,
+	RGA_SRC1_COLOR_FMT_ARGB1555 = 5,
+	RGA_SRC1_COLOR_FMT_ARGB4444 = 6,
+	RGA_SRC1_COLOR_FMT_MASK	 = 6,
+};
+
+enum e_rga_src1_color_swap {
+	RGA_SRC1_COLOR_RB_SWAP = 1,
+	RGA_SRC1_COLOR_ALPHA_SWAP = 2,
+};
+
+enum e_rga_dst_dither_down_mode {
+	RGA_DST_DITHER_MODE_888_TO_666 = 0,
+	RGA_DST_DITHER_MODE_888_TO_565 = 1,
+	RGA_DST_DITHER_MODE_888_TO_555 = 2,
+	RGA_DST_DITHER_MODE_888_TO_444 = 3,
+};
+
+enum e_rga_dst_csc_mode {
+	RGA_DST_CSC_MODE_BYPASS = 0,
+	RGA_DST_CSC_MODE_BT601_R0 = 1,
+	RGA_DST_CSC_MODE_BT601_R1 = 2,
+	RGA_DST_CSC_MODE_BT709_R0 = 3,
+};
+
+enum e_rga_alpha_rop_mode {
+	RGA_ALPHA_ROP_MODE_2 = 0,
+	RGA_ALPHA_ROP_MODE_3 = 1,
+	RGA_ALPHA_ROP_MODE_4 = 2,
+};
+
+enum e_rga_alpha_rop_select {
+	RGA_ALPHA_SELECT_ALPHA = 0,
+	RGA_ALPHA_SELECT_ROP = 1,
+};
+
+
+union rga_mode_ctrl {
+	unsigned int val;
+	struct {
+		/* [0:2] */
+		enum e_rga_render_mode	render:3;
+		/* [3:6] */
+		enum e_rga_bitblt_mode	bitblt:1;
+		enum e_rga_cf_rop4_pat	cf_rop4_pat:1;
+		unsigned int		alpha_zero_key:1;
+		unsigned int		gradient_sat:1;
+		/* [7:31] */
+		unsigned int		reserved:25;
+	} data;
+};
+
+union rga_src_info {
+	unsigned int val;
+	struct {
+		/* [0:3] */
+		enum e_rga_src_color_format		format:4;
+		/* [4:7] */
+		enum e_rga_src_color_swap		swap:3;
+		unsigned int				cp_endian:1;
+		/* [8:17] */
+		enum e_rga_src_csc_mode			csc_mode:2;
+		enum e_rga_src_rot_mode			rot_mode:2;
+		enum e_rga_src_mirr_mode		mir_mode:2;
+		enum e_rga_src_hscl_mode		hscl_mode:2;
+		enum e_rga_src_vscl_mode		vscl_mode:2;
+		/* [18:22] */
+		unsigned int				trans_mode:1;
+		enum e_rga_src_trans_enable		trans_enable:4;
+		/* [23:25] */
+		unsigned int				dither_up_en:1;
+		enum e_rga_src_bic_coe_select		bic_coe_sel:2;
+		/* [26] */
+		unsigned int				reserved:1;
+		/* [27:28] */
+		enum e_rga_src_yuv_ten_enable		yuv_ten_en:1;
+		enum e_rga_src_yuv_ten_round_enable	yuv_ten_round_en:1;
+		/* [29:31]*/
+		unsigned int				reserved1:3;
+	} data;
+};
+
+union rga_src_vir_info {
+	unsigned int val;
+	struct {
+		/* [0:15] */
+		unsigned int	vir_width:15;
+		unsigned int	reserved:1;
+		/* [16:25] */
+		unsigned int	vir_stride:10;
+		/* [26:31] */
+		unsigned int	reserved1:6;
+	} data;
+};
+
+union rga_src_act_info {
+	unsigned int val;
+	struct {
+		/* [0:15] */
+		unsigned int	act_width:13;
+		unsigned int	reserved:3;
+		/* [16:31] */
+		unsigned int	act_height:13;
+		unsigned int	reserved1:3;
+	} data;
+};
+
+union rga_src_x_factor {
+	unsigned int val;
+	struct {
+		/* [0:15] */
+		unsigned int	down_scale_factor:16;
+		/* [16:31] */
+		unsigned int	up_scale_factor:16;
+	} data;
+};
+
+union rga_src_y_factor {
+	unsigned int val;
+	struct {
+		/* [0:15] */
+		unsigned int	down_scale_factor:16;
+		/* [16:31] */
+		unsigned int	up_scale_factor:16;
+	} data;
+};
+
+/* Alpha / Red / Green / Blue */
+union rga_src_cp_gr_color {
+	unsigned int val;
+	struct {
+		/* [0:15] */
+		unsigned int	gradient_x:16;
+		/* [16:31] */
+		unsigned int	gradient_y:16;
+	} data;
+};
+
+union rga_src_transparency_color0 {
+	unsigned int val;
+	struct {
+		/* [0:7] */
+		unsigned int	trans_rmin:8;
+		/* [8:15] */
+		unsigned int	trans_gmin:8;
+		/* [16:23] */
+		unsigned int	trans_bmin:8;
+		/* [24:31] */
+		unsigned int	trans_amin:8;
+	} data;
+};
+
+union rga_src_transparency_color1 {
+	unsigned int val;
+	struct {
+		/* [0:7] */
+		unsigned int	trans_rmax:8;
+		/* [8:15] */
+		unsigned int	trans_gmax:8;
+		/* [16:23] */
+		unsigned int	trans_bmax:8;
+		/* [24:31] */
+		unsigned int	trans_amax:8;
+	} data;
+};
+
+union rga_dst_info {
+	unsigned int val;
+	struct {
+		/* [0:3] */
+		enum e_rga_dst_color_format	format:4;
+		/* [4:6] */
+		enum e_rga_dst_color_swap	swap:3;
+		/* [7:9] */
+		enum e_rga_src1_color_format	src1_format:3;
+		/* [10:11] */
+		enum e_rga_src1_color_swap	src1_swap:2;
+		/* [12:15] */
+		unsigned int			dither_up_en:1;
+		unsigned int			dither_down_en:1;
+		enum e_rga_dst_dither_down_mode	dither_down_mode:2;
+		/* [16:18] */
+		enum e_rga_dst_csc_mode		csc_mode:2;
+		unsigned int			csc_clip:1;
+		/* [19:31] */
+		unsigned int			reserved:13;
+	} data;
+};
+
+union rga_dst_vir_info {
+	unsigned int val;
+	struct {
+		/* [0:15] */
+		unsigned int	vir_stride:15;
+		unsigned int	reserved:1;
+		/* [16:31] */
+		unsigned int	src1_vir_stride:15;
+		unsigned int	reserved1:1;
+	} data;
+};
+
+union rga_dst_act_info {
+	unsigned int val;
+	struct {
+		/* [0:15] */
+		unsigned int	act_width:12;
+		unsigned int	reserved:4;
+		/* [16:31] */
+		unsigned int	act_height:12;
+		unsigned int	reserved1:4;
+	} data;
+};
+
+union rga_alpha_ctrl0 {
+	unsigned int val;
+	struct {
+		/* [0:3] */
+		unsigned int			rop_en:1;
+		enum e_rga_alpha_rop_select	rop_select:1;
+		enum e_rga_alpha_rop_mode	rop_mode:2;
+		/* [4:11] */
+		unsigned int			src_fading_val:8;
+		/* [12:20] */
+		unsigned int			dst_fading_val:8;
+		unsigned int			mask_endian:1;
+		/* [21:31] */
+		unsigned int			reserved:11;
+	} data;
+};
+
+union rga_alpha_ctrl1 {
+	unsigned int val;
+	struct {
+		/* [0:1] */
+		unsigned int	dst_color_m0:1;
+		unsigned int	src_color_m0:1;
+		/* [2:7] */
+		unsigned int	dst_factor_m0:3;
+		unsigned int	src_factor_m0:3;
+		/* [8:9] */
+		unsigned int	dst_alpha_cal_m0:1;
+		unsigned int	src_alpha_cal_m0:1;
+		/* [10:13] */
+		unsigned int	dst_blend_m0:2;
+		unsigned int	src_blend_m0:2;
+		/* [14:15] */
+		unsigned int	dst_alpha_m0:1;
+		unsigned int	src_alpha_m0:1;
+		/* [16:21] */
+		unsigned int	dst_factor_m1:3;
+		unsigned int	src_factor_m1:3;
+		/* [22:23] */
+		unsigned int	dst_alpha_cal_m1:1;
+		unsigned int	src_alpha_cal_m1:1;
+		/* [24:27] */
+		unsigned int	dst_blend_m1:2;
+		unsigned int	src_blend_m1:2;
+		/* [28:29] */
+		unsigned int	dst_alpha_m1:1;
+		unsigned int	src_alpha_m1:1;
+		/* [30:31] */
+		unsigned int	reserved:2;
+	} data;
+};
+
+union rga_fading_ctrl {
+	unsigned int val;
+	struct {
+		/* [0:7] */
+		unsigned int	fading_offset_r:8;
+		/* [8:15] */
+		unsigned int	fading_offset_g:8;
+		/* [16:23] */
+		unsigned int	fading_offset_b:8;
+		/* [24:31] */
+		unsigned int	fading_en:1;
+		unsigned int	reserved:7;
+	} data;
+};
+
+union rga_pat_con {
+	unsigned int val;
+	struct {
+		/* [0:7] */
+		unsigned int	width:8;
+		/* [8:15] */
+		unsigned int	height:8;
+		/* [16:23] */
+		unsigned int	offset_x:8;
+		/* [24:31] */
+		unsigned int	offset_y:8;
+	} data;
+};
+#endif
diff --git a/rockchip/rockchip_drm.c b/rockchip/rockchip_drm.c
new file mode 100644
index 00000000..ad878bad
--- /dev/null
+++ b/rockchip/rockchip_drm.c
@@ -0,0 +1,299 @@
+/*
+ * Copyright (C) ROCKCHIP, Inc.
+ * Author:yzq<yzq@rock-chips.com>
+ *
+ * based on exynos_drm.c
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+
+#include <sys/mman.h>
+#include <linux/stddef.h>
+
+#include <xf86drm.h>
+
+#include "rockchip_drm.h"
+#include "rockchip_drmif.h"
+
+/*
+ * Create rockchip drm device object.
+ *
+ * @fd: file descriptor to rockchip drm driver opened.
+ *
+ * if true, return the device object else NULL.
+ */
+struct rockchip_device *rockchip_device_create(int fd)
+{
+	struct rockchip_device *dev;
+
+	dev = calloc(1, sizeof(*dev));
+	if (!dev) {
+		fprintf(stderr, "failed to create device[%s].\n",
+				strerror(errno));
+		return NULL;
+	}
+
+	dev->fd = fd;
+
+	return dev;
+}
+
+/*
+ * Destroy rockchip drm device object
+ *
+ * @dev: rockchip drm device object.
+ */
+void rockchip_device_destroy(struct rockchip_device *dev)
+{
+	free(dev);
+}
+
+/*
+ * Create a rockchip buffer object to rockchip drm device.
+ *
+ * @dev: rockchip drm device object.
+ * @size: user-desired size.
+ * flags: user-desired memory type.
+ *	user can set one or more types among several types to memory
+ *	allocation and cache attribute types. and as default,
+ *	ROCKCHIP_BO_NONCONTIG and ROCKCHIP-BO_NONCACHABLE types would
+ *	be used.
+ *
+ * if true, return a rockchip buffer object else NULL.
+ */
+struct rockchip_bo *rockchip_bo_create(struct rockchip_device *dev,
+					size_t size, uint32_t flags)
+{
+	struct rockchip_bo *bo;
+	struct drm_rockchip_gem_create req = {
+		.size = size,
+		.flags = flags,
+	};
+
+	if (size == 0) {
+		fprintf(stderr, "invalid size.\n");
+		return NULL;
+	}
+
+	bo = calloc(1, sizeof(*bo));
+	if (!bo) {
+		fprintf(stderr, "failed to create bo[%s].\n",
+				strerror(errno));
+		goto fail;
+	}
+
+	bo->dev = dev;
+
+	if (drmIoctl(dev->fd, DRM_IOCTL_ROCKCHIP_GEM_CREATE, &req)){
+		fprintf(stderr, "failed to create gem object[%s].\n",
+				strerror(errno));
+		goto err_free_bo;
+	}
+
+	bo->handle = req.handle;
+	bo->size = size;
+	bo->flags = flags;
+
+	return bo;
+
+err_free_bo:
+	free(bo);
+fail:
+	return NULL;
+}
+
+struct rockchip_bo *rockchip_bo_from_handle(struct rockchip_device *dev,
+			uint32_t handle, uint32_t flags, uint32_t size)
+{
+	struct rockchip_bo *bo;
+
+	if (size == 0) {
+		fprintf(stderr, "invalid size.\n");
+		return NULL;
+	}
+
+	bo = calloc(1, sizeof(*bo));
+	if (!bo) {
+		fprintf(stderr, "failed to create bo[%s].\n",
+				strerror(errno));
+		return NULL;
+	}
+
+	bo->dev = dev;
+	bo->handle = handle;
+	bo->size = size;
+	bo->flags = flags;
+
+	return bo;
+}
+
+/*
+ * Destroy a rockchip buffer object.
+ *
+ * @bo: a rockchip buffer object to be destroyed.
+ */
+void rockchip_bo_destroy(struct rockchip_bo *bo)
+{
+	if (!bo)
+		return;
+
+	if (bo->vaddr)
+		munmap(bo->vaddr, bo->size);
+
+	if (bo->handle) {
+		struct drm_gem_close req = {
+			.handle = bo->handle,
+		};
+
+		drmIoctl(bo->dev->fd, DRM_IOCTL_GEM_CLOSE, &req);
+	}
+
+	free(bo);
+}
+
+
+/*
+ * Get a rockchip buffer object from a gem global object name.
+ *
+ * @dev: a rockchip device object.
+ * @name: a gem global object name exported by another process.
+ *
+ * this interface is used to get a rockchip buffer object from a gem
+ * global object name sent by another process for buffer sharing.
+ *
+ * if true, return a rockchip buffer object else NULL.
+ *
+ */
+struct rockchip_bo *rockchip_bo_from_name(struct rockchip_device *dev,
+						uint32_t name)
+{
+	struct rockchip_bo *bo;
+	struct drm_gem_open req = {
+		.name = name,
+	};
+
+	bo = calloc(1, sizeof(*bo));
+	if (!bo) {
+		fprintf(stderr, "failed to allocate bo[%s].\n",
+				strerror(errno));
+		return NULL;
+	}
+
+	if (drmIoctl(dev->fd, DRM_IOCTL_GEM_OPEN, &req)) {
+		fprintf(stderr, "failed to open gem object[%s].\n",
+				strerror(errno));
+		goto err_free_bo;
+	}
+
+	bo->dev = dev;
+	bo->name = name;
+	bo->handle = req.handle;
+
+	return bo;
+
+err_free_bo:
+	free(bo);
+	return NULL;
+}
+
+/*
+ * Get a gem global object name from a gem object handle.
+ *
+ * @bo: a rockchip buffer object including gem handle.
+ * @name: a gem global object name to be got by kernel driver.
+ *
+ * this interface is used to get a gem global object name from a gem object
+ * handle to a buffer that wants to share it with another process.
+ *
+ * if true, return 0 else negative.
+ */
+int rockchip_bo_get_name(struct rockchip_bo *bo, uint32_t *name)
+{
+	if (!bo->name) {
+		struct drm_gem_flink req = {
+			.handle = bo->handle,
+		};
+		int ret;
+
+		ret = drmIoctl(bo->dev->fd, DRM_IOCTL_GEM_FLINK, &req);
+		if (ret) {
+			fprintf(stderr, "failed to get gem global name[%s].\n",
+					strerror(errno));
+			return ret;
+		}
+
+		bo->name = req.name;
+	}
+
+	*name = bo->name;
+
+	return 0;
+}
+
+uint32_t rockchip_bo_handle(struct rockchip_bo *bo)
+{
+	return bo->handle;
+}
+
+/*
+ * Mmap a buffer to user space.
+ *
+ * @bo: a rockchip buffer object including a gem object handle to be mmapped
+ *	to user space.
+ *
+ * if true, user pointer mmaped else NULL.
+ */
+void *rockchip_bo_map(struct rockchip_bo *bo)
+{
+	if (!bo->vaddr) {
+		struct rockchip_device *dev = bo->dev;
+		struct drm_rockchip_gem_map_off req = {
+			.handle = bo->handle,
+		};
+		int ret;
+
+		ret = drmIoctl(dev->fd, DRM_IOCTL_ROCKCHIP_GEM_MAP_OFFSET, &req);
+		if (ret) {
+			fprintf(stderr, "failed to ioctl gem map offset[%s].\n",
+				strerror(errno));
+			return NULL;
+		}
+
+		bo->vaddr = mmap64(0, bo->size, PROT_READ | PROT_WRITE,
+			   MAP_SHARED, dev->fd, req.offset);
+		if (bo->vaddr == MAP_FAILED) {
+			fprintf(stderr, "failed to mmap buffer[%s].\n",
+				strerror(errno));
+			return NULL;
+		}
+	}
+
+	return bo->vaddr;
+}
diff --git a/rockchip/rockchip_drm.h b/rockchip/rockchip_drm.h
new file mode 100644
index 00000000..7b29d917
--- /dev/null
+++ b/rockchip/rockchip_drm.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) Fuzhou Rockchip Electronics Co.Ltd
+ * Authors:
+ *       Mark Yao <yzq@rock-chips.com>
+ *
+ * based on exynos_drm.h
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#ifndef _ROCKCHIP_DRM_H_
+#define _ROCKCHIP_DRM_H_
+
+#include <stdint.h>
+#include "drm.h"
+
+/**
+ * User-desired buffer creation information structure.
+ *
+ * @size: user-desired memory allocation size.
+ *	- this size value would be page-aligned internally.
+ * @flags: user request for setting memory type or cache attributes.
+ * @handle: returned a handle to created gem object.
+ *	- this handle will be set by gem module of kernel side.
+ */
+struct drm_rockchip_gem_create {
+	uint64_t size;
+	uint32_t flags;
+	uint32_t handle;
+};
+
+/**
+ * A structure for getting buffer offset.
+ *
+ * @handle: a pointer to gem object created.
+ * @pad: just padding to be 64-bit aligned.
+ * @offset: relatived offset value of the memory region allocated.
+ *	- this value should be set by user.
+ */
+struct drm_rockchip_gem_map_off {
+	uint32_t handle;
+	uint32_t pad;
+	uint64_t offset;
+};
+
+struct drm_rockchip_rga_get_ver {
+	__u32   major;
+	__u32   minor;
+};
+
+struct drm_rockchip_rga_cmd {
+	__u32   offset;
+	__u32   data;
+};
+
+enum drm_rockchip_rga_buf_type {
+	RGA_BUF_TYPE_USERPTR = 1 << 31,
+	RGA_BUF_TYPE_GEMFD   = 1 << 30,
+};
+
+struct drm_rockchip_rga_userptr {
+	unsigned long userptr;
+	unsigned long size;
+};
+
+struct drm_rockchip_rga_set_cmdlist {
+	__u64		cmd;
+	__u64		cmd_buf;
+	__u32		cmd_nr;
+	__u32		cmd_buf_nr;
+	__u64		user_data;
+};
+
+struct drm_rockchip_rga_exec {
+	__u64		async;
+};
+
+#define DRM_ROCKCHIP_GEM_CREATE	0x00
+#define DRM_ROCKCHIP_GEM_MAP_OFFSET	0x01
+#define DRM_ROCKCHIP_RGA_GET_VER		0x20
+#define DRM_ROCKCHIP_RGA_SET_CMDLIST		0x21
+#define DRM_ROCKCHIP_RGA_EXEC			0x22
+
+#define DRM_IOCTL_ROCKCHIP_RGA_GET_VER		DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_RGA_GET_VER, struct drm_rockchip_rga_get_ver)
+
+#define DRM_IOCTL_ROCKCHIP_RGA_SET_CMDLIST	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_RGA_SET_CMDLIST, struct drm_rockchip_rga_set_cmdlist)
+
+#define DRM_IOCTL_ROCKCHIP_RGA_EXEC		DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_RGA_EXEC, struct drm_rockchip_rga_exec)
+
+#define DRM_IOCTL_ROCKCHIP_GEM_CREATE		DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_GEM_CREATE, struct drm_rockchip_gem_create)
+
+#define DRM_IOCTL_ROCKCHIP_GEM_MAP_OFFSET	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_GEM_MAP_OFFSET, struct drm_rockchip_gem_map_off)
+
+#endif
diff --git a/rockchip/rockchip_drmif.h b/rockchip/rockchip_drmif.h
new file mode 100644
index 00000000..5c549a05
--- /dev/null
+++ b/rockchip/rockchip_drmif.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) ROCKCHIP, Inc.
+ * Author:yzq<yzq@rock-chips.com>
+ *
+ * based on exynos_drmif.h
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#ifndef ROCKCHIP_DRMIF_H_
+#define ROCKCHIP_DRMIF_H_
+
+#include <xf86drm.h>
+#include <stdint.h>
+#include "rockchip_drm.h"
+
+struct rockchip_device {
+	int fd;
+};
+
+/*
+ * Rockchip Buffer Object structure.
+ *
+ * @dev: rockchip device object allocated.
+ * @handle: a gem handle to gem object created.
+ * @flags: indicate memory allocation and cache attribute types.
+ * @size: size to the buffer created.
+ * @vaddr: user space address to a gem buffer mmaped.
+ * @name: a gem global handle from flink request.
+ */
+struct rockchip_bo {
+	struct rockchip_device	*dev;
+	uint32_t		handle;
+	uint32_t		flags;
+	size_t			size;
+	void			*vaddr;
+	uint32_t		name;
+};
+
+/*
+ * device related functions:
+ */
+struct rockchip_device *rockchip_device_create(int fd);
+void rockchip_device_destroy(struct rockchip_device *dev);
+
+/*
+ * buffer-object related functions:
+ */
+struct rockchip_bo *rockchip_bo_create(struct rockchip_device *dev,
+			size_t size, uint32_t flags);
+int rockchip_bo_get_info(struct rockchip_device *dev, uint32_t handle,
+			size_t *size, uint32_t *flags);
+void rockchip_bo_destroy(struct rockchip_bo *bo);
+struct rockchip_bo *rockchip_bo_from_name(struct rockchip_device *dev,
+			uint32_t name);
+int rockchip_bo_get_name(struct rockchip_bo *bo, uint32_t *name);
+uint32_t rockchip_bo_handle(struct rockchip_bo *bo);
+struct rockchip_bo *rockchip_bo_from_handle(struct rockchip_device *dev,
+			uint32_t handle, uint32_t flags, uint32_t size);
+void *rockchip_bo_map(struct rockchip_bo *bo);
+#endif /* ROCKCHIP_DRMIF_H_ */
diff --git a/rockchip/rockchip_rga.c b/rockchip/rockchip_rga.c
new file mode 100644
index 00000000..c8639c26
--- /dev/null
+++ b/rockchip/rockchip_rga.c
@@ -0,0 +1,1084 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rcockhip Electronics Co.Ltd
+ * Authors:
+ *	Yakir Yang <ykk@rock-chips.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+
+#include <android/log.h>
+
+#include <sys/mman.h>
+#include <linux/stddef.h>
+
+#include <xf86drm.h>
+
+#include "drm_fourcc.h"
+//#include "libdrm_macros.h"
+
+#include "rockchip_drm.h"
+#include "rockchip_rga.h"
+#include "rga_reg.h"
+
+#define  LOGI(...) __android_log_print(ANDROID_LOG_INFO, "libdrm", __VA_ARGS__)
+#define  LOGW(...) __android_log_print(ANDROID_LOG_WARN, "libdrm", __VA_ARGS__)
+#define  LOGE(...) __android_log_print(ANDROID_LOG_ERROR, "libdrm", __VA_ARGS__)
+
+enum rga_base_addr_reg {
+	rga_dst = 0,
+	rga_src
+};
+
+enum e_rga_start_pos {
+	LT = 0,
+	LB = 1,
+	RT = 2,
+	RB = 3,
+};
+
+struct rga_addr_offset {
+	unsigned int y_off;
+	unsigned int u_off;
+	unsigned int v_off;
+};
+
+struct rga_corners_addr_offset {
+	struct rga_addr_offset left_top;
+	struct rga_addr_offset right_top;
+	struct rga_addr_offset left_bottom;
+	struct rga_addr_offset right_bottom;
+};
+
+static int rga_get_uv_factor(int drm_color_format)
+{
+	int ydiv = 1;
+
+        switch (drm_color_format) {
+	case DRM_FORMAT_NV16:
+	case DRM_FORMAT_NV61:
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+		ydiv = 2;
+		break;
+
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV12_10:
+	//case DRM_FORMAT_NV21_10:
+		ydiv = 4;
+		break;
+
+	default:
+		break;
+	}
+
+	return ydiv;
+}
+
+static int rga_get_ydiv(int drm_color_format)
+{
+	int ydiv = 1;
+
+        switch (drm_color_format) {
+	case DRM_FORMAT_NV16:
+	case DRM_FORMAT_NV61:
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+		ydiv = 1;
+		break;
+
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV12_10:
+	//case DRM_FORMAT_NV21_10:
+		ydiv = 2;
+		break;
+
+	default:
+		break;
+	}
+
+	return ydiv;
+}
+
+static int rga_get_xdiv(int drm_color_format)
+{
+	int xdiv = 2;
+
+        switch (drm_color_format) {
+	case DRM_FORMAT_NV16:
+	case DRM_FORMAT_NV61:
+	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_NV12_10:
+	//case DRM_FORMAT_NV21_10:
+		xdiv = 1;
+		break;
+
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YVU422:
+		xdiv = 2;
+		break;
+
+	default:
+		break;
+	}
+
+	return xdiv;
+}
+
+static int rga_get_color_swap(int drm_color_format)
+{
+	unsigned int swap = 0;
+
+	switch (drm_color_format) {
+		case DRM_FORMAT_RGBA8888:
+		case DRM_FORMAT_RGBX8888:
+		case DRM_FORMAT_RGBA5551:
+		case DRM_FORMAT_RGBA4444:
+		case DRM_FORMAT_RGB888:
+		case DRM_FORMAT_RGB565:
+			break;
+
+		case DRM_FORMAT_YUV422:
+		case DRM_FORMAT_YUV420:
+		case DRM_FORMAT_NV12:
+		case DRM_FORMAT_NV16:
+		case DRM_FORMAT_NV12_10:
+			break;
+
+		case DRM_FORMAT_ABGR8888:
+		case DRM_FORMAT_XBGR8888:
+		case DRM_FORMAT_ABGR1555:
+		case DRM_FORMAT_ABGR4444:
+			swap |= RGA_SRC_COLOR_ALPHA_SWAP;
+
+		case DRM_FORMAT_BGRA8888:
+		case DRM_FORMAT_BGRX8888:
+		case DRM_FORMAT_BGRA5551:
+		case DRM_FORMAT_BGRA4444:
+		case DRM_FORMAT_BGR888:
+		case DRM_FORMAT_BGR565:
+			swap |= RGA_SRC_COLOR_RB_SWAP;
+			break;
+
+		case DRM_FORMAT_YVU422:
+		case DRM_FORMAT_YVU420:
+		case DRM_FORMAT_NV21:
+		case DRM_FORMAT_NV61:
+		//case DRM_FORMAT_NV21_10:
+			swap |= RGA_SRC_COLOR_UV_SWAP;
+			break;
+
+		default:
+			printf("Unsupport input color format %d\n", drm_color_format);
+			break;
+	}
+
+	return swap;
+}
+
+static int rga_get_color_format(int drm_color_format)
+{
+        switch (drm_color_format) {
+		case DRM_FORMAT_ARGB8888:
+		case DRM_FORMAT_ABGR8888:
+		case DRM_FORMAT_BGRA8888:
+		case DRM_FORMAT_RGBA8888:
+			return RGA_SRC_COLOR_FMT_ABGR8888;
+
+		case DRM_FORMAT_XRGB8888:
+		case DRM_FORMAT_XBGR8888:
+		case DRM_FORMAT_RGBX8888:
+		case DRM_FORMAT_BGRX8888:
+			return RGA_SRC_COLOR_FMT_XBGR8888;
+
+		case DRM_FORMAT_RGB888:
+		case DRM_FORMAT_BGR888:
+			return RGA_SRC_COLOR_FMT_RGB888;
+
+		case DRM_FORMAT_RGB565:
+		case DRM_FORMAT_BGR565:
+			return RGA_SRC_COLOR_FMT_RGB565;
+
+		case DRM_FORMAT_ARGB1555:
+		case DRM_FORMAT_ABGR1555:
+		case DRM_FORMAT_RGBA5551:
+		case DRM_FORMAT_BGRA5551:
+			return RGA_SRC_COLOR_FMT_ARGB1555;
+
+		case DRM_FORMAT_ARGB4444:
+		case DRM_FORMAT_ABGR4444:
+		case DRM_FORMAT_RGBA4444:
+		case DRM_FORMAT_BGRA4444:
+			return RGA_SRC_COLOR_FMT_ARGB4444;
+
+		case DRM_FORMAT_NV16:
+		case DRM_FORMAT_NV61:
+			return RGA_SRC_COLOR_FMT_YUV422SP;
+
+		case DRM_FORMAT_YUV422:
+		case DRM_FORMAT_YVU422:
+			return RGA_SRC_COLOR_FMT_YUV422P;
+
+		case DRM_FORMAT_NV12:
+		case DRM_FORMAT_NV21:
+		case DRM_FORMAT_NV12_10:
+			//case DRM_FORMAT_NV21_10:
+			return RGA_SRC_COLOR_FMT_YUV420SP;
+
+		case DRM_FORMAT_YUV420:
+		case DRM_FORMAT_YVU420:
+			return RGA_SRC_COLOR_FMT_YUV420P;
+
+		default:
+			return -EINVAL;
+	};
+}
+
+int get_string_of_cmd(int index,char *buf)
+{
+	switch (index) {
+		case MODE_CTRL		:strcpy(buf,"MODE_CTRL          ");break;
+		case SRC_INFO		:strcpy(buf,"SRC_INFO           ");break;
+		case SRC_Y_RGB_BASE_ADDR:strcpy(buf,"SRC_Y_RGB_BASE_ADDR");break;
+		case SRC_CB_BASE_ADDR	:strcpy(buf,"SRC_CB_BASE_ADDR   ");break;
+		case SRC_CR_BASE_ADDR	:strcpy(buf,"SRC_CR_BASE_ADDR   ");break;
+		case SRC1_RGB_BASE_ADDR	:strcpy(buf,"SRC1_RGB_BASE_ADDR ");break;
+		case SRC_VIR_INFO	:strcpy(buf,"SRC_VIR_INFO       ");break;
+		case SRC_ACT_INFO	:strcpy(buf,"SRC_ACT_INFO       ");break;
+		case SRC_X_FACTOR	:strcpy(buf,"SRC_X_FACTOR       ");break;
+		case SRC_Y_FACTOR	:strcpy(buf,"SRC_Y_FACTOR       ");break;
+		case SRC_BG_COLOR	:strcpy(buf,"SRC_BG_COLOR       ");break;
+		case SRC_FG_COLOR	:strcpy(buf,"SRC_FG_COLOR       ");break;
+		case SRC_TR_COLOR0	:strcpy(buf,"SRC_TR_COLOR0      ");break;
+		case SRC_TR_COLOR1	:strcpy(buf,"SRC_TR_COLOR1      ");break;
+		case DST_INFO		:strcpy(buf,"DST_INFO           ");break;
+		case DST_Y_RGB_BASE_ADDR:strcpy(buf,"DST_Y_RGB_BASE_ADDR");break;
+		case DST_CB_BASE_ADDR	:strcpy(buf,"DST_CB_BASE_ADDR   ");break;
+		case DST_CR_BASE_ADDR	:strcpy(buf,"DST_CR_BASE_ADDR   ");break;
+		case DST_VIR_INFO	:strcpy(buf,"DST_VIR_INFO       ");break;
+		case DST_ACT_INFO	:strcpy(buf,"DST_ACT_INFO       ");break;
+		case ALPHA_CTRL0	:strcpy(buf,"ALPHA_CTRL0        ");break;
+		case ALPHA_CTRL1	:strcpy(buf,"ALPHA_CTRL1        ");break;
+		case FADING_CTRL	:strcpy(buf,"FADING_CTRL        ");break;
+		case PAT_CON		:strcpy(buf,"PAT_CON            ");break;
+		case ROP_CON0		:strcpy(buf,"ROP_CON0           ");break;
+		case ROP_CON1		:strcpy(buf,"ROP_CON1           ");break;
+		case MASK_BASE		:strcpy(buf,"MASK_BASE          ");break;
+		case MMU_CTRL1		:strcpy(buf,"MMU_CTRL1          ");break;
+		case MMU_SRC_BASE	:strcpy(buf,"MMU_SRC_BASE       ");break;
+		case MMU_SRC1_BASE	:strcpy(buf,"MMU_SRC1_BASE      ");break;
+		case MMU_DST_BASE	:strcpy(buf,"MMU_DST_BASE       ");break;
+		case MMU_ELS_BASE	:strcpy(buf,"MMU_ELS_BASE       ");break;
+		case RGA_BUF_TYPE_GEMFD | SRC_Y_RGB_BASE_ADDR:
+					 strcpy(buf,"SRC_Y_RGB_BASE_ADDR");break;
+		case RGA_BUF_TYPE_GEMFD | DST_Y_RGB_BASE_ADDR:
+					 strcpy(buf,"DST_Y_RGB_BASE_ADDR");break;
+		default			:strcpy(buf,"ERROR_OFFSET       ");break;
+	}
+	return 0;
+}
+
+static unsigned int rga_get_scaling(unsigned int src, unsigned int dst)
+{
+	/*
+	 * The rga hw scaling factor is a normalized inverse of the scaling factor.
+	 * For example: When source width is 100 and destination width is 200
+	 * (scaling of 2x), then the hw factor is NC * 100 / 200.
+	 * The normalization factor (NC) is 2^16 = 0x10000.
+	 */
+
+	return (src > dst) ? ((dst << 16) / src) : ((src << 16) / dst);
+}
+
+static struct rga_corners_addr_offset
+rga_get_addr_offset(struct rga_image *img, unsigned int x, unsigned int y,
+		    unsigned int w, unsigned int h)
+{
+	struct rga_corners_addr_offset offsets;
+	struct rga_addr_offset *lt, *lb, *rt, *rb;
+	unsigned int x_div = 0, y_div = 0, uv_stride = 0, pixel_width = 0, uv_factor = 0;
+
+	lt = &offsets.left_top;
+	lb = &offsets.left_bottom;
+	rt = &offsets.right_top;
+	rb = &offsets.right_bottom;
+
+	x_div = rga_get_xdiv(img->color_mode);
+	y_div = rga_get_ydiv(img->color_mode);
+	uv_factor = rga_get_uv_factor(img->color_mode);
+	uv_stride = img->stride / x_div;
+	pixel_width = img->stride / img->width;
+
+	lt->y_off = y * img->stride + x * pixel_width;
+	lt->u_off = img->stride * img->hstride + (y / y_div) * uv_stride + x / x_div;
+	lt->v_off = lt->u_off + img->width * img->hstride / uv_factor;
+
+	lb->y_off = lt->y_off + (h - 1) * img->stride;
+	lb->u_off = lt->u_off + (h / y_div - 1) * uv_stride;
+	lb->v_off = lt->v_off + (h / y_div - 1) * uv_stride;
+
+	rt->y_off = lt->y_off + (w - 1) * pixel_width;
+	rt->u_off = lt->u_off + w / x_div - 1;
+	rt->v_off = lt->v_off + w / x_div - 1;
+
+	rb->y_off = lb->y_off + (w - 1) * pixel_width;
+	rb->u_off = lb->u_off + w / x_div - 1;
+	rb->v_off = lb->v_off + w / x_div - 1;
+
+	return offsets;
+}
+
+static struct rga_addr_offset *
+rga_lookup_draw_pos(struct rga_corners_addr_offset *offsets,
+		    enum e_rga_src_rot_mode rotate_mode,
+		    enum e_rga_src_mirr_mode mirr_mode)
+{
+	static enum e_rga_start_pos rot_mir_point_matrix[4][4] = {
+		{ LT, RT, LB, RB, },
+		{ RT, LT, RB, LB, },
+		{ RB, LB, RT, LT, },
+		{ LB, RB, LT, RT, },
+	};
+
+	if (offsets == NULL)
+		return NULL;
+
+	switch (rot_mir_point_matrix[rotate_mode][mirr_mode]) {
+	case LT:
+		return &offsets->left_top;
+	case LB:
+		return &offsets->left_bottom;
+	case RT:
+		return &offsets->right_top;
+	case RB:
+		return &offsets->right_bottom;
+	};
+
+	return NULL;
+}
+
+/*
+ * rga_add_cmd - set given command and value to user side command buffer.
+ *
+ * @ctx: a pointer to rga_context structure.
+ * @cmd: command data.
+ * @value: value data.
+ */
+static int rga_add_cmd(struct rga_context *ctx, unsigned long cmd,
+			unsigned long value)
+{
+	char buf[25];
+	const char *fmt;
+
+	if (ctx->log & 1) {
+		get_string_of_cmd(cmd, buf);
+		fprintf(stderr,"%s:0x%x:0x%x\n",buf,cmd,value);
+		LOGI("%s:%8x:  0x%x\n",buf,cmd,value);
+	}
+
+	switch (cmd & ~(RGA_IMGBUF_USERPTR)) {
+	case SRC_Y_RGB_BASE_ADDR:
+	case SRC_CB_BASE_ADDR:
+	case SRC_CR_BASE_ADDR:
+	case SRC1_RGB_BASE_ADDR:
+	case DST_Y_RGB_BASE_ADDR:
+	case DST_CB_BASE_ADDR:
+	case DST_CR_BASE_ADDR:
+		if (ctx->cmd_buf_nr >= RGA_MAX_GEM_CMD_NR) {
+			fprintf(stderr, "Overflow cmd_gem size.\n");
+			return -EINVAL;
+		}
+
+		ctx->cmd_buf[ctx->cmd_buf_nr].offset = cmd;
+		ctx->cmd_buf[ctx->cmd_buf_nr].data = value;
+		ctx->cmd_buf_nr++;
+
+		break;
+	default:
+		if (ctx->cmd_nr >= RGA_MAX_CMD_NR) {
+			fprintf(stderr, "Overflow cmd size.\n");
+			return -EINVAL;
+		}
+
+		ctx->cmd[ctx->cmd_nr].offset = cmd;
+		ctx->cmd[ctx->cmd_nr].data = value;
+		ctx->cmd_nr++;
+
+		break;
+	}
+
+	return 0;
+}
+
+int rga_dump_context(struct rga_context ctx)
+{
+    int i = 0;
+    char buf[25];
+    fprintf(stderr,"********************frame start************************\n"
+                   "fd=%d,major=%d,minor=%d\n"
+                   "cmd_nr=%d,cmd=%p\n"
+                   "cmd_buf_nr=%d,cmd_buf=%p\n"
+                   "cmdlist_nr=%d\n",
+                    ctx.fd,ctx.major,ctx.minor,ctx.cmd_nr,ctx.cmd,
+                    ctx.cmd_buf_nr,ctx.cmd_buf,ctx.cmdlist_nr);
+
+    fprintf(stderr,"\n---------------cmd_nr=%d,cmd=%p:\n",ctx.cmd_nr,ctx.cmd);
+    for(i = 0; i < ctx.cmd_nr; i ++) {
+        get_string_of_cmd(ctx.cmd[i].offset,buf);
+        fprintf(stderr,"%s:0x%x:[0x%x]\n",
+                                       buf,ctx.cmd[i].offset,ctx.cmd[i].data);
+    }
+
+    fprintf(stderr,"\ncmd_buf_nr=%d,cmd_buf=%p\n",ctx.cmd_buf_nr,ctx.cmd_buf);
+    for(i = 0; i < ctx.cmd_buf_nr; i ++) {
+        get_string_of_cmd(ctx.cmd_buf[i].offset,buf);
+        fprintf(stderr,"%s:0x%x:[0x%x]\n",
+                               buf,ctx.cmd_buf[i].offset,ctx.cmd_buf[i].data);
+    }
+    fprintf(stderr,"*******************frame end*************************\n");
+    return 0;
+}
+
+int rga_src_color_is_yuv(int format)
+{
+	int ret = 0;
+	switch (format) {
+		case RGA_SRC_COLOR_FMT_YUV422SP:
+		case RGA_SRC_COLOR_FMT_YUV422P:
+		case RGA_SRC_COLOR_FMT_YUV420SP:
+		case RGA_SRC_COLOR_FMT_YUV420P:
+			ret = 1;
+			break;
+
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+int rga_dst_color_is_yuv(int format)
+{
+	int ret = 0;
+	switch (format) {
+		case RGA_DST_COLOR_FMT_YUV422SP:
+		case RGA_DST_COLOR_FMT_YUV422P:
+		case RGA_DST_COLOR_FMT_YUV420SP:
+		case RGA_DST_COLOR_FMT_YUV420P:
+			ret = 1;
+			break;
+
+		default:
+			break;
+	}
+
+	return ret;
+}
+/*
+ * rga_add_base_addr - helper function to set dst/src base address register.
+ *
+ * @ctx: a pointer to rga_context structure.
+ * @img: a pointer to the dst/src rga_image structure.
+ * @reg: the register that should be set.
+ */
+static void rga_add_base_addr(struct rga_context *ctx, struct rga_image *img,
+			      enum rga_base_addr_reg reg)
+{
+	const unsigned long cmd = (reg == rga_dst) ?
+		DST_Y_RGB_BASE_ADDR : SRC_Y_RGB_BASE_ADDR;
+
+	if (img->buf_type == RGA_IMGBUF_USERPTR) {
+		fprintf(stderr, "Can't support userptr now!\n");
+		return;
+	} else {
+		rga_add_cmd(ctx, cmd | RGA_BUF_TYPE_GEMFD, img->bo[0]);
+	}
+}
+
+/*
+ * rga_reset - reset rga hardware.
+ *
+ * @ctx: a pointer to rga_context structure.
+ *
+ */
+static void rga_reset(struct rga_context *ctx)
+{
+	ctx->cmd_nr = 0;
+	ctx->cmd_buf_nr = 0;
+}
+
+/*
+ * rga_flush - submit all commands and values in user side command buffer
+ *		to command queue aware of rga dma.
+ *
+ * @ctx: a pointer to rga_context structure.
+ *
+ * This function should be called after all commands and values to user
+ * side command buffer are set. It submits that buffer to the kernel side driver.
+ */
+static int rga_flush(struct rga_context *ctx)
+{
+	int ret;
+	struct drm_rockchip_rga_set_cmdlist cmdlist = {0};
+
+	if (ctx->cmd_nr == 0 && ctx->cmd_buf_nr == 0)
+		return -1;
+
+	if (ctx->cmdlist_nr >= RGA_MAX_CMD_LIST_NR) {
+		fprintf(stderr, "Overflow cmdlist.\n");
+		return -EINVAL;
+	}
+
+	//rga_dump_context(*ctx);
+
+	cmdlist.cmd = (uint64_t)(uintptr_t)&ctx->cmd[0];
+	cmdlist.cmd_buf = (uint64_t)(uintptr_t)&ctx->cmd_buf[0];
+	cmdlist.cmd_nr = ctx->cmd_nr;
+	cmdlist.cmd_buf_nr = ctx->cmd_buf_nr;
+
+	ctx->cmd_nr = 0;
+	ctx->cmd_buf_nr = 0;
+
+	ret = drmIoctl(ctx->fd, DRM_IOCTL_ROCKCHIP_RGA_SET_CMDLIST, &cmdlist);
+	if (ret < 0) {
+		fprintf(stderr, "failed to set cmdlist.\n");
+		return ret;
+	}
+
+	ctx->cmdlist_nr++;
+
+	return ret;
+}
+
+/**
+ * rga_init - create a new rga context and get hardware version.
+ *
+ * fd: a file descriptor to an opened drm device.
+ */
+struct rga_context *rga_init(int fd)
+{
+	struct drm_rockchip_rga_get_ver ver;
+	struct rga_context *ctx;
+	int ret;
+
+	ctx = calloc(1, sizeof(*ctx));
+	if (!ctx) {
+		fprintf(stderr, "failed to allocate context.\n");
+		return NULL;
+	}
+
+	ctx->fd = fd;
+
+	ret = drmIoctl(fd, DRM_IOCTL_ROCKCHIP_RGA_GET_VER, &ver);
+	if (ret < 0) {
+		fprintf(stderr, "failed to get version.\n");
+		free(ctx);
+		return NULL;
+	}
+
+	ctx->major = ver.major;
+	ctx->minor = ver.minor;
+
+	return ctx;
+}
+
+void rga_fini(struct rga_context *ctx)
+{
+	if (ctx)
+		free(ctx);
+}
+
+/**
+ * rga_exec - start the dma to process all commands summited by rga_flush().
+ *
+ * @ctx: a pointer to rga_context structure.
+ */
+int rga_exec(struct rga_context *ctx)
+{
+	struct drm_rockchip_rga_exec exec;
+	int ret;
+
+	if (ctx->cmdlist_nr == 0)
+		return -EINVAL;
+
+	exec.async = 0;
+
+	ret = drmIoctl(ctx->fd, DRM_IOCTL_ROCKCHIP_RGA_EXEC, &exec);
+	if (ret < 0) {
+		fprintf(stderr, "failed to execute.\n");
+		return ret;
+	}
+
+	ctx->cmdlist_nr = 0;
+
+	return ret;
+}
+
+/**
+ * rga_solid_fill - fill given buffer with given color data.
+ *
+ * @ctx: a pointer to rga_context structure.
+ * @img: a pointer to rga_image structure including image and buffer
+ *	information.
+ * @x: x start position to buffer filled with given color data.
+ * @y: y start position to buffer filled with given color data.
+ * @w: width value to buffer filled with given color data.
+ * @h: height value to buffer filled with given color data.
+ */
+int rga_solid_fill(struct rga_context *ctx, struct rga_image *img,
+		   unsigned int x, unsigned int y, unsigned int w,
+		   unsigned int h)
+{
+	union rga_mode_ctrl mode;
+	union rga_dst_info dst_info;
+	union rga_dst_vir_info dst_vir_info;
+	union rga_dst_act_info dst_act_info;
+
+	struct rga_corners_addr_offset offsets;
+
+	if (x + w > img->width)
+		w = img->width - x;
+	if (y + h > img->height)
+		h = img->height - y;
+
+	/* Init the operation registers to zero */
+	mode.val = 0;
+	dst_info.val = 0;
+	dst_act_info.val = 0;
+	dst_vir_info.val = 0;
+
+	/*
+	 * Configure the RGA operation mode registers:
+	 *   Bitblt Mode,
+	 *   SRC + DST=> DST,
+	 *   Solid color fill,
+	 *   Gradient status is not-clip,
+	 */
+	mode.data.gradient_sat = 1;
+	mode.data.render = RGA_MODE_RENDER_BITBLT;
+	mode.data.render = RGA_MODE_RENDER_RECTANGLE_FILL;
+	mode.data.cf_rop4_pat = RGA_MODE_CF_ROP4_SOLID,
+	mode.data.bitblt = RGA_MODE_BITBLT_MODE_SRC_TO_DST;
+
+	rga_add_cmd(ctx, MODE_CTRL, mode.val);
+
+
+	/*
+	 * Translate the DRM color format to RGA color format
+	 */
+	dst_info.data.format = rga_get_color_format(img->color_mode);
+	dst_info.data.swap   = rga_get_color_swap(img->color_mode);
+	dst_info.data.csc_mode = RGA_DST_CSC_MODE_BT601_R0;
+
+	if (dst_info.data.format == RGA_DST_COLOR_FMT_YUV422SP ||
+	    dst_info.data.format == RGA_DST_COLOR_FMT_YUV422P ||
+	    dst_info.data.format == RGA_DST_COLOR_FMT_YUV420SP ||
+	    dst_info.data.format == RGA_DST_COLOR_FMT_YUV420P)
+		dst_info.data.csc_mode = RGA_DST_CSC_MODE_BT601_R0;
+
+	rga_add_cmd(ctx, DST_INFO, dst_info.val);
+
+
+	/*
+	 * Configure the target color to foreground color.
+	 */
+	rga_add_cmd(ctx, SRC_FG_COLOR, img->fill_color);
+
+
+	/*
+	 * Cacluate the framebuffer virtual strides and active size,
+	 * note that the step of vir_stride is 4 byte words
+	 */
+	dst_vir_info.data.vir_stride = img->stride >> 2;
+	dst_act_info.data.act_height = h - 1;
+	dst_act_info.data.act_width = w - 1;
+
+	rga_add_cmd(ctx, DST_VIR_INFO, dst_vir_info.val);
+	rga_add_cmd(ctx, DST_ACT_INFO, dst_act_info.val);
+
+
+	/*
+	 * Configure the dest framebuffer base address with pixel offset.
+	 */
+	offsets = rga_get_addr_offset(img, x, y, w, h);
+
+	rga_add_cmd(ctx, DST_Y_RGB_BASE_ADDR, offsets.left_top.y_off);
+	rga_add_cmd(ctx, DST_CB_BASE_ADDR, offsets.left_top.u_off);
+	rga_add_cmd(ctx, DST_CR_BASE_ADDR, offsets.left_top.v_off);
+
+	rga_add_base_addr(ctx, img, rga_dst);
+
+
+	/* Start to flush RGA device */
+	rga_flush(ctx);
+
+	return 0;
+}
+
+int rga_multiple_transform(struct rga_context *ctx, struct rga_image *src,
+			   struct rga_image *dst, unsigned int src_x,
+			   unsigned int src_y, unsigned int src_w,
+			   unsigned int src_h, unsigned int dst_x,
+			   unsigned int dst_y, unsigned int dst_w,
+			   unsigned int dst_h, unsigned int degree,
+			   unsigned int x_mirr, unsigned int y_mirr)
+{
+	union rga_mode_ctrl mode;
+	union rga_src_info src_info;
+	union rga_dst_info dst_info;
+	union rga_src_x_factor x_factor;
+	union rga_src_y_factor y_factor;
+	union rga_src_vir_info src_vir_info;
+	union rga_src_act_info src_act_info;
+	union rga_dst_vir_info dst_vir_info;
+	union rga_dst_act_info dst_act_info;
+
+	struct rga_addr_offset *dst_offset;
+	struct rga_corners_addr_offset offsets;
+	struct rga_corners_addr_offset src_offsets;
+
+	unsigned int scale_dst_w, scale_dst_h;
+
+	if (degree != 0 && degree != 90 && degree != 180 && degree != 270) {
+		fprintf(stderr, "invalid rotate degree.\n");
+		rga_reset(ctx);
+		return -EINVAL;
+	}
+
+	if (src_w < 32 || src_h < 34 || dst_w < 32 || dst_h < 34) {
+		fprintf(stderr, "invalid src/dst width or height.\n");
+		rga_reset(ctx);
+		return -EINVAL;
+	}
+
+	if (src_x + src_w > src->width)
+		src_w = src->width - src_x;
+	if (src_y + src_h > src->height)
+		src_h = src->height - src_y;
+
+	if (dst_x + dst_w > dst->width)
+		dst_w = dst->width - dst_x;
+	if (dst_y + dst_h > dst->height)
+		dst_h = dst->height - dst_y;
+
+	if (src_w <= 0 || src_h <= 0 || dst_w <= 0 || dst_h <= 0) {
+		fprintf(stderr, "invalid width or height.\n");
+		rga_reset(ctx);
+		return -EINVAL;
+	}
+
+	/* Init RGA registers values to zero */
+	mode.val = 0;
+	x_factor.val = 0;
+	y_factor.val = 0;
+	src_info.val = 0;
+	dst_info.val = 0;
+	src_vir_info.val = 0;
+	dst_vir_info.val = 0;
+	src_act_info.val = 0;
+	dst_act_info.val = 0;
+
+	/*
+	 * Configure the RGA operation mode registers:
+	 *   Bitblt Mode,
+	 *   SRC => DST,
+	 *   Gradient status is not-clip,
+	 */
+	mode.data.gradient_sat = 1;
+	mode.data.render = RGA_MODE_RENDER_BITBLT;
+	mode.data.bitblt = RGA_MODE_BITBLT_MODE_SRC_TO_DST;
+	rga_add_cmd(ctx, MODE_CTRL, mode.val);
+
+	/*
+	 * Translate the DRM color format to RGA color format, and
+	 * configure the actual rotate / mirr mode.
+	 */
+	src_info.data.format   = rga_get_color_format(src->color_mode);
+	dst_info.data.format   = rga_get_color_format(dst->color_mode);
+	src_info.data.swap     = rga_get_color_swap(src->color_mode);
+	dst_info.data.swap     = rga_get_color_swap(dst->color_mode);
+
+	if (src->color_mode == DRM_FORMAT_NV12_10) {
+		src_info.data.yuv_ten_en = RGA_SRC_YUV_TEN_ENABLE;
+		src_info.data.yuv_ten_round_en = RGA_SRC_YUV_TEN_ROUND_ENABLE;
+	}
+
+	switch (degree) {
+	case 90:
+		src_info.data.rot_mode = RGA_SRC_ROT_MODE_90_DEGREE;
+		break;
+	case 180:
+		src_info.data.rot_mode = RGA_SRC_ROT_MODE_180_DEGREE;
+		break;
+	case 270:
+		src_info.data.rot_mode = RGA_SRC_ROT_MODE_270_DEGREE;
+		break;
+	default:
+		src_info.data.rot_mode = RGA_SRC_ROT_MODE_0_DEGREE;
+		break;
+	}
+
+	if (x_mirr)
+		src_info.data.mir_mode |= RGA_SRC_MIRR_MODE_X;
+	if (y_mirr)
+		src_info.data.mir_mode |= RGA_SRC_MIRR_MODE_Y;
+
+	/*
+	 * Cacluate the up/down scaling mode/factor.
+	 *
+	 * RGA used to scale the picture first, and then rotate second,
+	 * so we need to swap the w/h when rotate degree is 90/270.
+	 */
+	if (src_info.data.rot_mode == RGA_SRC_ROT_MODE_90_DEGREE ||
+	    src_info.data.rot_mode == RGA_SRC_ROT_MODE_270_DEGREE) {
+		if (ctx->major == 0 || ctx->minor == 0) {
+			if (dst_w == src_h)
+				src_h -= 8;
+			if (abs(src_w - dst_h) < 16)
+				src_w -= 16;
+		}
+
+		scale_dst_h = dst_w;
+		scale_dst_w = dst_h;
+	} else {
+		scale_dst_w = dst_w;
+		scale_dst_h = dst_h;
+	}
+
+	if (src_w == scale_dst_w) {
+		src_info.data.hscl_mode = RGA_SRC_HSCL_MODE_NO;
+		x_factor.val = 0;
+		if (src->color_mode == DRM_FORMAT_NV12_10)
+		    src_info.data.hscl_mode = RGA_SRC_HSCL_MODE_DOWN | RGA_SRC_HSCL_MODE_UP;
+	} else if(src_w > scale_dst_w) {
+		src_info.data.hscl_mode = RGA_SRC_HSCL_MODE_DOWN;
+		x_factor.data.down_scale_factor = rga_get_scaling(src_w, scale_dst_w) + 1;
+	} else {
+		src_info.data.hscl_mode = RGA_SRC_HSCL_MODE_UP;
+		x_factor.data.up_scale_factor = rga_get_scaling(src_w - 1, scale_dst_w - 1);
+	}
+
+	if (src_h == scale_dst_h) {
+		src_info.data.vscl_mode = RGA_SRC_VSCL_MODE_NO;
+		y_factor.val = 0;
+		if (src->color_mode == DRM_FORMAT_NV12_10)
+		    src_info.data.vscl_mode = RGA_SRC_VSCL_MODE_DOWN | RGA_SRC_VSCL_MODE_UP;
+	} else if(src_h > scale_dst_h) {
+		src_info.data.vscl_mode = RGA_SRC_VSCL_MODE_DOWN;
+		y_factor.data.down_scale_factor = rga_get_scaling(src_h, scale_dst_h) + 1;
+	} else {
+		src_info.data.vscl_mode = RGA_SRC_VSCL_MODE_UP;
+		y_factor.data.up_scale_factor = rga_get_scaling(src_h - 1, scale_dst_h - 1);
+	}
+
+	rga_add_cmd(ctx, SRC_X_FACTOR, x_factor.val);
+	rga_add_cmd(ctx, SRC_Y_FACTOR, y_factor.val);
+
+	if (rga_src_color_is_yuv(src_info.data.format)
+			&& rga_dst_color_is_yuv(dst_info.data.format)) {
+		src_info.data.csc_mode = RGA_SRC_CSC_MODE_BT601_R0;
+		dst_info.data.csc_mode = RGA_SRC_CSC_MODE_BT601_R0;
+	}
+
+	if (rga_src_color_is_yuv(src_info.data.format)
+			&& !rga_dst_color_is_yuv(dst_info.data.format))
+		src_info.data.csc_mode = RGA_SRC_CSC_MODE_BT601_R1;
+
+	if (!rga_src_color_is_yuv(src_info.data.format)
+			&& rga_dst_color_is_yuv(dst_info.data.format))
+		dst_info.data.csc_mode = RGA_SRC_CSC_MODE_BT601_R1;
+
+	rga_add_cmd(ctx, SRC_INFO, src_info.val);
+	rga_add_cmd(ctx, DST_INFO, dst_info.val);
+
+
+	/*
+	 * Cacluate the framebuffer virtual strides and active size,
+	 * note that the step of vir_stride / vir_width is 4 byte words
+	 */
+	src_vir_info.data.vir_stride = 0x3ff;//src->stride >> 2;
+	src_vir_info.data.vir_width = src->stride >> 2;
+
+	src_act_info.data.act_height = src_h - 1;
+	src_act_info.data.act_width = src_w - 1;
+
+	dst_vir_info.data.vir_stride = dst->stride >> 2;
+	dst_act_info.data.act_height = dst_h - 1;
+	dst_act_info.data.act_width = dst_w - 1;
+
+	rga_add_cmd(ctx, SRC_VIR_INFO, src_vir_info.val);
+	rga_add_cmd(ctx, SRC_ACT_INFO, src_act_info.val);
+
+	rga_add_cmd(ctx, DST_VIR_INFO, dst_vir_info.val);
+	rga_add_cmd(ctx, DST_ACT_INFO, dst_act_info.val);
+
+
+	/*
+	 * Cacluate the source framebuffer base address with offset pixel.
+	 */
+	src_offsets = rga_get_addr_offset(src, src_x, src_y, src_w, src_h);
+
+	rga_add_cmd(ctx, SRC_Y_RGB_BASE_ADDR, src_offsets.left_top.y_off);
+	rga_add_cmd(ctx, SRC_CB_BASE_ADDR, src_offsets.left_top.u_off);
+	rga_add_cmd(ctx, SRC_CR_BASE_ADDR, src_offsets.left_top.v_off);
+
+	rga_add_base_addr(ctx, src, rga_src);
+
+
+	/*
+	 * Configure the dest framebuffer base address with pixel offset.
+	 */
+	offsets = rga_get_addr_offset(dst, dst_x, dst_y, dst_w, dst_h);
+	dst_offset = rga_lookup_draw_pos(&offsets, src_info.data.rot_mode,
+					 src_info.data.mir_mode);
+
+	rga_add_cmd(ctx, DST_Y_RGB_BASE_ADDR, dst_offset->y_off);
+	rga_add_cmd(ctx, DST_CB_BASE_ADDR, dst_offset->u_off);
+	rga_add_cmd(ctx, DST_CR_BASE_ADDR, dst_offset->v_off);
+
+	rga_add_base_addr(ctx, dst, rga_dst);
+
+
+	/* Start to flush RGA device */
+	rga_flush(ctx);
+
+	return 0;
+}
+
+/**
+ * rga_copy_with_rorate - copy contents in source buffer to destination buffer
+ *	rotate properly.
+ *
+ * @ctx: a pointer to rga_context structure.
+ * @src: a pointer to rga_image structure including image and buffer
+ *	information to source.
+ * @dst: a pointer to rga_image structure including image and buffer
+ *	information to destination.
+ * @src_x: x start position to source buffer.
+ * @src_y: y start position to source buffer.
+ * @src_w: width value to source buffer.
+ * @src_h: height value to source buffer.
+ * @dst_x: x start position to destination buffer.
+ * @dst_y: y start position to destination buffer.
+ * @dst_w: width value to destination buffer.
+ * @dst_h: height value to destination buffer.
+ * @degree: rotate degree (0, 90, 180, 270)
+ */
+int rga_copy_with_rotate(struct rga_context *ctx, struct rga_image *src,
+			 struct rga_image *dst, unsigned int src_x,
+			 unsigned int src_y, unsigned int src_w,
+			 unsigned int src_h, unsigned int dst_x,
+			 unsigned int dst_y, unsigned int dst_w,
+			 unsigned int dst_h, unsigned int degree)
+{
+	if (degree != 0 && degree != 90 && degree != 180 && degree != 270) {
+		fprintf(stderr, "invalid rotate degree %d.\n", degree);
+		return -EINVAL;
+	}
+
+	return rga_multiple_transform(ctx, src, dst, src_x, src_y, src_w,
+				      src_h, dst_x, dst_y, dst_w, dst_h,
+				      degree, 0, 0);
+}
+
+/**
+ * rga_copy_with_scale - copy contents in source buffer to destination buffer
+ *	scaling up or down properly.
+ *
+ * @ctx: a pointer to rga_context structure.
+ * @src: a pointer to rga_image structure including image and buffer
+ *	information to source.
+ * @dst: a pointer to rga_image structure including image and buffer
+ *	information to destination.
+ * @src_x: x start position to source buffer.
+ * @src_y: y start position to source buffer.
+ * @src_w: width value to source buffer.
+ * @src_h: height value to source buffer.
+ * @dst_x: x start position to destination buffer.
+ * @dst_y: y start position to destination buffer.
+ * @dst_w: width value to destination buffer.
+ * @dst_h: height value to destination buffer.
+ */
+int rga_copy_with_scale(struct rga_context *ctx, struct rga_image *src,
+			struct rga_image *dst, unsigned int src_x,
+			unsigned int src_y, unsigned int src_w,
+			unsigned int src_h, unsigned int dst_x,
+			unsigned int dst_y, unsigned int dst_w,
+			unsigned int dst_h)
+{
+
+	return rga_multiple_transform(ctx, src, dst, src_x, src_y, src_w,
+				      src_h, dst_x, dst_y, dst_w, dst_h,
+				      0, 0, 0);
+}
+
+/**
+ * rga_copy - copy contents in source buffer to destination buffer.
+ *
+ * @ctx: a pointer to rga_context structure.
+ * @src: a pointer to rga_image structure including image and buffer
+ *	information to source.
+ * @dst: a pointer to rga_image structure including image and buffer
+ *	information to destination.
+ * @src_x: x start position to source buffer.
+ * @src_y: y start position to source buffer.
+ * @dst_x: x start position to destination buffer.
+ * @dst_y: y start position to destination buffer.
+ * @w: width value to source and destination buffers.
+ * @h: height value to source and destination buffers.
+ */
+int rga_copy(struct rga_context *ctx, struct rga_image *src,
+	     struct rga_image *dst, unsigned int src_x, unsigned int src_y,
+	     unsigned int dst_x, unsigned dst_y, unsigned int w,
+	     unsigned int h)
+{
+	unsigned int src_w = 0, src_h = 0, dst_w = 0, dst_h = 0;
+
+	src_w = w;
+	src_h = h;
+	if (src_x + src_w > src->width)
+		src_w = src->width - src_x;
+	if (src_y + src_h > src->height)
+		src_h = src->height - src_y;
+
+	dst_w = w;
+	dst_h = h;
+	if (dst_x + dst_w > dst->width)
+		dst_w = dst->width - dst_x;
+	if (dst_y + dst_h > dst->height)
+		dst_h = dst->height - dst_y;
+
+	w = (src_w < dst_w) ? src_w : dst_w;
+	h = (src_h < dst_h) ? src_h : dst_h;
+
+	if (w <= 0 || h <= 0) {
+		fprintf(stderr, "invalid width or height.\n");
+		rga_reset(ctx);
+		return -EINVAL;
+	}
+
+	return rga_multiple_transform(ctx, src, dst, src_x, src_y, src_w,
+				      src_h, dst_x, dst_y, dst_w, dst_h,
+				      0, 0, 0);
+}
diff --git a/rockchip/rockchip_rga.h b/rockchip/rockchip_rga.h
new file mode 100644
index 00000000..c94f8d2f
--- /dev/null
+++ b/rockchip/rockchip_rga.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip lectronics Co.Ltd
+ * Authors:
+ *	Yakir Yang <ykk@rock-chips.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _FIMrga_H_
+#define _FIMrga_H_
+
+enum e_rga_buf_type {
+	RGA_IMGBUF_COLOR,
+	RGA_IMGBUF_GEM,
+	RGA_IMGBUF_USERPTR,
+};
+
+#define RGA_PLANE_MAX_NR	3
+#define RGA_MAX_CMD_NR		32
+#define RGA_MAX_GEM_CMD_NR	10
+#define RGA_MAX_CMD_LIST_NR     64
+
+struct rga_image {
+	unsigned int			color_mode;
+	unsigned int			width;
+	unsigned int			height;
+	unsigned int			stride;
+	unsigned int			hstride;
+	unsigned int			fill_color;
+	enum e_rga_buf_type		buf_type;
+	unsigned int			bo[RGA_PLANE_MAX_NR];
+	struct drm_rockchip_rga_userptr	user_ptr[RGA_PLANE_MAX_NR];
+};
+
+struct rga_context {
+	int				fd;
+	int				log;
+	unsigned int			major;
+	unsigned int			minor;
+	struct drm_rockchip_rga_cmd	cmd[RGA_MAX_CMD_NR];
+	struct drm_rockchip_rga_cmd	cmd_buf[RGA_MAX_GEM_CMD_NR];
+	unsigned int			cmd_nr;
+	unsigned int			cmd_buf_nr;
+	unsigned int			cmdlist_nr;
+};
+
+struct rga_context *rga_init(int fd);
+
+void rga_fini(struct rga_context *ctx);
+
+int rga_exec(struct rga_context *ctx);
+
+int rga_solid_fill(struct rga_context *ctx, struct rga_image *img,
+		   unsigned int x, unsigned int y, unsigned int w,
+		   unsigned int h);
+
+int rga_copy(struct rga_context *ctx, struct rga_image *src,
+	     struct rga_image *dst, unsigned int src_x,
+	     unsigned int src_y, unsigned int dst_x, unsigned int dst_y,
+	     unsigned int w, unsigned int h);
+
+int rga_copy_with_scale(struct rga_context *ctx, struct rga_image *src,
+			struct rga_image *dst, unsigned int src_x,
+			unsigned int src_y, unsigned int src_w,
+			unsigned int src_h, unsigned int dst_x,
+			unsigned int dst_y, unsigned int dst_w,
+			unsigned int dst_h);
+
+int rga_copy_with_rotate(struct rga_context *ctx, struct rga_image *src,
+			 struct rga_image *dst, unsigned int src_x,
+			 unsigned int src_y, unsigned int src_w,
+			 unsigned int src_h, unsigned int dst_x,
+			 unsigned int dst_y, unsigned int dst_w,
+			 unsigned int dst_h, unsigned int degree);
+
+int rga_multiple_transform(struct rga_context *ctx, struct rga_image *src,
+			   struct rga_image *dst, unsigned int src_x,
+			   unsigned int src_y, unsigned int src_w,
+			   unsigned int src_h, unsigned int dst_x,
+			   unsigned int dst_y, unsigned int dst_w,
+			   unsigned int dst_h, unsigned int degree,
+			   unsigned int x_mirr, unsigned int y_mirr);
+#endif /* _RGA_H_ */
diff --git a/tests/modetest/modetest.c b/tests/modetest/modetest.c
index e66be660..ca703d03 100644
--- a/tests/modetest/modetest.c
+++ b/tests/modetest/modetest.c
@@ -623,6 +623,7 @@ static struct resources *get_resources(struct device *dev)
 		return NULL;
 
 	drmSetClientCap(dev->fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+	drmSetClientCap(dev->fd, DRM_CLIENT_CAP_ATOMIC, 1);
 
 	res->res = drmModeGetResources(dev->fd);
 	if (!res->res) {
diff --git a/xf86drmMode.c b/xf86drmMode.c
index 207d7be9..fe576539 100644
--- a/xf86drmMode.c
+++ b/xf86drmMode.c
@@ -305,6 +305,31 @@ drm_public int drmModeAddFB2(int fd, uint32_t width, uint32_t height,
 					  buf_id, flags);
 }
 
+int drmModeAddFB2_ext(int fd, uint32_t width, uint32_t height,
+                 uint32_t pixel_format, uint32_t bo_handles[4],
+                 uint32_t pitches[4], uint32_t offsets[4], __u64 modifier[4],
+                 uint32_t *buf_id, uint32_t flags)
+{
+       struct drm_mode_fb_cmd2 f;
+       int ret;
+       int i;
+
+       f.width  = width;
+       f.height = height;
+       f.pixel_format = pixel_format;
+       f.flags = flags;
+       memcpy(f.handles, bo_handles, 4 * sizeof(bo_handles[0]));
+       memcpy(f.pitches, pitches, 4 * sizeof(pitches[0]));
+       memcpy(f.offsets, offsets, 4 * sizeof(offsets[0]));
+       memcpy(f.modifier, modifier, 4 * sizeof(modifier[0]));
+
+       if ((ret = DRM_IOCTL(fd, DRM_IOCTL_MODE_ADDFB2, &f)))
+               return ret;
+
+       *buf_id = f.fb_id;
+       return 0;
+}
+
 drm_public int drmModeRmFB(int fd, uint32_t bufferId)
 {
 	return DRM_IOCTL(fd, DRM_IOCTL_MODE_RMFB, &bufferId);
diff --git a/xf86drmMode.h b/xf86drmMode.h
index a32902f7..b16b51ac 100644
--- a/xf86drmMode.h
+++ b/xf86drmMode.h
@@ -166,6 +166,7 @@ extern "C" {
 #define DRM_MODE_PROP_IMMUTABLE (1<<2)
 #define DRM_MODE_PROP_ENUM      (1<<3) /* enumerated type with text strings */
 #define DRM_MODE_PROP_BLOB      (1<<4)
+#define DRM_MODE_PROP_BITMASK	(1<<5) /* bitmask of enumerated types */
 
 #define DRM_MODE_CURSOR_BO      (1<<0)
 #define DRM_MODE_CURSOR_MOVE    (1<<1)
@@ -380,6 +381,11 @@ int drmModeAddFB2WithModifiers(int fd, uint32_t width, uint32_t height,
 			       const uint64_t modifier[4], uint32_t *buf_id,
 				   uint32_t flags);
 
+extern int drmModeAddFB2_ext(int fd, uint32_t width, uint32_t height,
+                        uint32_t pixel_format, uint32_t bo_handles[4],
+                        uint32_t pitches[4], uint32_t offsets[4], __u64 modifier[4],
+                        uint32_t *buf_id, uint32_t flags);
+
 /**
  * Destroies the given framebuffer.
  */
-- 
2.36.0

